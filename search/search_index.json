{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":".index-page { margin-top: 36px; margin-bottom: 200px; } .index-page a:hover{ color: #00C1A2; text-decoration: none; } .index-card-header { display: flex; flex-direction: row; align-items: flex-end; padding: 24px 8px; gap: 24px; width: 1200px; } .index-card-header-content { display: flex; flex-direction: column; align-items: flex-start; padding: 0px; gap: 16px; width: 768px; } .index-card-header-nav{ display: flex; flex-direction: column; align-items: flex-start; padding: 20px; gap: 8px; width: 360px; background: #F3F6F8; border-radius: 16px; flex: none; order: 1; flex-grow: 0; } .index-page a { color: #20272C } .index-card-lg { display: flex; flex-direction: column; justify-content: center; align-items: flex-start; gap: 16px; width: 588px; height: 200px; padding: 24px; border-radius: 12px; border: 1px solid #F3F6F8; cursor: pointer; } .index-card-sm { display: flex; flex-direction: column; justify-content: center; align-items: flex-start; gap: 16px; width: 282px; left: 0px; top: 0px; border-radius: 12px; padding: 24px; border: 1px solid #F3F6F8; cursor: pointer; } .index-footer { box-sizing: border-box; display: flex; flex-direction: row; justify-content: center; align-items: center; padding: 24px; width: 100vw; height: 110px; border-top: 1px solid #F3F6F8; position: fixed; bottom: 0px; left: 0px; background: white; } .index-footer-content { display: flex; flex-direction: row; align-items: flex-start; padding: 10px; gap: 10px; width: 1200px; } .index-footer-content > p { font-family: 'Karla'; font-style: normal; font-weight: 400; font-size: 14px; line-height: 150%; letter-spacing: -0.02em; color: #63727E; } .index-topic-header { margin: 0 } .index-card-lg:hover { border: 1px solid #D9E0E6; } .index-card-sm:hover { border: 1px solid #D9E0E6; } .index-container-top{ display: flex; flex-direction: row; align-items: flex-start; padding: 0px; gap: 24px; margin-top: 24px; } .index-card-header-content > h2 { margin: 0; } .lottie-button{ display: flex; flex-direction: row; justify-content: center; align-items: center; padding: 4px 12px; gap: 8px; height: 32px; background: #F3F6F8; border-radius: 8px; border: 0; color: #20272C; } .lottie-button:hover { background: #D9E0E6; } .lottie-button:focus { background: #F3F6F8; /* focus-on-light */ box-shadow: 0px 0px 0px 1px #FFFFFF, 0px 0px 0px 3px #00DDB3; } @media (max-width: 800px) { .index-card-header-nav { display: none; } } @media (max-height: 1200px) { .index-page { margin-bottom: 0px; } .index-footer { margin-top: 64px; margin-left: -16px; position: static; } } @media (max-width: 1200px) { .index-card-header{ width: 100%; } } @media (max-width: 1000px) { .index-card-header { padding: 24px 0; } .index-container-top { flex-direction : column; padding: 0; } .index-card-lg { width: 100%; height: auto; } .index-card-sm { width: 100%; height: auto; } .index-footer { padding: 16px; } .index-page { margin-bottom: 0px; } .index-footer { margin-top: 64px; margin-left: -16px; position: static; } } A human's guide to the Lottie format Lottie is a vector animation format, using JSON to represent its data. This guide aims to provide a human-readable description of the format and how everything works within it. Read the guide Topics Introduction Bouncy Ball Lottie from Scratch Bezier Curves Precompositions Values Tips for Rendering JSON Schema Advanced Interactions Lottie Format This page describes values and other objects used throughout the Lottie format. Lottie from Scratch In this example, we'll build a simple lottie animation from scratch. Lottie Playground JSON Editor Lottie Builder Lottie-Player Easily embed and play Lottie animations in websites. Lottie-React Easily add Lottie animations to your React projects. Lottie-Svelte Svelte provides a Lottie player using the lottie-web library. Lottie-Vue Vue component for the Lottie Web Player. LottieFiles is by Design Barn Inc. Copyright \u00a9 2022 Design Barn Inc. All rights reserved.","title":"Home"},{"location":"Introduction/","text":"A human's guide to the Lottie format Lottie is a vector animation format, using JSON to represent its data. This guide aims to provide a human-readable description of the format and how everything works within it. This documentation assumes the reader is already familiar with the following concepts: JSON Vector Graphics Bezier Curves Tweening Easing Functions What this guide is This guide aims to describe the lottie format in its entirety, while also give in-depth descriptions of how every aspect works, which you can't get from just looking at a list of JSON attributes. It contains a section that shows a breakdown of simple lottie animation describing what is going on as an introduction for the format. It also has reference pages which go over the details of every object you can find in a lottie file, and a description of its most notable attributes. It provides a complete JSON schema , this is intended for people who want to write tools to parse or generate lottie and need to get every little detail. Finally it has a section with details about rendering , which gives tips and provides pseudo-code on how to draw various elements to match with the lottie web player. What this guide is not You won't find here information on how to animate, or how to export a lottie file from your editor of choice. It also won't give information on how to embed lottie animations in your application or website. This is because there's already a lot of documentation for creating and using lottie animations, while this aims at providing a description of the file format itself. For the Impatient The top level JSON object is the Animation . Note that some lottie players require certain JSON keys to be presents before others in the file to play properly. Objects within the JSON may have a mixture of animatable and non-animatable properties. If a property is not animated, the value is represented as usual within the JSON. If it's animated, it has a special representation . Interactive Explanation If you have a lottie animation and you want to see an interactive description of its contents, you can visit the JSON Editor page. Anatomy of a Lottie file Go to the next page for a breakdown of a simple lottie animation. JSON Schema This guide provides a human-readable description of the format, but if you want a machine-readable description, we also have a JSON schema . Media Type The registered internet media type for lottie is video/lottie+json with .lot file extension. Other Resources Lottie documentation from python-lottie Lottie community documentation Lottie community schema","title":"Introduction"},{"location":"Introduction/#a-humans-guide-to-the-lottie-format","text":"Lottie is a vector animation format, using JSON to represent its data. This guide aims to provide a human-readable description of the format and how everything works within it. This documentation assumes the reader is already familiar with the following concepts: JSON Vector Graphics Bezier Curves Tweening Easing Functions","title":"A human's guide to the Lottie format"},{"location":"Introduction/#what-this-guide-is","text":"This guide aims to describe the lottie format in its entirety, while also give in-depth descriptions of how every aspect works, which you can't get from just looking at a list of JSON attributes. It contains a section that shows a breakdown of simple lottie animation describing what is going on as an introduction for the format. It also has reference pages which go over the details of every object you can find in a lottie file, and a description of its most notable attributes. It provides a complete JSON schema , this is intended for people who want to write tools to parse or generate lottie and need to get every little detail. Finally it has a section with details about rendering , which gives tips and provides pseudo-code on how to draw various elements to match with the lottie web player.","title":"What this guide is"},{"location":"Introduction/#what-this-guide-is-not","text":"You won't find here information on how to animate, or how to export a lottie file from your editor of choice. It also won't give information on how to embed lottie animations in your application or website. This is because there's already a lot of documentation for creating and using lottie animations, while this aims at providing a description of the file format itself.","title":"What this guide is not"},{"location":"Introduction/#for-the-impatient","text":"The top level JSON object is the Animation . Note that some lottie players require certain JSON keys to be presents before others in the file to play properly. Objects within the JSON may have a mixture of animatable and non-animatable properties. If a property is not animated, the value is represented as usual within the JSON. If it's animated, it has a special representation .","title":"For the Impatient"},{"location":"Introduction/#interactive-explanation","text":"If you have a lottie animation and you want to see an interactive description of its contents, you can visit the JSON Editor page.","title":"Interactive Explanation"},{"location":"Introduction/#anatomy-of-a-lottie-file","text":"Go to the next page for a breakdown of a simple lottie animation.","title":"Anatomy of a Lottie file"},{"location":"Introduction/#json-schema","text":"This guide provides a human-readable description of the format, but if you want a machine-readable description, we also have a JSON schema .","title":"JSON Schema"},{"location":"Introduction/#media-type","text":"The registered internet media type for lottie is video/lottie+json with .lot file extension.","title":"Media Type"},{"location":"Introduction/#other-resources","text":"Lottie documentation from python-lottie Lottie community documentation Lottie community schema","title":"Other Resources"},{"location":"advanced_interactions/","text":"Advanced Interactions This page will describe how to create lotties with advanced interactivity, specifically when used with lottie-web player. This page is divided into \"levels\", each level adds more obscure features which are less portable but add increased interaction capabilities. There are 9 levels below Regular Lottie , which is the same as the number of circles of hell in Dante's Inferno. Reader discretion is advised. The techniques described below require knowledge on the following topics: The Lottie format Lottie expressions The lottie-web player ECMAScript / JavaScript DOM and events .playground_html > div > svg { border: 1px solid #ccc; } pre { margin-top: 0; } #content-container .nav.nav-tabs { height: 45px; } Level 0: Regular Lotties Lotties can play an animation, loading an animation looks something like this: Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 1, \"k\": [ {\"t\": 0, \"s\": [0], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 360, \"s\": [360]} ]}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } <div id=\"level0\"></div> var container = document.getElementById(\"level0\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 1, \"k\": [ {\"t\": 0, \"s\": [0], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 360, \"s\": [360]} ]}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } ; var container = document.getElementById(\"level0\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); })(); By themselves lotties just play an animation, but luckily lottie-web provides some utility functions, note how in the Script above we are storing the variable anim returned by bodymovin.loadAnimation . Level 1: Controlling Playback You can play around with the anim object like setting the current frame, pausing stopping etc. There's also the LottieFiles interactivity library that makes some of these interactions easier to create. Here's an example of a lottie changing based on mouse position: Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 1, \"k\": [ {\"t\": 0, \"s\": [0], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 360, \"s\": [360]} ]}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } <div id=\"level1\"></div> var container = document.getElementById(\"level1\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: false, animationData: json, }; var anim = bodymovin.loadAnimation(options); container.addEventListener(\"mousemove\", ev => { var rect = container.getBoundingClientRect(); var t = (ev.clientX - rect.left) / rect.width; anim.goToAndStop(t * json.op, true); }); (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 1, \"k\": [ {\"t\": 0, \"s\": [0], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 360, \"s\": [360]} ]}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } ; var container = document.getElementById(\"level1\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: false, animationData: json, }; var anim = bodymovin.loadAnimation(options); container.addEventListener(\"mousemove\", ev => { var rect = container.getBoundingClientRect(); var t = (ev.clientX - rect.left) / rect.width; anim.goToAndStop(t * json.op, true); }); })(); Level 2: SVG Styling When using the SVG renderer, you can make use of CSS styling by specifying a value for cl in the lottie layers. In the example below, CSS rules highlight the lottie layer showing a rectangle when the mouse is over it. Lottie CSS HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [400, 300]}, \"s\": {\"a\": 0, \"k\": [150, 150]}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.769, 0.851, 0.961]} } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"cl\": \"lottie_level_2\", \"shapes\": [ { \"ty\": \"rc\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [256, 128]}, \"r\": {\"a\": 0, \"k\": 3}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]} } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [100, 200]}, \"s\": {\"a\": 0, \"k\": [150, 150]}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.769, 0.851, 0.961]} } ] } ] } .lottie_level_2:hover { opacity: 10%; } .lottie_level_2 { cursor: pointer; } <div id=\"level2\"></div> var container = document.getElementById(\"level2\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: false, animationData: json, }; var anim = bodymovin.loadAnimation(options); .lottie_level_2:hover { opacity: 10%; } .lottie_level_2 { cursor: pointer; } (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [400, 300]}, \"s\": {\"a\": 0, \"k\": [150, 150]}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.769, 0.851, 0.961]} } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"cl\": \"lottie_level_2\", \"shapes\": [ { \"ty\": \"rc\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [256, 128]}, \"r\": {\"a\": 0, \"k\": 3}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]} } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [100, 200]}, \"s\": {\"a\": 0, \"k\": [150, 150]}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.769, 0.851, 0.961]} } ] } ] } ; var container = document.getElementById(\"level2\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: false, animationData: json, }; var anim = bodymovin.loadAnimation(options); })(); Level 3: Basic Expressions Lotties can have expressions , they are basically small snippets of JavaScript code used to modify the value of animated properties. Below the star rotation is animated using an expression instead of using keyframes. Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0, \"x\": \"var $bm_rt = time * 60;\"}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } <div id=\"level3\"></div> var container = document.getElementById(\"level3\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0, \"x\": \"var $bm_rt = time * 60;\"}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } ; var container = document.getElementById(\"level3\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); })(); Level 4: Advanced Expressions Within expressions you can access properties from other layers, and since they are all JavaScript objects, you can add your own properties to them. You can make a layer follow the position of another: // Set the layer position to follow the X position of another layer var other_position = thisComp(\"layer_name\").transform.position; var $bm_rt = [other_position[0], value[1]]; Since property values are initialized to their non-expression value, you can't access updated value of the property you are changing from the expression. However you can work around this by storing state in the layer object. // Get size of the rect var size = thisLayer.content(1).size; // Initialize everything at the start if ( time == 0 ) { thisLayer.my_value = size[0] / 2; thisLayer.speed = 60; thisLayer.direction = 1; thisLayer.prev_time = 0; } // Handle the case when the lottie has looped and time has reset // as it might not be exactly 0 if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; // Find the time delta to keep constant speed var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Increment x thisLayer.my_value += dt * thisLayer.speed * thisLayer.direction; var x = thisLayer.my_value; if ( x >= thisComp.width - size[0] / 2) thisLayer.direction = -1; else if ( x <= size[0] / 2 ) thisLayer.direction = 1; // Calculate y based on x var y = value[1] + Math.sin((x / thisComp.width) * Math.PI * 2) * (thisComp.height - size[1]) / 2; var $bm_rt = [x, y]; Here's an example: Note that the JSON uses ECMAScript's backtick string syntax for clarity, in a real Lottie file you'd need to put it into a single line. Newlines in the expression string work fine as long as the last line of the expression doesn't end in a single line comment. Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 60, \"st\": 0, \"nm\": \"layer_name\", \"ks\": { \"p\": { \"a\": 0, \"k\": [0, 256], \"x\": ` // Get size of the rect var size = thisLayer.content(1).size; // Initialize everything at the start if ( time == 0 ) { thisLayer.my_value = size[0] / 2; thisLayer.speed = 120; thisLayer.direction = 1; thisLayer.prev_time = 0; } // Handle the case when the lottie has looped and time has reset // as it might not be exactly 0 if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; // Find the time delta to keep constant speed var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Increment x thisLayer.my_value += dt * thisLayer.speed * thisLayer.direction; var x = thisLayer.my_value; if ( x >= thisComp.width - size[0] / 2) thisLayer.direction = -1; else if ( x <= size[0] / 2 ) thisLayer.direction = 1; // Calculate y based on x var y = value[1] + Math.sin((x / thisComp.width) * Math.PI * 2) * (thisComp.height - size[1]) / 2; var $bm_rt = [x, y]; ` } }, \"shapes\": [ { \"ty\": \"rc\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [80, 80]}, \"r\": {\"a\": 0, \"k\": 3}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]} } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 3600, \"st\": 0, \"ks\": { \"p\": { \"a\": 0, \"k\": [0, 256], \"x\": ` // Set the layer position to follow the X position of another layer var other_position = thisComp(\"layer_name\").transform.position; var $bm_rt = [other_position[0], value[1]]; ` } }, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [150, 150]}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.769, 0.851, 0.961]} } ] } ] } <div id=\"level4\"></div> var container = document.getElementById(\"level4\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 60, \"st\": 0, \"nm\": \"layer_name\", \"ks\": { \"p\": { \"a\": 0, \"k\": [0, 256], \"x\": ` // Get size of the rect var size = thisLayer.content(1).size; // Initialize everything at the start if ( time == 0 ) { thisLayer.my_value = size[0] / 2; thisLayer.speed = 120; thisLayer.direction = 1; thisLayer.prev_time = 0; } // Handle the case when the lottie has looped and time has reset // as it might not be exactly 0 if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; // Find the time delta to keep constant speed var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Increment x thisLayer.my_value += dt * thisLayer.speed * thisLayer.direction; var x = thisLayer.my_value; if ( x >= thisComp.width - size[0] / 2) thisLayer.direction = -1; else if ( x <= size[0] / 2 ) thisLayer.direction = 1; // Calculate y based on x var y = value[1] + Math.sin((x / thisComp.width) * Math.PI * 2) * (thisComp.height - size[1]) / 2; var $bm_rt = [x, y]; ` } }, \"shapes\": [ { \"ty\": \"rc\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [80, 80]}, \"r\": {\"a\": 0, \"k\": 3}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]} } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 3600, \"st\": 0, \"ks\": { \"p\": { \"a\": 0, \"k\": [0, 256], \"x\": ` // Set the layer position to follow the X position of another layer var other_position = thisComp(\"layer_name\").transform.position; var $bm_rt = [other_position[0], value[1]]; ` } }, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [150, 150]}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.769, 0.851, 0.961]} } ] } ] } ; var container = document.getElementById(\"level4\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); })(); Level 5: Breaking Time In the previous examples, we had a condition at the start of some expressions initializing custom attributes when time is equal to 0. if ( time == 0 ) thisLayer.my_property = \"some value\"; This works because the first frame is always at time 0 but it isn't a super reliable check: when the player loops, the time can go back to 0 which would result in your properties being initialized again. If you want your interactions to carry over across loops, a better approach is to use a condition where you check for undefined layer properties: if ( thisLayer.my_property === undefined ) thisLayer.my_property = \"some value\"; For smooth value increments, we need to properly handle the time variable within expressions. Similarly to what we've done before the following example shows how to initialize and update a variable over time; // Initialization if ( thisLayer.last_time === undefined ) { thisLayer.last_time = time; thisLayer.value = 0; thisLayer.speed = 600; } // Handle looping if ( time < thisLayer.last_time ) thisLayer.last_time = time; // `dt` is the time since the last expression evaluation in seconds var dt = time - thisLayer.last_time; // Update the time management variable thisLayer.last_time = time; // Increment thisLayer.value = dt * thisLayer.speed; This approach allows you to change values regardless of playback speed and framerate. I also allows you to continue the movement when the lottie reaches its last frame and starts looping. In the following example, the lottie is set to loop every second but it keeps going indefinitely because of the time management setup: Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.prev_time === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; thisLayer.dx = 1; thisLayer.dy = 1; thisLayer.prev_time = 0; } // Time management if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Animation thisLayer.px += thisLayer.dx * dt * 100; thisLayer.py += thisLayer.dy * dt * 120; var radius = thisLayer.content(1).outerRadius; if ( thisLayer.px < radius ) thisLayer.dx = 1; else if ( thisLayer.px > thisComp.width - radius ) thisLayer.dx = -1; if ( thisLayer.py < radius ) thisLayer.dy = 1; else if ( thisLayer.py > thisComp.height - radius ) thisLayer.dy = -1; // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], } } ] } ] } <div id=\"level5\"></div> var options = { container: document.getElementById(\"level5\"), renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.prev_time === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; thisLayer.dx = 1; thisLayer.dy = 1; thisLayer.prev_time = 0; } // Time management if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Animation thisLayer.px += thisLayer.dx * dt * 100; thisLayer.py += thisLayer.dy * dt * 120; var radius = thisLayer.content(1).outerRadius; if ( thisLayer.px < radius ) thisLayer.dx = 1; else if ( thisLayer.px > thisComp.width - radius ) thisLayer.dx = -1; if ( thisLayer.py < radius ) thisLayer.dy = 1; else if ( thisLayer.py > thisComp.height - radius ) thisLayer.dy = -1; // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], } } ] } ] } ; var options = { container: document.getElementById(\"level5\"), renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); })(); Level 6: Injecting Data Remember the anim object we get from lottie-web? It's the key for more advanced interactions. Internally it stores its lottie structure and the objects being passed to expression as thisComp and thisLayer . Being able to access these objects allows us to pass data directly to the lottie expressions. The object corresponding to thisComp can be accessed as anim.renderer.compInterface , and from there you can get the layers by name or index (see the Composition expression object). In the example below the rotation direction and color of the star change based on whether the mouse is over the element containing the lottie. // Time management as before if ( time == 0 ) { thisLayer.angle = 0; thisLayer.prev_time = 0; } if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; var direction = thisComp.counter_clockwise ? -1 : 1; thisLayer.angle += dt * direction * 60; var $bm_rt = thisLayer.angle; Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0, \"x\": ` // Time management as before if ( thisLayer.prev_time === undefined ) { thisLayer.angle = 0; thisLayer.prev_time = 0; } if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; var direction = thisComp.mouse_is_over ? -1 : 1; thisLayer.angle += dt * direction * 60; var $bm_rt = thisLayer.angle; `}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], \"x\": \"var $bm_rt = thisComp.mouse_is_over ? [0.196, 0.314, 0.69] : value;\" }, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } <div id=\"level6\"></div> var container = document.getElementById(\"level6\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); container.addEventListener(\"mouseenter\", () => { anim.renderer.compInterface.mouse_is_over = true; }); container.addEventListener(\"mouseleave\", () => { anim.renderer.compInterface.mouse_is_over = false; }); (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0, \"x\": ` // Time management as before if ( thisLayer.prev_time === undefined ) { thisLayer.angle = 0; thisLayer.prev_time = 0; } if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; var direction = thisComp.mouse_is_over ? -1 : 1; thisLayer.angle += dt * direction * 60; var $bm_rt = thisLayer.angle; `}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], \"x\": \"var $bm_rt = thisComp.mouse_is_over ? [0.196, 0.314, 0.69] : value;\" }, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } ; var container = document.getElementById(\"level6\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); container.addEventListener(\"mouseenter\", () => { anim.renderer.compInterface.mouse_is_over = true; }); container.addEventListener(\"mouseleave\", () => { anim.renderer.compInterface.mouse_is_over = false; }); })(); Level 7: Automatic Event Handlers So far the interaction logic has been done by JavaScript on the browser. In this section we'll add all the logic in the JSON itself and write a wrapper script that sets up the animation. This allows you to have self-contained lotties you can embed in a web page that will handle events on their own. Lottie JSON Extension First thing is to write the expressions in the Lottie itself. Since Lottie is just a JSON file, it's easy to add custom values: { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"click\": \"/*event handler code*/\" } } Now we need to add some JavaScript so we can listen to the events fired by the DOM and execute expressions: for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", expression); container.addEventListener(ev_type, expression_function); } Preparing Globals While the above would work, we should expose some objects for it to be useful. The lottie player define a bunch of objects and functions for expressions, but we don't really need all of them since the even handlers only need to pass along the information that an event has occurred. We will define thisComp and time to be the same as the globals of the same name you'd expect to find an expressions, and pass them to the event handling function: function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } After this step, you're all set to hanle DOM events automatically from a lottie. The next couple steps add some polish to the event interface for a smoother experience. Mouse Events Events like click , mousemove , etc. provide the mouse coordinates, which you might want to access from within the lottie. By default these coordinates aren't in the same space as the values inside the lottie so we need to scale them appropriately: function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } Now we can reference the position in the lottie expression: { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"click\": ` var star = thisComp(\"star\"); star.px = event.lottie_x; star.py = event.lottie_y; ` } } In the example below you can click to move the star to a given position: Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"click\": ` var star = thisComp(\"star\"); star.px = event.lottie_x; star.py = event.lottie_y; ` }, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], } } ] } ] } <div id=\"level7_mouse\"></div> var container = document.getElementById(\"level7_mouse\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"click\": ` var star = thisComp(\"star\"); star.px = event.lottie_x; star.py = event.lottie_y; ` }, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], } } ] } ] } ; var container = document.getElementById(\"level7_mouse\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } })(); Keyboard Events To allow keyboard events to be fired correctly, you need to ensure the element containing the lottie is focusable. You can do this by setting the tabindex attribute in HTML or with JavaScript. <div id=\"level7_keyboard\" tabindex=\"0\"></div> or container.setAttribute(\"tabindex\", \"0\"); In the example below we'll move a layer based on whether the user is pressing the left and right arrow keys. A good solution for this is to keep track of which key has been pressed and react accordingly. The event handler code is simple enough: For keydown : if ( event.key == \"ArrowLeft\" ) thisComp(\"star\").left = true; else if ( event.key == \"ArrowRight\" ) thisComp(\"star\").right = true; // Prevent scrolling and other browser shortcuts event.preventDefault(); keyup : if ( event.key == \"ArrowLeft\" ) thisComp(\"star\").left = false; else if ( event.key == \"ArrowRight\" ) thisComp(\"star\").right = false; // Prevent scrolling and other browser shortcuts event.preventDefault(); We should also reset these when the lottie element loses focus: focusout : thisComp(\"star\").left = false; thisComp(\"star\").right = false; We need to add some logic to the layer position property: // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; thisLayer.left = false; thisLayer.right = false; thisLayer.prev_time = 0; } // Handle time wrapping around if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; // Time delta var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Figure which direction to move var direction = 0; if ( thisLayer.left && thisLayer.right ) direction = 0; else if ( thisLayer.left ) direction = -1; else if ( thisLayer.right ) direction = 1; // Move if ( direction != 0 ) { // 600 is the \"speed\", you need to consider that dt is the time // in seconds since the previous frame so it's usally a rather small value thisLayer.px += direction * dt * 600; var radius = thisLayer.content(1).outerRadius; thisLayer.px = clamp(thisLayer.px, radius, thisComp.width - radius); } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; The example below shows how to handle keyboard event. Focusing on the element changes the star color. When focused (blue star) left and right arrow keys move the star in the corresponding direction. Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"keydown\": ` if ( event.key == \"ArrowLeft\" ) thisComp(\"star\").left = true; else if ( event.key == \"ArrowRight\" ) thisComp(\"star\").right = true; // Prevent scrolling and other browser shortcuts event.preventDefault(); `, \"keyup\": ` if ( event.key == \"ArrowLeft\" ) thisComp(\"star\").left = false; else if ( event.key == \"ArrowRight\" ) thisComp(\"star\").right = false; // Prevent scrolling and other browser shortcuts event.preventDefault(); `, \"focusin\": \"thisComp.focus = true;\", \"focusout\": ` thisComp(\"star\").left = false; thisComp(\"star\").right = false; thisComp.focus = false; `, }, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; thisLayer.left = false; thisLayer.right = false; thisLayer.prev_time = 0; } // Handle time wrapping around if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; // Time delta var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Figure which direction to move var direction = 0; if ( thisLayer.left && thisLayer.right ) direction = 0; else if ( thisLayer.left ) direction = -1; else if ( thisLayer.right ) direction = 1; // Move if ( direction != 0 ) { // 600 is the \"speed\", you need to consider that dt is the time // in seconds since the previous frame so it's usally a rather small value thisLayer.px += direction * dt * 600; var radius = thisLayer.content(1).outerRadius; thisLayer.px = clamp(thisLayer.px, radius, thisComp.width - radius); } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], \"x\": \"var $bm_rt = thisComp.focus ? [0.196, 0.314, 0.69] : value;\" } } ] } ] } <div id=\"level7_keyboard\" tabindex=\"0\"></div> var container = document.getElementById(\"level7_keyboard\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"keydown\": ` if ( event.key == \"ArrowLeft\" ) thisComp(\"star\").left = true; else if ( event.key == \"ArrowRight\" ) thisComp(\"star\").right = true; // Prevent scrolling and other browser shortcuts event.preventDefault(); `, \"keyup\": ` if ( event.key == \"ArrowLeft\" ) thisComp(\"star\").left = false; else if ( event.key == \"ArrowRight\" ) thisComp(\"star\").right = false; // Prevent scrolling and other browser shortcuts event.preventDefault(); `, \"focusin\": \"thisComp.focus = true;\", \"focusout\": ` thisComp(\"star\").left = false; thisComp(\"star\").right = false; thisComp.focus = false; `, }, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; thisLayer.left = false; thisLayer.right = false; thisLayer.prev_time = 0; } // Handle time wrapping around if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; // Time delta var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Figure which direction to move var direction = 0; if ( thisLayer.left && thisLayer.right ) direction = 0; else if ( thisLayer.left ) direction = -1; else if ( thisLayer.right ) direction = 1; // Move if ( direction != 0 ) { // 600 is the \"speed\", you need to consider that dt is the time // in seconds since the previous frame so it's usally a rather small value thisLayer.px += direction * dt * 600; var radius = thisLayer.content(1).outerRadius; thisLayer.px = clamp(thisLayer.px, radius, thisComp.width - radius); } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], \"x\": \"var $bm_rt = thisComp.focus ? [0.196, 0.314, 0.69] : value;\" } } ] } ] } ; var container = document.getElementById(\"level7_keyboard\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } })(); Level 8: Sound Effects Lottie web supports playing audio layers with the help of Howler . By default the level of control you get with sound is rather limited but we can find a way around it. The issue is audio layers don't have a scriptable property that controls playback which means we can't attach an expression to audio layers. The trick is to wrap an audio layer into a precomp and to use an expression on its time remapping property. We can then control playback as follows: if ( thisLayer.last_time === undefined ) { thisLayer.last_time = time; // This variable wil control whether the sound is played thisLayer.sound_play = 0; // This should be the time in seconds you want the sound to play for // To get the best results, it should be just short of the duration // of the audio file thisLayer.sound_duration = 1; } // Usual time management stuff if ( time < thisLayer.last_time ) thisLayer.last_time = time; var dt = time - thisLayer.last_time; thisLayer.last_time = time; // Default to not playing var $bm_rt = 0; if ( thisLayer.sound_play > 0 ) { $bm_rt = thisLayer.sound_duration - thisLayer.sound_play; thisLayer.sound_play -= dt; } In the example that follows you can click on the lottie to make it play a sound. The precomp also has a green cicle that shows playback progress. Lottie HTML Script Result { \"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 180, \"w\": 512, \"h\": 512, \"ddd\": 0, \"events\": { \"click\": \"thisComp('sound_control').sound_play = thisComp('sound_control').sound_duration\" }, \"assets\": [ { \"id\": \"sound\", \"u\": \"/lottie-docs/examples/\", \"p\": \"sound.mp3\", \"e\": 0 }, { \"id\": \"precomp\", \"layers\": [ { \"nm\": \"a\", \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 1, \"k\": [ { \"t\": 0, \"s\": [0, 256], \"i\": {\"x\": 0, \"y\": 0}, \"o\": {\"x\": 1, \"y\": 1}, }, { \"t\": 60, \"s\": [512, 256], } ]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, }, { \"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 1, 0]}, \"o\": {\"a\": 0, \"k\": 100}, } ] }, { \"ty\": 6, \"ip\": 1, \"op\": 60, \"st\": 1, \"refId\": \"sound\", \"au\": { \"lv\": {\"a\": 0, \"k\": [100, 100]} } } ] } ], \"markers\": [], \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 180, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": { \"a\": 1, \"k\": [ { \"t\": 0, \"s\": [0], \"i\": {\"x\": 0, \"y\": 0}, \"o\": {\"x\": 1, \"y\": 1} }, { \"t\": 180, \"s\": [360] } ] }, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 1], \"x\": ` var amount = thisComp('sound_control').sound_play ?? 0; var $bm_rt = [amount, 0, 0]; `, } } ] }, { \"nm\": \"sound_control\", \"ty\": 0, \"ip\": 0, \"op\": 180, \"st\": 0, \"ks\": {}, \"refId\": \"precomp\", \"w\": 512, \"h\": 512, \"tm\": { \"a\": 1, \"k\": [{ \"t\": 0, \"s\": [0], \"i\": {\"x\": 0, \"y\": 0}, \"o\": {\"x\": 1, \"y\": 1} }, { \"t\": 180, \"s\": [0] } ], \"x\": ` if ( thisLayer.last_time === undefined ) { thisLayer.last_time = time; // This variable wil control whether the sound is played thisLayer.sound_play = 0; // This should be the time in seconds you want the sound to play for thisLayer.sound_duration = 1; } // Usual time management stuff if ( time < thisLayer.last_time ) thisLayer.last_time = time; var dt = time - thisLayer.last_time; thisLayer.last_time = time; // Default to not playing var $bm_rt = 100; if ( thisLayer.sound_play > 0 ) { $bm_rt = thisLayer.sound_duration - thisLayer.sound_play; thisLayer.sound_play -= dt; }` } } ] } <div id=\"level8\"></div> var container = document.getElementById(\"level8\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } (function(){var json = { \"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 180, \"w\": 512, \"h\": 512, \"ddd\": 0, \"events\": { \"click\": \"thisComp('sound_control').sound_play = thisComp('sound_control').sound_duration\" }, \"assets\": [ { \"id\": \"sound\", \"u\": \"/lottie-docs/examples/\", \"p\": \"sound.mp3\", \"e\": 0 }, { \"id\": \"precomp\", \"layers\": [ { \"nm\": \"a\", \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 1, \"k\": [ { \"t\": 0, \"s\": [0, 256], \"i\": {\"x\": 0, \"y\": 0}, \"o\": {\"x\": 1, \"y\": 1}, }, { \"t\": 60, \"s\": [512, 256], } ]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, }, { \"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 1, 0]}, \"o\": {\"a\": 0, \"k\": 100}, } ] }, { \"ty\": 6, \"ip\": 1, \"op\": 60, \"st\": 1, \"refId\": \"sound\", \"au\": { \"lv\": {\"a\": 0, \"k\": [100, 100]} } } ] } ], \"markers\": [], \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 180, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": { \"a\": 1, \"k\": [ { \"t\": 0, \"s\": [0], \"i\": {\"x\": 0, \"y\": 0}, \"o\": {\"x\": 1, \"y\": 1} }, { \"t\": 180, \"s\": [360] } ] }, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 1], \"x\": ` var amount = thisComp('sound_control').sound_play ?? 0; var $bm_rt = [amount, 0, 0]; `, } } ] }, { \"nm\": \"sound_control\", \"ty\": 0, \"ip\": 0, \"op\": 180, \"st\": 0, \"ks\": {}, \"refId\": \"precomp\", \"w\": 512, \"h\": 512, \"tm\": { \"a\": 1, \"k\": [{ \"t\": 0, \"s\": [0], \"i\": {\"x\": 0, \"y\": 0}, \"o\": {\"x\": 1, \"y\": 1} }, { \"t\": 180, \"s\": [0] } ], \"x\": ` if ( thisLayer.last_time === undefined ) { thisLayer.last_time = time; // This variable wil control whether the sound is played thisLayer.sound_play = 0; // This should be the time in seconds you want the sound to play for thisLayer.sound_duration = 1; } // Usual time management stuff if ( time < thisLayer.last_time ) thisLayer.last_time = time; var dt = time - thisLayer.last_time; thisLayer.last_time = time; // Default to not playing var $bm_rt = 100; if ( thisLayer.sound_play > 0 ) { $bm_rt = thisLayer.sound_duration - thisLayer.sound_play; thisLayer.sound_play -= dt; }` } } ] } ; var container = document.getElementById(\"level8\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } })(); Interlude: Writing a Small Wrapper Follows a JavaScript class that sets everything we've seen until now in a self-contained object. class LottieInteractionPlayer { constructor(container, custom_options={}) { if ( typeof container == \"string\" ) this.container = document.getElementById(container); else this.container = container; this.anim = null; this.custom_options = custom_options; // needed by keyup/down if ( !container.hasAttribute(\"tabindex\") ) container.setAttribute(\"tabindex\", \"0\"); this.handlers = {}; this._container_event_listener = this.container_event.bind(this); } // Deep copy lottie JSON lottie_clone(json) { return JSON.parse(JSON.stringify(json)); } load(lottie, resize = true) { // Options var options = { container: this.container, renderer: 'svg', loop: true, autoplay: true, // Clone because the player modifies the passed object animationData = this.lottie_clone(lottie); ...this.custom_options, }; if ( resize ) { this.container.style.width = lottie.w + \"px\"; this.container.style.height = lottie.h + \"px\"; } // Clean up this.clear(); // Setup handlers this.handlers = {}; if ( lottie.events ) { for ( var [name, func] of Object.entries(lottie.events) ) { this.handlers[name] = this.expression_to_event_handler(func); this.container.addEventListener(name, this._container_event_listener); } } // Create lottie player this.anim = bodymovin.loadAnimation(options); } // Destroy the animation clear() { if ( this.anim != null ) { try { this.anim.destroy(); this.anim = null; } catch ( e ) {} } for ( let name of Object.keys(this.handlers) ) this.container.removeEventListener(name, this._container_event_listener); } // Get the expression `thisComp` global get thisComp() { return this.anim.renderer.compInterface; } // Get the expression `time` global get time() { return this.anim.renderer.renderedFrame / this.anim.renderer.globalData.frameRate; } // Get an expression layer layer(name) { return this.thisComp(name); } // Handles an event from the container element container_event(ev) { this.prepare_lottie_event(ev); if ( this.handlers[ev.type] ) this.handle_lottie_event(ev, this.handlers[ev.type]); } // Adds useful attributes to an event object prepare_lottie_event(ev) { if ( ev.clientX !== undefined ) { var rect = this.container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * this.thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * this.thisComp.height; } } // Handles an event given a handler handle_lottie_event(ev, handler) { handler(ev, this.thisComp, this.time); } // Sets up an event handler expression_to_event_handler(expr) { return Function(\"event\", \"thisComp\", \"time\", expr); } } Level 9: Patching the Renderer So far we've used the vanilla lottie-web player without modifications. This is good for the interactions described until now but for more advanced stuff we need to patch the player. The code in this level assumes you have a wrapper class similar to the one described in the interlude. Why Follows a description of some use cases that don't work with the current approach. Initializing Values So far we've initialized custom layer attributes in the expressions using them. We started by checking if time is 0: // Initialize everything at the start if ( time == 0 ) { thisLayer.my_value = size[0] / 2; thisLayer.speed = 60; thisLayer.direction = 1; thisLayer.prev_time = 0; } Since that isn't always reliable, we moved on to checking if the attributes are undefined: // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; } While this works, it's a bit annoying because you don't know if you can access another layer's custom attributes on frame 0, so it would be nice to have an event for this: { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"load\": \"thisComp('mylayer').value = 123;\" } } We have the options of the DOMLoaded event from bodymovin: load(lottie, resize = true) { // (omitted the part of the code that's the same as before) // Create lottie player this.anim = bodymovin.loadAnimation(options); this.anim.addEventListener(\"DOMLoaded\", this._lottie_loaded_event.bind(this)); } _lottie_loaded_event() { // Create a dummy event object and invoke the this.container.dispatchEvent(new Event(\"load\"), {}); } The issue with this is such event can only be fired after the first frame has been renderer (and expressions have been evaluated at least once). DOM Events from Layers Until now the event handling has been done on the container element. Since all the layers result in DOM elements, it would be nice to be able to listen to events from those elements and handle them based on expressions defined on each layer. { \"ty\": 4, \"nm\": \"My layer\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {}, \"shapes\": [], \"events\": { \"click\": \"thisLayer.clicked = true;\" } } To do this we need a way of mapping the layer in the JSON to the DOM element and the value for the expression thisLayer . All this information is within the lottie-web SVG renderer but we need to find a way of accessing it. The first step is to allow a layer object to be passed to the events: // Handles an event from the container element container_event(ev) { this.prepare_lottie_event(ev); if ( this.handlers[ev.type] ) this.handle_lottie_event(ev, this.handlers[ev.type], null); } // Handles an event given a handler handle_lottie_event(ev, handler, layer) { handler(ev, this.thisComp, this.time, layer); } // Sets up an event handler expression_to_event_handler(expr) { return Function(\"event\", \"thisComp\", \"time\", \"thisLayer\", expr); } How The gist of it is we need to path the renderer object and inject our code in some of its methods. Luckily we can do this on the fly: load(lottie, resize = true) { // (omitted the part of the code that's the same as before) // Create lottie player this.anim = bodymovin.loadAnimation(options); this._patch_renderer(); } _patch_renderer() { // We patch initItems to trigger an event before any expression is evaluated: var old_init = this.anim.renderer.initItems.bind(this.anim.renderer); var post_init = this._lottie_load_event.bind(this) this.anim.renderer.initItems = function(){ old_init(); post_init(); }; // We patch createItem to add event listener. // It takes the JSON layer as input and returns the renderer later object this.layer_elements = []; var old_create = this.anim.renderer.createItem.bind(this.anim.renderer); this.anim.renderer.createItem = (function(layer){ var item = old_create(layer); this._create_item_event(layer, item); return item; }).bind(this); } _lottie_load_event() { let ev = new Event(\"load\", {}); this.container.dispatchEvent(ev); for ( let layer of this.layer_elements ) layer.dispatchEvent(ev); } _create_item_event(lottie, item) { // lottie is the JSON layer // item.layerElement is the DOM element for this layer // item.layerInterface is the expression thisLayer object if ( !lottie.events ) return; // Create a dummy element for Null layers and the like, // it makes it easier to listen for `load` events let element = item.layerElement ?? document.createElement(\"div\"); // Keep track of layer elements so they can have the `load` event too this.layer_elements.push(element); for ( let [name, func] of Object.entries(lottie.events) ) { let handler = this.expression_to_event_handler(func); function listener(ev) { this.prepare_lottie_event(ev); this.handle_lottie_event(ev, handler, item.layerInterface); } element.addEventListener(name, listener.bind(this)); } } Now that the renderer has been patched can we be assured the patching is done before the functions we are patching have been called? The short answer is No, but we can have a look at how we can achieve this. Abusing Font Loading When a lottie has external fonts, the lottie-web player waits for every font to be loaded before initializing the renderer. Which means when you have text layers, the code above works perfectly. This is nice but not all lotties need text so we'll need something better. Deferring Animation Load The trick is to not pass the lottie JSON to lottie-web until after we've patched the renderer. This is easy enough because if you call bodymovin.loadAnimation without path or animationData everything will be initialized (including the renderer) and only the JSON loading step is missing. We can use this to patch the renderer before loading the animation: load(lottie, resize = true) { // Options var options = { container: this.container, renderer: 'svg', loop: true, autoplay: true, ...this.custom_options, // Note that animationData is deferred }; if ( resize ) { this.container.style.width = lottie.w + \"px\"; this.container.style.height = lottie.h + \"px\"; } // Clean up this.clear(); // Setup handlers this.handlers = {}; if ( lottie.events ) { for ( var [name, func] of Object.entries(lottie.events) ) { this.handlers[name] = this.expression_to_event_handler(func); this.container.addEventListener(name, this._container_event_listener); } } // Create lottie player this.anim = bodymovin.loadAnimation(options); this._patch_renderer(); this.anim.addEventListener(\"DOMLoaded\", this._lottie_loaded_event.bind(this)); // Clone because the player modifies the passed object var animation_data = this.lottie_clone(lottie); // Load animation separately so we can patch the renderer this.anim.setupAnimation(animation_data); } Note that anim.setupAnimation is available from lottie-web version 5.8.0. If you have earlier versions, you should call anim.configAnimation instead. Triggering new events We know how to make the lottie react to DOM events, but what if we want to make the DOM react to events triggered from the lottie? We can use the patching setup just discussed to also add events on the other direction, the only thing we need is adding a method to thisComp , so it's invokable from the expressions and make it trigger DOM events. The trick is to patch thisComp in the right place, fortunately we've already done the bulk of the work so we just need to add some more code when the animation has been loaded: _lottie_load_event() { let ev = new Event(\"load\", {}); this.container.dispatchEvent(ev); for ( let layer of this.layer_elements ) layer.dispatchEvent(ev); // We add a method for triggering events from the lottie this.thisComp.trigger_event = (function(type, detail){ this.container.dispatchEvent(new CustomEvent(\"lottie.\" + type, {detail})); }).bind(this); } Then you can add event listeners to the element containing the lottie animation. Resulting Wrapper Here's the same wrapper class as described earlier, but with patching code applied to support the load event and layer events. class LottieInteractionPlayer { constructor(container, custom_options={}) { if ( typeof container == \"string\" ) this.container = document.getElementById(container); else this.container = container; this.anim = null; this.custom_options = custom_options; // needed by keyup/down if ( !container.hasAttribute(\"tabindex\") ) container.setAttribute(\"tabindex\", \"0\"); this.handlers = {}; this._container_event_listener = this.container_event.bind(this); } // Deep copy lottie JSON lottie_clone(json) { return JSON.parse(JSON.stringify(json)); } load(lottie, resize = true) { // Options var options = { container: this.container, renderer: 'svg', loop: true, autoplay: true, ...this.custom_options, // Note that animationData is deferred }; if ( resize ) { this.container.style.width = lottie.w + \"px\"; this.container.style.height = lottie.h + \"px\"; } // Clean up this.clear(); // Setup handlers this.handlers = {}; if ( lottie.events ) { for ( var [name, func] of Object.entries(lottie.events) ) { this.handlers[name] = this.expression_to_event_handler(func); this.container.addEventListener(name, this._container_event_listener); } } // Create lottie player this.anim = bodymovin.loadAnimation(options); this._patch_renderer(); // Clone because the player modifies the passed object var animation_data = this.lottie_clone(lottie); // Load animation separately so we can patch the renderer this.anim.setupAnimation(animation_data); } _patch_renderer() { // We patch initItems to trigger an event before any expression is evaluated: var old_init = this.anim.renderer.initItems.bind(this.anim.renderer); var post_init = this._lottie_load_event.bind(this) this.anim.renderer.initItems = function(){ old_init(); post_init(); }; // We patch createItem to add event listener. // It takes the JSON layer as input and returns the renderer later object this.layer_elements = []; var old_create = this.anim.renderer.createItem.bind(this.anim.renderer); this.anim.renderer.createItem = (function(layer){ var item = old_create(layer); this._create_item_event(layer, item); return item; }).bind(this); } _create_item_event(lottie, item) { // lottie is the JSON layer // item.layerElement is the DOM element for this layer // item.layerInterface is the expression thisLayer object if ( !lottie.events ) return; // Create a dummy element for Null layers and the like, // it makes it easier to listen for `load` events let element = item.layerElement ?? document.createElement(\"div\"); // Keep track of layer elements so they can have the `load` event too this.layer_elements.push(element); for ( let [name, func] of Object.entries(lottie.events) ) { let handler = this.expression_to_event_handler(func); function listener(ev) { this.prepare_lottie_event(ev); this.handle_lottie_event(ev, handler, item.layerInterface); } element.addEventListener(name, listener.bind(this)); } } _lottie_load_event() { let ev = new Event(\"load\", {}); this.container.dispatchEvent(ev); for ( let layer of this.layer_elements ) layer.dispatchEvent(ev); // We add a method for triggering events from the lottie this.thisComp.trigger_event = (function(type, detail){ this.container.dispatchEvent(new CustomEvent(\"lottie.\" + type, {detail})); }).bind(this); } // Destroy the animation clear() { if ( this.anim != null ) { try { this.anim.destroy(); this.anim = null; } catch ( e ) {} } for ( let name of Object.keys(this.handlers) ) this.container.removeEventListener(name, this._container_event_listener); } // Get the expression `thisComp` global get thisComp() { return this.anim.renderer.compInterface; } // Get the expression `time` global get time() { return this.anim.renderer.renderedFrame / this.anim.renderer.globalData.frameRate; } // Get an expression layer layer(name) { return this.thisComp(name); } // Handles an event from the container element container_event(ev) { this.prepare_lottie_event(ev); if ( this.handlers[ev.type] ) this.handle_lottie_event(ev, this.handlers[ev.type], null); } // Adds useful attributes to an event object prepare_lottie_event(ev) { if ( ev.clientX !== undefined ) { var rect = this.container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * this.thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * this.thisComp.height; } } // Handles an event given a handler handle_lottie_event(ev, handler, layer) { handler(ev, this.thisComp, this.time, layer); } // Sets up an event handler expression_to_event_handler(expr) { return Function(\"event\", \"thisComp\", \"time\", \"thisLayer\", expr); } } class LottieInteractionPlayer { constructor(container, custom_options={}) { if ( typeof container == \"string\" ) this.container = document.getElementById(container); else this.container = container; this.anim = null; this.custom_options = custom_options; // needed by keyup/down if ( !container.hasAttribute(\"tabindex\") ) container.setAttribute(\"tabindex\", \"0\"); this.handlers = {}; this._container_event_listener = this.container_event.bind(this); } // Deep copy lottie JSON lottie_clone(json) { return JSON.parse(JSON.stringify(json)); } load(lottie, resize = true) { // Options var options = { container: this.container, renderer: 'svg', loop: true, autoplay: true, ...this.custom_options, // Note that animationData is deferred }; if ( resize ) { this.container.style.width = lottie.w + \"px\"; this.container.style.height = lottie.h + \"px\"; } // Clean up this.clear(); // Setup handlers this.handlers = {}; if ( lottie.events ) { for ( var [name, func] of Object.entries(lottie.events) ) { this.handlers[name] = this.expression_to_event_handler(func); this.container.addEventListener(name, this._container_event_listener); } } // Create lottie player this.anim = bodymovin.loadAnimation(options); this._patch_renderer(); // Clone because the player modifies the passed object var animation_data = this.lottie_clone(lottie); // Load animation separately so we can patch the renderer this.anim.setupAnimation(animation_data); } _patch_renderer() { // We patch initItems to trigger an event before any expression is evaluated: var old_init = this.anim.renderer.initItems.bind(this.anim.renderer); var post_init = this._lottie_load_event.bind(this) this.anim.renderer.initItems = function(){ old_init(); post_init(); }; // We patch createItem to add event listener. // It takes the JSON layer as input and returns the renderer later object this.layer_elements = []; var old_create = this.anim.renderer.createItem.bind(this.anim.renderer); this.anim.renderer.createItem = (function(layer){ var item = old_create(layer); this._create_item_event(layer, item); return item; }).bind(this); } _create_item_event(lottie, item) { // lottie is the JSON layer // item.layerElement is the DOM element for this layer // item.layerInterface is the expression thisLayer object if ( !lottie.events ) return; // Create a dummy element for Null layers and the like, // it makes it easier to listen for `load` events let element = item.layerElement ?? document.createElement(\"div\"); // Keep track of layer elements so they can have the `load` event too this.layer_elements.push(element); for ( let [name, func] of Object.entries(lottie.events) ) { let handler = this.expression_to_event_handler(func); function listener(ev) { this.prepare_lottie_event(ev); this.handle_lottie_event(ev, handler, item.layerInterface); } element.addEventListener(name, listener.bind(this)); } } _lottie_load_event() { let ev = new Event(\"load\", {}); this.container.dispatchEvent(ev); for ( let layer of this.layer_elements ) layer.dispatchEvent(ev); // We add a method for triggering events from the lottie this.thisComp.trigger_event = (function(type, detail){ this.container.dispatchEvent(new CustomEvent(\"lottie.\" + type, {detail})); }).bind(this); } // Destroy the animation clear() { if ( this.anim != null ) { try { this.anim.destroy(); this.anim = null; } catch ( e ) {} } for ( let name of Object.keys(this.handlers) ) this.container.removeEventListener(name, this._container_event_listener); } // Get the expression `thisComp` global get thisComp() { return this.anim.renderer.compInterface; } // Get the expression `time` global get time() { return this.anim.renderer.renderedFrame / this.anim.renderer.globalData.frameRate; } // Get an expression layer layer(name) { return this.thisComp(name); } // Handles an event from the container element container_event(ev) { this.prepare_lottie_event(ev); if ( this.handlers[ev.type] ) this.handle_lottie_event(ev, this.handlers[ev.type], null); } // Adds useful attributes to an event object prepare_lottie_event(ev) { if ( ev.clientX !== undefined ) { var rect = this.container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * this.thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * this.thisComp.height; } } // Handles an event given a handler handle_lottie_event(ev, handler, layer) { handler(ev, this.thisComp, this.time, layer); } // Sets up an event handler expression_to_event_handler(expr) { return Function(\"event\", \"thisComp\", \"time\", \"thisLayer\", expr); } } Animation or Interaction It's possible to use the custom load to detect whether the lottie is being played in an environment that supports the custom events. The following example is similar to the click example from level 7 but when a player doesn't have interaction support, the star moves around on its own. Lottie HTML CSS Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"click\": \"var star = thisComp('star'); star.px = event.lottie_x; star.py = event.lottie_y;\", \"load\": \"thisComp('star').interactive = true;\" }, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; if ( !thisLayer.interactive ) { thisLayer.dx = 1; thisLayer.dy = 1; thisLayer.prev_time = 0; } } if ( !thisLayer.interactive ) { if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; thisLayer.px += thisLayer.dx * dt * 100; thisLayer.py += thisLayer.dy * dt * 120; var radius = thisLayer.content(1).outerRadius; if ( thisLayer.px < radius ) thisLayer.dx = 1; else if ( thisLayer.px > thisComp.width - radius ) thisLayer.dx = -1; if ( thisLayer.py < radius ) thisLayer.dy = 1; else if ( thisLayer.py > thisComp.height - radius ) thisLayer.dy = -1; } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], } } ] } ] } <div id=\"level9_parent\"> <div id=\"level9_not_interactive\"></div> <div id=\"level9_interactive\"></div> </div> #level9_parent { display: flex; } #level9_interactive, #level9_not_interactive { border: 1px solid #ccc; width: 50%; box-sizing: border-box; } var options = { container: document.getElementById(\"level9_not_interactive\"), renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); var player = new LottieInteractionPlayer(document.getElementById(\"level9_interactive\")); player.load(json, false); #level9_parent { display: flex; } #level9_interactive, #level9_not_interactive { border: 1px solid #ccc; width: 50%; box-sizing: border-box; } (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"click\": \"var star = thisComp('star'); star.px = event.lottie_x; star.py = event.lottie_y;\", \"load\": \"thisComp('star').interactive = true;\" }, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; if ( !thisLayer.interactive ) { thisLayer.dx = 1; thisLayer.dy = 1; thisLayer.prev_time = 0; } } if ( !thisLayer.interactive ) { if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; thisLayer.px += thisLayer.dx * dt * 100; thisLayer.py += thisLayer.dy * dt * 120; var radius = thisLayer.content(1).outerRadius; if ( thisLayer.px < radius ) thisLayer.dx = 1; else if ( thisLayer.px > thisComp.width - radius ) thisLayer.dx = -1; if ( thisLayer.py < radius ) thisLayer.dy = 1; else if ( thisLayer.py > thisComp.height - radius ) thisLayer.dy = -1; } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], } } ] } ] } ; var options = { container: document.getElementById(\"level9_not_interactive\"), renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); var player = new LottieInteractionPlayer(document.getElementById(\"level9_interactive\")); player.load(json, false); })(); Lottie Button Example This example uses everything we discussed so far. A quick note: to avoid clicks going to the wrong layer we need to define some CSS that gets rid of pointer events for layers we don't want to click. Lottie Script HTML CSS Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"fonts\": {\"list\":[ { \"ascent\": 72, \"fFamily\": \"Roboto\", \"fName\": \"Roboto Regular\", \"fStyle\": \"Regular\", \"fPath\": \"https://fonts.googleapis.com/css2?family=Roboto&display=swap\", \"origin\": 1, } ]}, \"layers\": [ { \"ty\": 5, \"ip\": 0, \"op\": 60, \"st\": 0, \"parent\": 1, \"cl\": \"no-mouse\", \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 25]}, }, \"t\": { \"a\": [], \"d\": { \"x\": \"var $bm_rt = 'Clicks: ' + thisComp('button').clicks;\", \"k\": [ { \"s\": { \"f\": \"Roboto Regular\", \"fc\": [0, 0, 0], \"s\": 70, \"t\": \"\", \"j\": 2, }, \"t\": 0 } ] }, \"m\": { \"a\": {\"a\": 0, \"k\": [0,0]}, \"g\": 3 }, \"p\": {} } }, { \"ty\": 4, \"nm\": \"button\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ind\": 1, \"cl\": \"lottie-button\", \"events\": { \"load\": \"thisLayer.clicks = 0;\", \"click\": \"thisLayer.clicks += 1; thisComp.trigger_event('click', {clicks: thisLayer.clicks});\", \"mouseenter\": \"thisLayer.highlighted = true;\", \"mouseleave\": \"thisLayer.highlighted = false;\" }, \"ks\": { \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": { \"a\": 0, \"k\": [100, 100], \"x\": \"var sz = thisLayer.highlighted ? 120 : 100; var $bm_rt = [sz, sz];\" } }, \"shapes\": [ { \"ty\": \"rc\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [350, 90]}, \"r\": {\"a\": 0, \"k\": 3}, }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 1, 0]}, \"w\": {\"a\": 0, \"k\": 1}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 50, \"x\": \"var $bm_rt = thisLayer.highlighted ? 70 : 30;\"}, \"c\": {\"a\": 0, \"k\": [0.4, 1, 0.4]} } ] } ] } var container = document.getElementById(\"level9_button\"); var player = new LottieInteractionPlayer(container); player.load(json); container.addEventListener(\"lottie.click\", ev => document.getElementById(\"level9_outer\").innerText = `Lottie clicked ${ev.detail.clicks} times` ); <div id=\"level9_button\"></div> <div id=\"level9_outer\">Button not clicked</div> .no-mouse { pointer-events: none; } .lottie-button { cursor: pointer; } Button not clicked .no-mouse { pointer-events: none; } .lottie-button { cursor: pointer; } (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"fonts\": {\"list\":[ { \"ascent\": 72, \"fFamily\": \"Roboto\", \"fName\": \"Roboto Regular\", \"fStyle\": \"Regular\", \"fPath\": \"https://fonts.googleapis.com/css2?family=Roboto&display=swap\", \"origin\": 1, } ]}, \"layers\": [ { \"ty\": 5, \"ip\": 0, \"op\": 60, \"st\": 0, \"parent\": 1, \"cl\": \"no-mouse\", \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 25]}, }, \"t\": { \"a\": [], \"d\": { \"x\": \"var $bm_rt = 'Clicks: ' + thisComp('button').clicks;\", \"k\": [ { \"s\": { \"f\": \"Roboto Regular\", \"fc\": [0, 0, 0], \"s\": 70, \"t\": \"\", \"j\": 2, }, \"t\": 0 } ] }, \"m\": { \"a\": {\"a\": 0, \"k\": [0,0]}, \"g\": 3 }, \"p\": {} } }, { \"ty\": 4, \"nm\": \"button\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ind\": 1, \"cl\": \"lottie-button\", \"events\": { \"load\": \"thisLayer.clicks = 0;\", \"click\": \"thisLayer.clicks += 1; thisComp.trigger_event('click', {clicks: thisLayer.clicks});\", \"mouseenter\": \"thisLayer.highlighted = true;\", \"mouseleave\": \"thisLayer.highlighted = false;\" }, \"ks\": { \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": { \"a\": 0, \"k\": [100, 100], \"x\": \"var sz = thisLayer.highlighted ? 120 : 100; var $bm_rt = [sz, sz];\" } }, \"shapes\": [ { \"ty\": \"rc\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [350, 90]}, \"r\": {\"a\": 0, \"k\": 3}, }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 1, 0]}, \"w\": {\"a\": 0, \"k\": 1}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 50, \"x\": \"var $bm_rt = thisLayer.highlighted ? 70 : 30;\"}, \"c\": {\"a\": 0, \"k\": [0.4, 1, 0.4]} } ] } ] } ; var container = document.getElementById(\"level9_button\"); var player = new LottieInteractionPlayer(container); player.load(json); container.addEventListener(\"lottie.click\", ev => document.getElementById(\"level9_outer\").innerText = `Lottie clicked ${ev.detail.clicks} times` ); })(); 3D Everything discussed so far was for the lottie-web svg renderer but all the patching works with the html renderer as well. The html renderer supports 3D layers so we can make an interactive 3D scene with little effort. The main caveat is that you need to set position: relative on the container element. On the example below you can click to capture the mouse then have first-person controls. Lottie Script HTML CSS Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 180, \"fr\": 60, \"w\": 512, \"h\": 512, \"fonts\": { \"list\": [] }, \"assets\": [], \"layers\": [ { \"nm\": \"Camera\", \"ty\": 13, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 0, 0, -10 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"pe\": { \"a\": 0, \"k\": 256 }, \"ddd\": 1 }, { \"nm\": \"Move Parent\", \"ty\": 3, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"a\": { \"a\": 0, \"k\": [ 0, 0, 0 ], \"x\": \"var dt = thisComp.time_delta(thisLayer, time);\\n\\n if ( thisComp.mouse_dx )\\n {\\n thisComp.char_angle -= dt * thisComp.mouse_dx / 8 * Math.PI;\\n thisComp.mouse_dx = 0;\\n }\\n\\n if ( thisComp.mouse_dy )\\n {\\n thisComp.look_angle += dt * thisComp.mouse_dy / 8 * Math.PI;\\n thisComp.mouse_dy = 0;\\n }\\n\\n\\n var left = thisComp.keys_pressed.ArrowLeft || thisComp.keys_pressed.a;\\n var right = thisComp.keys_pressed.ArrowRight || thisComp.keys_pressed.d;\\n var dx = 0;\\n if ( left && right )\\n dx = 0;\\n else if ( left )\\n dx = -1;\\n else if ( right )\\n dx = 1;\\n\\n var up = thisComp.keys_pressed.ArrowUp || thisComp.keys_pressed.w;\\n var down = thisComp.keys_pressed.ArrowDown || thisComp.keys_pressed.s;\\n var dz = 0;\\n if ( up && down )\\n dz = 0;\\n else if ( up )\\n dz = 1;\\n else if ( down )\\n dz = -1;\\n\\n thisLayer.char_x += dz * dt * -200 * Math.sin(thisComp.char_angle);\\n thisLayer.char_z += dz * dt * 200 * Math.cos(thisComp.char_angle);\\n\\n thisLayer.char_x += dx * dt * -200 * Math.sin(thisComp.char_angle - Math.PI / 2);\\n thisLayer.char_z += dx * dt * 200 * Math.cos(thisComp.char_angle - Math.PI / 2);\\n\\n var $bm_rt = [thisLayer.char_x, thisLayer.char_y, thisLayer.char_z];\\n \\n/**/\" }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ], \"x\": \"var $bm_rt = [thisComp.look_angle * 180 / Math.PI, thisComp.char_angle * 180 / Math.PI, 0];\\n \\n/**/\" } }, \"ind\": 1, \"ddd\": 1, \"events\": { \"load\": \"thisLayer.char_x = 0;\\n thisLayer.char_z = 0;\\n thisLayer.char_y = 0;\\n \\n/**/\" } }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 0, 0, 200 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 0.5, 0.5, 1 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 0, 0, -200 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 0.5, 0.5, 0 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 200, 0, 0 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 90 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 1, 0.5, 0.5 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ -200, 0, 0 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 90 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 0, 0.5, 0.5 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] } ], \"events\": { \"keydown\": \"thisComp.keys_pressed[event.key] = true;\\n\\n if ( event.key != \\\"F5\\\" )\\n event.preventDefault();\\n \\n/**/\", \"keyup\": \"thisComp.keys_pressed[event.key] = false;\\n\\n if ( event.key != \\\"F5\\\" )\\n event.preventDefault();\\n \\n/**/\", \"load\": \"thisComp.keys_pressed = {};\\n thisComp.mouse_dx = 0;\\n thisComp.mouse_dy = 0;\\n thisComp.char_angle = 0;\\n thisComp.look_angle = 0;\\n thisComp.time_delta = function (thisLayer, time) {\\n if ( thisLayer.last_time === undefined || time < thisLayer.last_time )\\n {\\n thisLayer.last_time = time;\\n return 0;\\n }\\n\\n var dt = time - thisLayer.last_time;\\n thisLayer.last_time = time;\\n return dt;\\n };\\n \\n/**/\", \"mouseenter\": \"thisComp.mouse_old_x = thisComp.mouse_x = event.lottie_x;\\n thisComp.mouse_old_y = thisComp.mouse_y = event.lottie_x;\\n \\n/**/\", \"mouseleave\": \"thisComp.mouse_old_x = thisComp.mouse_x = event.lottie_x;\\n thisComp.mouse_old_y = thisComp.mouse_y = event.lottie_x;\\n \\n/**/\", \"mousemove\": \"thisComp.mouse_dx += event.movementX;\\n thisComp.mouse_dy += event.movementY;\\n \\n/**/\" }, \"ddd\": 1 } var container = document.getElementById(\"level9_3d\"); var player = new LottieInteractionPlayer(container, {renderer: \"html\"}); player.load(json); <div id=\"level9_3d\" onclick=\"this.requestPointerLock();\"></div> #level9_3d { position: relative; } #level9_3d { position: relative; } (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 180, \"fr\": 60, \"w\": 512, \"h\": 512, \"fonts\": { \"list\": [] }, \"assets\": [], \"layers\": [ { \"nm\": \"Camera\", \"ty\": 13, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 0, 0, -10 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"pe\": { \"a\": 0, \"k\": 256 }, \"ddd\": 1 }, { \"nm\": \"Move Parent\", \"ty\": 3, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"a\": { \"a\": 0, \"k\": [ 0, 0, 0 ], \"x\": \"var dt = thisComp.time_delta(thisLayer, time);\\n\\n if ( thisComp.mouse_dx )\\n {\\n thisComp.char_angle -= dt * thisComp.mouse_dx / 8 * Math.PI;\\n thisComp.mouse_dx = 0;\\n }\\n\\n if ( thisComp.mouse_dy )\\n {\\n thisComp.look_angle += dt * thisComp.mouse_dy / 8 * Math.PI;\\n thisComp.mouse_dy = 0;\\n }\\n\\n\\n var left = thisComp.keys_pressed.ArrowLeft || thisComp.keys_pressed.a;\\n var right = thisComp.keys_pressed.ArrowRight || thisComp.keys_pressed.d;\\n var dx = 0;\\n if ( left && right )\\n dx = 0;\\n else if ( left )\\n dx = -1;\\n else if ( right )\\n dx = 1;\\n\\n var up = thisComp.keys_pressed.ArrowUp || thisComp.keys_pressed.w;\\n var down = thisComp.keys_pressed.ArrowDown || thisComp.keys_pressed.s;\\n var dz = 0;\\n if ( up && down )\\n dz = 0;\\n else if ( up )\\n dz = 1;\\n else if ( down )\\n dz = -1;\\n\\n thisLayer.char_x += dz * dt * -200 * Math.sin(thisComp.char_angle);\\n thisLayer.char_z += dz * dt * 200 * Math.cos(thisComp.char_angle);\\n\\n thisLayer.char_x += dx * dt * -200 * Math.sin(thisComp.char_angle - Math.PI / 2);\\n thisLayer.char_z += dx * dt * 200 * Math.cos(thisComp.char_angle - Math.PI / 2);\\n\\n var $bm_rt = [thisLayer.char_x, thisLayer.char_y, thisLayer.char_z];\\n \\n/**/\" }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ], \"x\": \"var $bm_rt = [thisComp.look_angle * 180 / Math.PI, thisComp.char_angle * 180 / Math.PI, 0];\\n \\n/**/\" } }, \"ind\": 1, \"ddd\": 1, \"events\": { \"load\": \"thisLayer.char_x = 0;\\n thisLayer.char_z = 0;\\n thisLayer.char_y = 0;\\n \\n/**/\" } }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 0, 0, 200 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 0.5, 0.5, 1 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 0, 0, -200 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 0.5, 0.5, 0 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 200, 0, 0 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 90 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 1, 0.5, 0.5 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ -200, 0, 0 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 90 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 0, 0.5, 0.5 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] } ], \"events\": { \"keydown\": \"thisComp.keys_pressed[event.key] = true;\\n\\n if ( event.key != \\\"F5\\\" )\\n event.preventDefault();\\n \\n/**/\", \"keyup\": \"thisComp.keys_pressed[event.key] = false;\\n\\n if ( event.key != \\\"F5\\\" )\\n event.preventDefault();\\n \\n/**/\", \"load\": \"thisComp.keys_pressed = {};\\n thisComp.mouse_dx = 0;\\n thisComp.mouse_dy = 0;\\n thisComp.char_angle = 0;\\n thisComp.look_angle = 0;\\n thisComp.time_delta = function (thisLayer, time) {\\n if ( thisLayer.last_time === undefined || time < thisLayer.last_time )\\n {\\n thisLayer.last_time = time;\\n return 0;\\n }\\n\\n var dt = time - thisLayer.last_time;\\n thisLayer.last_time = time;\\n return dt;\\n };\\n \\n/**/\", \"mouseenter\": \"thisComp.mouse_old_x = thisComp.mouse_x = event.lottie_x;\\n thisComp.mouse_old_y = thisComp.mouse_y = event.lottie_x;\\n \\n/**/\", \"mouseleave\": \"thisComp.mouse_old_x = thisComp.mouse_x = event.lottie_x;\\n thisComp.mouse_old_y = thisComp.mouse_y = event.lottie_x;\\n \\n/**/\", \"mousemove\": \"thisComp.mouse_dx += event.movementX;\\n thisComp.mouse_dy += event.movementY;\\n \\n/**/\" }, \"ddd\": 1 } ; var container = document.getElementById(\"level9_3d\"); var player = new LottieInteractionPlayer(container, {renderer: \"html\"}); player.load(json); })(); document.querySelectorAll(\".nav-tabs a\").forEach( link => link.addEventListener(\"click\", e => jQuery(e.target).tab(\"show\")) );","title":"Advanced Interactions"},{"location":"advanced_interactions/#advanced-interactions","text":"This page will describe how to create lotties with advanced interactivity, specifically when used with lottie-web player. This page is divided into \"levels\", each level adds more obscure features which are less portable but add increased interaction capabilities. There are 9 levels below Regular Lottie , which is the same as the number of circles of hell in Dante's Inferno. Reader discretion is advised. The techniques described below require knowledge on the following topics: The Lottie format Lottie expressions The lottie-web player ECMAScript / JavaScript DOM and events .playground_html > div > svg { border: 1px solid #ccc; } pre { margin-top: 0; } #content-container .nav.nav-tabs { height: 45px; }","title":"Advanced Interactions"},{"location":"advanced_interactions/#level-0-regular-lotties","text":"Lotties can play an animation, loading an animation looks something like this: Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 1, \"k\": [ {\"t\": 0, \"s\": [0], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 360, \"s\": [360]} ]}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } <div id=\"level0\"></div> var container = document.getElementById(\"level0\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 1, \"k\": [ {\"t\": 0, \"s\": [0], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 360, \"s\": [360]} ]}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } ; var container = document.getElementById(\"level0\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); })(); By themselves lotties just play an animation, but luckily lottie-web provides some utility functions, note how in the Script above we are storing the variable anim returned by bodymovin.loadAnimation .","title":"Level 0: Regular Lotties"},{"location":"advanced_interactions/#level-1-controlling-playback","text":"You can play around with the anim object like setting the current frame, pausing stopping etc. There's also the LottieFiles interactivity library that makes some of these interactions easier to create. Here's an example of a lottie changing based on mouse position: Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 1, \"k\": [ {\"t\": 0, \"s\": [0], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 360, \"s\": [360]} ]}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } <div id=\"level1\"></div> var container = document.getElementById(\"level1\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: false, animationData: json, }; var anim = bodymovin.loadAnimation(options); container.addEventListener(\"mousemove\", ev => { var rect = container.getBoundingClientRect(); var t = (ev.clientX - rect.left) / rect.width; anim.goToAndStop(t * json.op, true); }); (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 1, \"k\": [ {\"t\": 0, \"s\": [0], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 360, \"s\": [360]} ]}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } ; var container = document.getElementById(\"level1\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: false, animationData: json, }; var anim = bodymovin.loadAnimation(options); container.addEventListener(\"mousemove\", ev => { var rect = container.getBoundingClientRect(); var t = (ev.clientX - rect.left) / rect.width; anim.goToAndStop(t * json.op, true); }); })();","title":"Level 1: Controlling Playback"},{"location":"advanced_interactions/#level-2-svg-styling","text":"When using the SVG renderer, you can make use of CSS styling by specifying a value for cl in the lottie layers. In the example below, CSS rules highlight the lottie layer showing a rectangle when the mouse is over it. Lottie CSS HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [400, 300]}, \"s\": {\"a\": 0, \"k\": [150, 150]}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.769, 0.851, 0.961]} } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"cl\": \"lottie_level_2\", \"shapes\": [ { \"ty\": \"rc\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [256, 128]}, \"r\": {\"a\": 0, \"k\": 3}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]} } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [100, 200]}, \"s\": {\"a\": 0, \"k\": [150, 150]}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.769, 0.851, 0.961]} } ] } ] } .lottie_level_2:hover { opacity: 10%; } .lottie_level_2 { cursor: pointer; } <div id=\"level2\"></div> var container = document.getElementById(\"level2\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: false, animationData: json, }; var anim = bodymovin.loadAnimation(options); .lottie_level_2:hover { opacity: 10%; } .lottie_level_2 { cursor: pointer; } (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [400, 300]}, \"s\": {\"a\": 0, \"k\": [150, 150]}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.769, 0.851, 0.961]} } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"cl\": \"lottie_level_2\", \"shapes\": [ { \"ty\": \"rc\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [256, 128]}, \"r\": {\"a\": 0, \"k\": 3}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]} } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [100, 200]}, \"s\": {\"a\": 0, \"k\": [150, 150]}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.769, 0.851, 0.961]} } ] } ] } ; var container = document.getElementById(\"level2\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: false, animationData: json, }; var anim = bodymovin.loadAnimation(options); })();","title":"Level 2: SVG Styling"},{"location":"advanced_interactions/#level-3-basic-expressions","text":"Lotties can have expressions , they are basically small snippets of JavaScript code used to modify the value of animated properties. Below the star rotation is animated using an expression instead of using keyframes. Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0, \"x\": \"var $bm_rt = time * 60;\"}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } <div id=\"level3\"></div> var container = document.getElementById(\"level3\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0, \"x\": \"var $bm_rt = time * 60;\"}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } ; var container = document.getElementById(\"level3\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); })();","title":"Level 3: Basic Expressions"},{"location":"advanced_interactions/#level-4-advanced-expressions","text":"Within expressions you can access properties from other layers, and since they are all JavaScript objects, you can add your own properties to them. You can make a layer follow the position of another: // Set the layer position to follow the X position of another layer var other_position = thisComp(\"layer_name\").transform.position; var $bm_rt = [other_position[0], value[1]]; Since property values are initialized to their non-expression value, you can't access updated value of the property you are changing from the expression. However you can work around this by storing state in the layer object. // Get size of the rect var size = thisLayer.content(1).size; // Initialize everything at the start if ( time == 0 ) { thisLayer.my_value = size[0] / 2; thisLayer.speed = 60; thisLayer.direction = 1; thisLayer.prev_time = 0; } // Handle the case when the lottie has looped and time has reset // as it might not be exactly 0 if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; // Find the time delta to keep constant speed var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Increment x thisLayer.my_value += dt * thisLayer.speed * thisLayer.direction; var x = thisLayer.my_value; if ( x >= thisComp.width - size[0] / 2) thisLayer.direction = -1; else if ( x <= size[0] / 2 ) thisLayer.direction = 1; // Calculate y based on x var y = value[1] + Math.sin((x / thisComp.width) * Math.PI * 2) * (thisComp.height - size[1]) / 2; var $bm_rt = [x, y]; Here's an example: Note that the JSON uses ECMAScript's backtick string syntax for clarity, in a real Lottie file you'd need to put it into a single line. Newlines in the expression string work fine as long as the last line of the expression doesn't end in a single line comment. Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 60, \"st\": 0, \"nm\": \"layer_name\", \"ks\": { \"p\": { \"a\": 0, \"k\": [0, 256], \"x\": ` // Get size of the rect var size = thisLayer.content(1).size; // Initialize everything at the start if ( time == 0 ) { thisLayer.my_value = size[0] / 2; thisLayer.speed = 120; thisLayer.direction = 1; thisLayer.prev_time = 0; } // Handle the case when the lottie has looped and time has reset // as it might not be exactly 0 if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; // Find the time delta to keep constant speed var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Increment x thisLayer.my_value += dt * thisLayer.speed * thisLayer.direction; var x = thisLayer.my_value; if ( x >= thisComp.width - size[0] / 2) thisLayer.direction = -1; else if ( x <= size[0] / 2 ) thisLayer.direction = 1; // Calculate y based on x var y = value[1] + Math.sin((x / thisComp.width) * Math.PI * 2) * (thisComp.height - size[1]) / 2; var $bm_rt = [x, y]; ` } }, \"shapes\": [ { \"ty\": \"rc\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [80, 80]}, \"r\": {\"a\": 0, \"k\": 3}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]} } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 3600, \"st\": 0, \"ks\": { \"p\": { \"a\": 0, \"k\": [0, 256], \"x\": ` // Set the layer position to follow the X position of another layer var other_position = thisComp(\"layer_name\").transform.position; var $bm_rt = [other_position[0], value[1]]; ` } }, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [150, 150]}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.769, 0.851, 0.961]} } ] } ] } <div id=\"level4\"></div> var container = document.getElementById(\"level4\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 60, \"st\": 0, \"nm\": \"layer_name\", \"ks\": { \"p\": { \"a\": 0, \"k\": [0, 256], \"x\": ` // Get size of the rect var size = thisLayer.content(1).size; // Initialize everything at the start if ( time == 0 ) { thisLayer.my_value = size[0] / 2; thisLayer.speed = 120; thisLayer.direction = 1; thisLayer.prev_time = 0; } // Handle the case when the lottie has looped and time has reset // as it might not be exactly 0 if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; // Find the time delta to keep constant speed var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Increment x thisLayer.my_value += dt * thisLayer.speed * thisLayer.direction; var x = thisLayer.my_value; if ( x >= thisComp.width - size[0] / 2) thisLayer.direction = -1; else if ( x <= size[0] / 2 ) thisLayer.direction = 1; // Calculate y based on x var y = value[1] + Math.sin((x / thisComp.width) * Math.PI * 2) * (thisComp.height - size[1]) / 2; var $bm_rt = [x, y]; ` } }, \"shapes\": [ { \"ty\": \"rc\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [80, 80]}, \"r\": {\"a\": 0, \"k\": 3}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]} } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 3600, \"st\": 0, \"ks\": { \"p\": { \"a\": 0, \"k\": [0, 256], \"x\": ` // Set the layer position to follow the X position of another layer var other_position = thisComp(\"layer_name\").transform.position; var $bm_rt = [other_position[0], value[1]]; ` } }, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [150, 150]}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.769, 0.851, 0.961]} } ] } ] } ; var container = document.getElementById(\"level4\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); })();","title":"Level 4: Advanced Expressions"},{"location":"advanced_interactions/#level-5-breaking-time","text":"In the previous examples, we had a condition at the start of some expressions initializing custom attributes when time is equal to 0. if ( time == 0 ) thisLayer.my_property = \"some value\"; This works because the first frame is always at time 0 but it isn't a super reliable check: when the player loops, the time can go back to 0 which would result in your properties being initialized again. If you want your interactions to carry over across loops, a better approach is to use a condition where you check for undefined layer properties: if ( thisLayer.my_property === undefined ) thisLayer.my_property = \"some value\"; For smooth value increments, we need to properly handle the time variable within expressions. Similarly to what we've done before the following example shows how to initialize and update a variable over time; // Initialization if ( thisLayer.last_time === undefined ) { thisLayer.last_time = time; thisLayer.value = 0; thisLayer.speed = 600; } // Handle looping if ( time < thisLayer.last_time ) thisLayer.last_time = time; // `dt` is the time since the last expression evaluation in seconds var dt = time - thisLayer.last_time; // Update the time management variable thisLayer.last_time = time; // Increment thisLayer.value = dt * thisLayer.speed; This approach allows you to change values regardless of playback speed and framerate. I also allows you to continue the movement when the lottie reaches its last frame and starts looping. In the following example, the lottie is set to loop every second but it keeps going indefinitely because of the time management setup: Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.prev_time === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; thisLayer.dx = 1; thisLayer.dy = 1; thisLayer.prev_time = 0; } // Time management if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Animation thisLayer.px += thisLayer.dx * dt * 100; thisLayer.py += thisLayer.dy * dt * 120; var radius = thisLayer.content(1).outerRadius; if ( thisLayer.px < radius ) thisLayer.dx = 1; else if ( thisLayer.px > thisComp.width - radius ) thisLayer.dx = -1; if ( thisLayer.py < radius ) thisLayer.dy = 1; else if ( thisLayer.py > thisComp.height - radius ) thisLayer.dy = -1; // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], } } ] } ] } <div id=\"level5\"></div> var options = { container: document.getElementById(\"level5\"), renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.prev_time === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; thisLayer.dx = 1; thisLayer.dy = 1; thisLayer.prev_time = 0; } // Time management if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Animation thisLayer.px += thisLayer.dx * dt * 100; thisLayer.py += thisLayer.dy * dt * 120; var radius = thisLayer.content(1).outerRadius; if ( thisLayer.px < radius ) thisLayer.dx = 1; else if ( thisLayer.px > thisComp.width - radius ) thisLayer.dx = -1; if ( thisLayer.py < radius ) thisLayer.dy = 1; else if ( thisLayer.py > thisComp.height - radius ) thisLayer.dy = -1; // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], } } ] } ] } ; var options = { container: document.getElementById(\"level5\"), renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); })();","title":"Level 5: Breaking Time"},{"location":"advanced_interactions/#level-6-injecting-data","text":"Remember the anim object we get from lottie-web? It's the key for more advanced interactions. Internally it stores its lottie structure and the objects being passed to expression as thisComp and thisLayer . Being able to access these objects allows us to pass data directly to the lottie expressions. The object corresponding to thisComp can be accessed as anim.renderer.compInterface , and from there you can get the layers by name or index (see the Composition expression object). In the example below the rotation direction and color of the star change based on whether the mouse is over the element containing the lottie. // Time management as before if ( time == 0 ) { thisLayer.angle = 0; thisLayer.prev_time = 0; } if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; var direction = thisComp.counter_clockwise ? -1 : 1; thisLayer.angle += dt * direction * 60; var $bm_rt = thisLayer.angle; Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0, \"x\": ` // Time management as before if ( thisLayer.prev_time === undefined ) { thisLayer.angle = 0; thisLayer.prev_time = 0; } if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; var direction = thisComp.mouse_is_over ? -1 : 1; thisLayer.angle += dt * direction * 60; var $bm_rt = thisLayer.angle; `}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], \"x\": \"var $bm_rt = thisComp.mouse_is_over ? [0.196, 0.314, 0.69] : value;\" }, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } <div id=\"level6\"></div> var container = document.getElementById(\"level6\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); container.addEventListener(\"mouseenter\", () => { anim.renderer.compInterface.mouse_is_over = true; }); container.addEventListener(\"mouseleave\", () => { anim.renderer.compInterface.mouse_is_over = false; }); (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 360, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ { \"ty\": 4, \"ip\": 0, \"op\": 360, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0, \"x\": ` // Time management as before if ( thisLayer.prev_time === undefined ) { thisLayer.angle = 0; thisLayer.prev_time = 0; } if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; var direction = thisComp.mouse_is_over ? -1 : 1; thisLayer.angle += dt * direction * 60; var $bm_rt = thisLayer.angle; `}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], \"x\": \"var $bm_rt = thisComp.mouse_is_over ? [0.196, 0.314, 0.69] : value;\" }, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30} } ] } ] } ; var container = document.getElementById(\"level6\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); container.addEventListener(\"mouseenter\", () => { anim.renderer.compInterface.mouse_is_over = true; }); container.addEventListener(\"mouseleave\", () => { anim.renderer.compInterface.mouse_is_over = false; }); })();","title":"Level 6: Injecting Data"},{"location":"advanced_interactions/#level-7-automatic-event-handlers","text":"So far the interaction logic has been done by JavaScript on the browser. In this section we'll add all the logic in the JSON itself and write a wrapper script that sets up the animation. This allows you to have self-contained lotties you can embed in a web page that will handle events on their own.","title":"Level 7: Automatic Event Handlers"},{"location":"advanced_interactions/#lottie-json-extension","text":"First thing is to write the expressions in the Lottie itself. Since Lottie is just a JSON file, it's easy to add custom values: { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"click\": \"/*event handler code*/\" } } Now we need to add some JavaScript so we can listen to the events fired by the DOM and execute expressions: for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", expression); container.addEventListener(ev_type, expression_function); }","title":"Lottie JSON Extension"},{"location":"advanced_interactions/#preparing-globals","text":"While the above would work, we should expose some objects for it to be useful. The lottie player define a bunch of objects and functions for expressions, but we don't really need all of them since the even handlers only need to pass along the information that an event has occurred. We will define thisComp and time to be the same as the globals of the same name you'd expect to find an expressions, and pass them to the event handling function: function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } After this step, you're all set to hanle DOM events automatically from a lottie. The next couple steps add some polish to the event interface for a smoother experience.","title":"Preparing Globals"},{"location":"advanced_interactions/#mouse-events","text":"Events like click , mousemove , etc. provide the mouse coordinates, which you might want to access from within the lottie. By default these coordinates aren't in the same space as the values inside the lottie so we need to scale them appropriately: function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } Now we can reference the position in the lottie expression: { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"click\": ` var star = thisComp(\"star\"); star.px = event.lottie_x; star.py = event.lottie_y; ` } } In the example below you can click to move the star to a given position: Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"click\": ` var star = thisComp(\"star\"); star.px = event.lottie_x; star.py = event.lottie_y; ` }, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], } } ] } ] } <div id=\"level7_mouse\"></div> var container = document.getElementById(\"level7_mouse\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"click\": ` var star = thisComp(\"star\"); star.px = event.lottie_x; star.py = event.lottie_y; ` }, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], } } ] } ] } ; var container = document.getElementById(\"level7_mouse\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } })();","title":"Mouse Events"},{"location":"advanced_interactions/#keyboard-events","text":"To allow keyboard events to be fired correctly, you need to ensure the element containing the lottie is focusable. You can do this by setting the tabindex attribute in HTML or with JavaScript. <div id=\"level7_keyboard\" tabindex=\"0\"></div> or container.setAttribute(\"tabindex\", \"0\"); In the example below we'll move a layer based on whether the user is pressing the left and right arrow keys. A good solution for this is to keep track of which key has been pressed and react accordingly. The event handler code is simple enough: For keydown : if ( event.key == \"ArrowLeft\" ) thisComp(\"star\").left = true; else if ( event.key == \"ArrowRight\" ) thisComp(\"star\").right = true; // Prevent scrolling and other browser shortcuts event.preventDefault(); keyup : if ( event.key == \"ArrowLeft\" ) thisComp(\"star\").left = false; else if ( event.key == \"ArrowRight\" ) thisComp(\"star\").right = false; // Prevent scrolling and other browser shortcuts event.preventDefault(); We should also reset these when the lottie element loses focus: focusout : thisComp(\"star\").left = false; thisComp(\"star\").right = false; We need to add some logic to the layer position property: // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; thisLayer.left = false; thisLayer.right = false; thisLayer.prev_time = 0; } // Handle time wrapping around if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; // Time delta var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Figure which direction to move var direction = 0; if ( thisLayer.left && thisLayer.right ) direction = 0; else if ( thisLayer.left ) direction = -1; else if ( thisLayer.right ) direction = 1; // Move if ( direction != 0 ) { // 600 is the \"speed\", you need to consider that dt is the time // in seconds since the previous frame so it's usally a rather small value thisLayer.px += direction * dt * 600; var radius = thisLayer.content(1).outerRadius; thisLayer.px = clamp(thisLayer.px, radius, thisComp.width - radius); } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; The example below shows how to handle keyboard event. Focusing on the element changes the star color. When focused (blue star) left and right arrow keys move the star in the corresponding direction. Lottie HTML Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"keydown\": ` if ( event.key == \"ArrowLeft\" ) thisComp(\"star\").left = true; else if ( event.key == \"ArrowRight\" ) thisComp(\"star\").right = true; // Prevent scrolling and other browser shortcuts event.preventDefault(); `, \"keyup\": ` if ( event.key == \"ArrowLeft\" ) thisComp(\"star\").left = false; else if ( event.key == \"ArrowRight\" ) thisComp(\"star\").right = false; // Prevent scrolling and other browser shortcuts event.preventDefault(); `, \"focusin\": \"thisComp.focus = true;\", \"focusout\": ` thisComp(\"star\").left = false; thisComp(\"star\").right = false; thisComp.focus = false; `, }, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; thisLayer.left = false; thisLayer.right = false; thisLayer.prev_time = 0; } // Handle time wrapping around if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; // Time delta var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Figure which direction to move var direction = 0; if ( thisLayer.left && thisLayer.right ) direction = 0; else if ( thisLayer.left ) direction = -1; else if ( thisLayer.right ) direction = 1; // Move if ( direction != 0 ) { // 600 is the \"speed\", you need to consider that dt is the time // in seconds since the previous frame so it's usally a rather small value thisLayer.px += direction * dt * 600; var radius = thisLayer.content(1).outerRadius; thisLayer.px = clamp(thisLayer.px, radius, thisComp.width - radius); } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], \"x\": \"var $bm_rt = thisComp.focus ? [0.196, 0.314, 0.69] : value;\" } } ] } ] } <div id=\"level7_keyboard\" tabindex=\"0\"></div> var container = document.getElementById(\"level7_keyboard\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"keydown\": ` if ( event.key == \"ArrowLeft\" ) thisComp(\"star\").left = true; else if ( event.key == \"ArrowRight\" ) thisComp(\"star\").right = true; // Prevent scrolling and other browser shortcuts event.preventDefault(); `, \"keyup\": ` if ( event.key == \"ArrowLeft\" ) thisComp(\"star\").left = false; else if ( event.key == \"ArrowRight\" ) thisComp(\"star\").right = false; // Prevent scrolling and other browser shortcuts event.preventDefault(); `, \"focusin\": \"thisComp.focus = true;\", \"focusout\": ` thisComp(\"star\").left = false; thisComp(\"star\").right = false; thisComp.focus = false; `, }, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; thisLayer.left = false; thisLayer.right = false; thisLayer.prev_time = 0; } // Handle time wrapping around if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; // Time delta var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; // Figure which direction to move var direction = 0; if ( thisLayer.left && thisLayer.right ) direction = 0; else if ( thisLayer.left ) direction = -1; else if ( thisLayer.right ) direction = 1; // Move if ( direction != 0 ) { // 600 is the \"speed\", you need to consider that dt is the time // in seconds since the previous frame so it's usally a rather small value thisLayer.px += direction * dt * 600; var radius = thisLayer.content(1).outerRadius; thisLayer.px = clamp(thisLayer.px, radius, thisComp.width - radius); } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], \"x\": \"var $bm_rt = thisComp.focus ? [0.196, 0.314, 0.69] : value;\" } } ] } ] } ; var container = document.getElementById(\"level7_keyboard\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } })();","title":"Keyboard Events"},{"location":"advanced_interactions/#level-8-sound-effects","text":"Lottie web supports playing audio layers with the help of Howler . By default the level of control you get with sound is rather limited but we can find a way around it. The issue is audio layers don't have a scriptable property that controls playback which means we can't attach an expression to audio layers. The trick is to wrap an audio layer into a precomp and to use an expression on its time remapping property. We can then control playback as follows: if ( thisLayer.last_time === undefined ) { thisLayer.last_time = time; // This variable wil control whether the sound is played thisLayer.sound_play = 0; // This should be the time in seconds you want the sound to play for // To get the best results, it should be just short of the duration // of the audio file thisLayer.sound_duration = 1; } // Usual time management stuff if ( time < thisLayer.last_time ) thisLayer.last_time = time; var dt = time - thisLayer.last_time; thisLayer.last_time = time; // Default to not playing var $bm_rt = 0; if ( thisLayer.sound_play > 0 ) { $bm_rt = thisLayer.sound_duration - thisLayer.sound_play; thisLayer.sound_play -= dt; } In the example that follows you can click on the lottie to make it play a sound. The precomp also has a green cicle that shows playback progress. Lottie HTML Script Result { \"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 180, \"w\": 512, \"h\": 512, \"ddd\": 0, \"events\": { \"click\": \"thisComp('sound_control').sound_play = thisComp('sound_control').sound_duration\" }, \"assets\": [ { \"id\": \"sound\", \"u\": \"/lottie-docs/examples/\", \"p\": \"sound.mp3\", \"e\": 0 }, { \"id\": \"precomp\", \"layers\": [ { \"nm\": \"a\", \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 1, \"k\": [ { \"t\": 0, \"s\": [0, 256], \"i\": {\"x\": 0, \"y\": 0}, \"o\": {\"x\": 1, \"y\": 1}, }, { \"t\": 60, \"s\": [512, 256], } ]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, }, { \"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 1, 0]}, \"o\": {\"a\": 0, \"k\": 100}, } ] }, { \"ty\": 6, \"ip\": 1, \"op\": 60, \"st\": 1, \"refId\": \"sound\", \"au\": { \"lv\": {\"a\": 0, \"k\": [100, 100]} } } ] } ], \"markers\": [], \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 180, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": { \"a\": 1, \"k\": [ { \"t\": 0, \"s\": [0], \"i\": {\"x\": 0, \"y\": 0}, \"o\": {\"x\": 1, \"y\": 1} }, { \"t\": 180, \"s\": [360] } ] }, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 1], \"x\": ` var amount = thisComp('sound_control').sound_play ?? 0; var $bm_rt = [amount, 0, 0]; `, } } ] }, { \"nm\": \"sound_control\", \"ty\": 0, \"ip\": 0, \"op\": 180, \"st\": 0, \"ks\": {}, \"refId\": \"precomp\", \"w\": 512, \"h\": 512, \"tm\": { \"a\": 1, \"k\": [{ \"t\": 0, \"s\": [0], \"i\": {\"x\": 0, \"y\": 0}, \"o\": {\"x\": 1, \"y\": 1} }, { \"t\": 180, \"s\": [0] } ], \"x\": ` if ( thisLayer.last_time === undefined ) { thisLayer.last_time = time; // This variable wil control whether the sound is played thisLayer.sound_play = 0; // This should be the time in seconds you want the sound to play for thisLayer.sound_duration = 1; } // Usual time management stuff if ( time < thisLayer.last_time ) thisLayer.last_time = time; var dt = time - thisLayer.last_time; thisLayer.last_time = time; // Default to not playing var $bm_rt = 100; if ( thisLayer.sound_play > 0 ) { $bm_rt = thisLayer.sound_duration - thisLayer.sound_play; thisLayer.sound_play -= dt; }` } } ] } <div id=\"level8\"></div> var container = document.getElementById(\"level8\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } (function(){var json = { \"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 180, \"w\": 512, \"h\": 512, \"ddd\": 0, \"events\": { \"click\": \"thisComp('sound_control').sound_play = thisComp('sound_control').sound_duration\" }, \"assets\": [ { \"id\": \"sound\", \"u\": \"/lottie-docs/examples/\", \"p\": \"sound.mp3\", \"e\": 0 }, { \"id\": \"precomp\", \"layers\": [ { \"nm\": \"a\", \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"el\", \"p\": {\"a\": 1, \"k\": [ { \"t\": 0, \"s\": [0, 256], \"i\": {\"x\": 0, \"y\": 0}, \"o\": {\"x\": 1, \"y\": 1}, }, { \"t\": 60, \"s\": [512, 256], } ]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, }, { \"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 1, 0]}, \"o\": {\"a\": 0, \"k\": 100}, } ] }, { \"ty\": 6, \"ip\": 1, \"op\": 60, \"st\": 1, \"refId\": \"sound\", \"au\": { \"lv\": {\"a\": 0, \"k\": [100, 100]} } } ] } ], \"markers\": [], \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 180, \"st\": 0, \"ks\": {}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": { \"a\": 1, \"k\": [ { \"t\": 0, \"s\": [0], \"i\": {\"x\": 0, \"y\": 0}, \"o\": {\"x\": 1, \"y\": 1} }, { \"t\": 180, \"s\": [360] } ] }, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 1], \"x\": ` var amount = thisComp('sound_control').sound_play ?? 0; var $bm_rt = [amount, 0, 0]; `, } } ] }, { \"nm\": \"sound_control\", \"ty\": 0, \"ip\": 0, \"op\": 180, \"st\": 0, \"ks\": {}, \"refId\": \"precomp\", \"w\": 512, \"h\": 512, \"tm\": { \"a\": 1, \"k\": [{ \"t\": 0, \"s\": [0], \"i\": {\"x\": 0, \"y\": 0}, \"o\": {\"x\": 1, \"y\": 1} }, { \"t\": 180, \"s\": [0] } ], \"x\": ` if ( thisLayer.last_time === undefined ) { thisLayer.last_time = time; // This variable wil control whether the sound is played thisLayer.sound_play = 0; // This should be the time in seconds you want the sound to play for thisLayer.sound_duration = 1; } // Usual time management stuff if ( time < thisLayer.last_time ) thisLayer.last_time = time; var dt = time - thisLayer.last_time; thisLayer.last_time = time; // Default to not playing var $bm_rt = 100; if ( thisLayer.sound_play > 0 ) { $bm_rt = thisLayer.sound_duration - thisLayer.sound_play; thisLayer.sound_play -= dt; }` } } ] } ; var container = document.getElementById(\"level8\"); var options = { container: container, renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); function event_handler(ev, expression_function) { var thisComp = anim.renderer.compInterface; var time = anim.renderer.renderedFrame / anim.renderer.globalData.frameRate; if ( ev.clientX !== undefined ) { var rect = container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * thisComp.height; } expression_function(ev, thisComp, time); } for ( let [ev_type, expression] of Object.entries(json.events) ) { let expression_function = Function(\"event\", \"thisComp\", \"time\", expression); container.addEventListener(ev_type, ev => event_handler(ev, expression_function)); } })();","title":"Level 8: Sound Effects"},{"location":"advanced_interactions/#interlude-writing-a-small-wrapper","text":"Follows a JavaScript class that sets everything we've seen until now in a self-contained object. class LottieInteractionPlayer { constructor(container, custom_options={}) { if ( typeof container == \"string\" ) this.container = document.getElementById(container); else this.container = container; this.anim = null; this.custom_options = custom_options; // needed by keyup/down if ( !container.hasAttribute(\"tabindex\") ) container.setAttribute(\"tabindex\", \"0\"); this.handlers = {}; this._container_event_listener = this.container_event.bind(this); } // Deep copy lottie JSON lottie_clone(json) { return JSON.parse(JSON.stringify(json)); } load(lottie, resize = true) { // Options var options = { container: this.container, renderer: 'svg', loop: true, autoplay: true, // Clone because the player modifies the passed object animationData = this.lottie_clone(lottie); ...this.custom_options, }; if ( resize ) { this.container.style.width = lottie.w + \"px\"; this.container.style.height = lottie.h + \"px\"; } // Clean up this.clear(); // Setup handlers this.handlers = {}; if ( lottie.events ) { for ( var [name, func] of Object.entries(lottie.events) ) { this.handlers[name] = this.expression_to_event_handler(func); this.container.addEventListener(name, this._container_event_listener); } } // Create lottie player this.anim = bodymovin.loadAnimation(options); } // Destroy the animation clear() { if ( this.anim != null ) { try { this.anim.destroy(); this.anim = null; } catch ( e ) {} } for ( let name of Object.keys(this.handlers) ) this.container.removeEventListener(name, this._container_event_listener); } // Get the expression `thisComp` global get thisComp() { return this.anim.renderer.compInterface; } // Get the expression `time` global get time() { return this.anim.renderer.renderedFrame / this.anim.renderer.globalData.frameRate; } // Get an expression layer layer(name) { return this.thisComp(name); } // Handles an event from the container element container_event(ev) { this.prepare_lottie_event(ev); if ( this.handlers[ev.type] ) this.handle_lottie_event(ev, this.handlers[ev.type]); } // Adds useful attributes to an event object prepare_lottie_event(ev) { if ( ev.clientX !== undefined ) { var rect = this.container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * this.thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * this.thisComp.height; } } // Handles an event given a handler handle_lottie_event(ev, handler) { handler(ev, this.thisComp, this.time); } // Sets up an event handler expression_to_event_handler(expr) { return Function(\"event\", \"thisComp\", \"time\", expr); } }","title":"Interlude: Writing a Small Wrapper"},{"location":"advanced_interactions/#level-9-patching-the-renderer","text":"So far we've used the vanilla lottie-web player without modifications. This is good for the interactions described until now but for more advanced stuff we need to patch the player. The code in this level assumes you have a wrapper class similar to the one described in the interlude.","title":"Level 9: Patching the Renderer"},{"location":"advanced_interactions/#why","text":"Follows a description of some use cases that don't work with the current approach.","title":"Why"},{"location":"advanced_interactions/#initializing-values","text":"So far we've initialized custom layer attributes in the expressions using them. We started by checking if time is 0: // Initialize everything at the start if ( time == 0 ) { thisLayer.my_value = size[0] / 2; thisLayer.speed = 60; thisLayer.direction = 1; thisLayer.prev_time = 0; } Since that isn't always reliable, we moved on to checking if the attributes are undefined: // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; } While this works, it's a bit annoying because you don't know if you can access another layer's custom attributes on frame 0, so it would be nice to have an event for this: { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"load\": \"thisComp('mylayer').value = 123;\" } } We have the options of the DOMLoaded event from bodymovin: load(lottie, resize = true) { // (omitted the part of the code that's the same as before) // Create lottie player this.anim = bodymovin.loadAnimation(options); this.anim.addEventListener(\"DOMLoaded\", this._lottie_loaded_event.bind(this)); } _lottie_loaded_event() { // Create a dummy event object and invoke the this.container.dispatchEvent(new Event(\"load\"), {}); } The issue with this is such event can only be fired after the first frame has been renderer (and expressions have been evaluated at least once).","title":"Initializing Values"},{"location":"advanced_interactions/#dom-events-from-layers","text":"Until now the event handling has been done on the container element. Since all the layers result in DOM elements, it would be nice to be able to listen to events from those elements and handle them based on expressions defined on each layer. { \"ty\": 4, \"nm\": \"My layer\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {}, \"shapes\": [], \"events\": { \"click\": \"thisLayer.clicked = true;\" } } To do this we need a way of mapping the layer in the JSON to the DOM element and the value for the expression thisLayer . All this information is within the lottie-web SVG renderer but we need to find a way of accessing it. The first step is to allow a layer object to be passed to the events: // Handles an event from the container element container_event(ev) { this.prepare_lottie_event(ev); if ( this.handlers[ev.type] ) this.handle_lottie_event(ev, this.handlers[ev.type], null); } // Handles an event given a handler handle_lottie_event(ev, handler, layer) { handler(ev, this.thisComp, this.time, layer); } // Sets up an event handler expression_to_event_handler(expr) { return Function(\"event\", \"thisComp\", \"time\", \"thisLayer\", expr); }","title":"DOM Events from Layers"},{"location":"advanced_interactions/#how","text":"The gist of it is we need to path the renderer object and inject our code in some of its methods. Luckily we can do this on the fly: load(lottie, resize = true) { // (omitted the part of the code that's the same as before) // Create lottie player this.anim = bodymovin.loadAnimation(options); this._patch_renderer(); } _patch_renderer() { // We patch initItems to trigger an event before any expression is evaluated: var old_init = this.anim.renderer.initItems.bind(this.anim.renderer); var post_init = this._lottie_load_event.bind(this) this.anim.renderer.initItems = function(){ old_init(); post_init(); }; // We patch createItem to add event listener. // It takes the JSON layer as input and returns the renderer later object this.layer_elements = []; var old_create = this.anim.renderer.createItem.bind(this.anim.renderer); this.anim.renderer.createItem = (function(layer){ var item = old_create(layer); this._create_item_event(layer, item); return item; }).bind(this); } _lottie_load_event() { let ev = new Event(\"load\", {}); this.container.dispatchEvent(ev); for ( let layer of this.layer_elements ) layer.dispatchEvent(ev); } _create_item_event(lottie, item) { // lottie is the JSON layer // item.layerElement is the DOM element for this layer // item.layerInterface is the expression thisLayer object if ( !lottie.events ) return; // Create a dummy element for Null layers and the like, // it makes it easier to listen for `load` events let element = item.layerElement ?? document.createElement(\"div\"); // Keep track of layer elements so they can have the `load` event too this.layer_elements.push(element); for ( let [name, func] of Object.entries(lottie.events) ) { let handler = this.expression_to_event_handler(func); function listener(ev) { this.prepare_lottie_event(ev); this.handle_lottie_event(ev, handler, item.layerInterface); } element.addEventListener(name, listener.bind(this)); } } Now that the renderer has been patched can we be assured the patching is done before the functions we are patching have been called? The short answer is No, but we can have a look at how we can achieve this.","title":"How"},{"location":"advanced_interactions/#abusing-font-loading","text":"When a lottie has external fonts, the lottie-web player waits for every font to be loaded before initializing the renderer. Which means when you have text layers, the code above works perfectly. This is nice but not all lotties need text so we'll need something better.","title":"Abusing Font Loading"},{"location":"advanced_interactions/#deferring-animation-load","text":"The trick is to not pass the lottie JSON to lottie-web until after we've patched the renderer. This is easy enough because if you call bodymovin.loadAnimation without path or animationData everything will be initialized (including the renderer) and only the JSON loading step is missing. We can use this to patch the renderer before loading the animation: load(lottie, resize = true) { // Options var options = { container: this.container, renderer: 'svg', loop: true, autoplay: true, ...this.custom_options, // Note that animationData is deferred }; if ( resize ) { this.container.style.width = lottie.w + \"px\"; this.container.style.height = lottie.h + \"px\"; } // Clean up this.clear(); // Setup handlers this.handlers = {}; if ( lottie.events ) { for ( var [name, func] of Object.entries(lottie.events) ) { this.handlers[name] = this.expression_to_event_handler(func); this.container.addEventListener(name, this._container_event_listener); } } // Create lottie player this.anim = bodymovin.loadAnimation(options); this._patch_renderer(); this.anim.addEventListener(\"DOMLoaded\", this._lottie_loaded_event.bind(this)); // Clone because the player modifies the passed object var animation_data = this.lottie_clone(lottie); // Load animation separately so we can patch the renderer this.anim.setupAnimation(animation_data); } Note that anim.setupAnimation is available from lottie-web version 5.8.0. If you have earlier versions, you should call anim.configAnimation instead.","title":"Deferring Animation Load"},{"location":"advanced_interactions/#triggering-new-events","text":"We know how to make the lottie react to DOM events, but what if we want to make the DOM react to events triggered from the lottie? We can use the patching setup just discussed to also add events on the other direction, the only thing we need is adding a method to thisComp , so it's invokable from the expressions and make it trigger DOM events. The trick is to patch thisComp in the right place, fortunately we've already done the bulk of the work so we just need to add some more code when the animation has been loaded: _lottie_load_event() { let ev = new Event(\"load\", {}); this.container.dispatchEvent(ev); for ( let layer of this.layer_elements ) layer.dispatchEvent(ev); // We add a method for triggering events from the lottie this.thisComp.trigger_event = (function(type, detail){ this.container.dispatchEvent(new CustomEvent(\"lottie.\" + type, {detail})); }).bind(this); } Then you can add event listeners to the element containing the lottie animation.","title":"Triggering new events"},{"location":"advanced_interactions/#resulting-wrapper","text":"Here's the same wrapper class as described earlier, but with patching code applied to support the load event and layer events. class LottieInteractionPlayer { constructor(container, custom_options={}) { if ( typeof container == \"string\" ) this.container = document.getElementById(container); else this.container = container; this.anim = null; this.custom_options = custom_options; // needed by keyup/down if ( !container.hasAttribute(\"tabindex\") ) container.setAttribute(\"tabindex\", \"0\"); this.handlers = {}; this._container_event_listener = this.container_event.bind(this); } // Deep copy lottie JSON lottie_clone(json) { return JSON.parse(JSON.stringify(json)); } load(lottie, resize = true) { // Options var options = { container: this.container, renderer: 'svg', loop: true, autoplay: true, ...this.custom_options, // Note that animationData is deferred }; if ( resize ) { this.container.style.width = lottie.w + \"px\"; this.container.style.height = lottie.h + \"px\"; } // Clean up this.clear(); // Setup handlers this.handlers = {}; if ( lottie.events ) { for ( var [name, func] of Object.entries(lottie.events) ) { this.handlers[name] = this.expression_to_event_handler(func); this.container.addEventListener(name, this._container_event_listener); } } // Create lottie player this.anim = bodymovin.loadAnimation(options); this._patch_renderer(); // Clone because the player modifies the passed object var animation_data = this.lottie_clone(lottie); // Load animation separately so we can patch the renderer this.anim.setupAnimation(animation_data); } _patch_renderer() { // We patch initItems to trigger an event before any expression is evaluated: var old_init = this.anim.renderer.initItems.bind(this.anim.renderer); var post_init = this._lottie_load_event.bind(this) this.anim.renderer.initItems = function(){ old_init(); post_init(); }; // We patch createItem to add event listener. // It takes the JSON layer as input and returns the renderer later object this.layer_elements = []; var old_create = this.anim.renderer.createItem.bind(this.anim.renderer); this.anim.renderer.createItem = (function(layer){ var item = old_create(layer); this._create_item_event(layer, item); return item; }).bind(this); } _create_item_event(lottie, item) { // lottie is the JSON layer // item.layerElement is the DOM element for this layer // item.layerInterface is the expression thisLayer object if ( !lottie.events ) return; // Create a dummy element for Null layers and the like, // it makes it easier to listen for `load` events let element = item.layerElement ?? document.createElement(\"div\"); // Keep track of layer elements so they can have the `load` event too this.layer_elements.push(element); for ( let [name, func] of Object.entries(lottie.events) ) { let handler = this.expression_to_event_handler(func); function listener(ev) { this.prepare_lottie_event(ev); this.handle_lottie_event(ev, handler, item.layerInterface); } element.addEventListener(name, listener.bind(this)); } } _lottie_load_event() { let ev = new Event(\"load\", {}); this.container.dispatchEvent(ev); for ( let layer of this.layer_elements ) layer.dispatchEvent(ev); // We add a method for triggering events from the lottie this.thisComp.trigger_event = (function(type, detail){ this.container.dispatchEvent(new CustomEvent(\"lottie.\" + type, {detail})); }).bind(this); } // Destroy the animation clear() { if ( this.anim != null ) { try { this.anim.destroy(); this.anim = null; } catch ( e ) {} } for ( let name of Object.keys(this.handlers) ) this.container.removeEventListener(name, this._container_event_listener); } // Get the expression `thisComp` global get thisComp() { return this.anim.renderer.compInterface; } // Get the expression `time` global get time() { return this.anim.renderer.renderedFrame / this.anim.renderer.globalData.frameRate; } // Get an expression layer layer(name) { return this.thisComp(name); } // Handles an event from the container element container_event(ev) { this.prepare_lottie_event(ev); if ( this.handlers[ev.type] ) this.handle_lottie_event(ev, this.handlers[ev.type], null); } // Adds useful attributes to an event object prepare_lottie_event(ev) { if ( ev.clientX !== undefined ) { var rect = this.container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * this.thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * this.thisComp.height; } } // Handles an event given a handler handle_lottie_event(ev, handler, layer) { handler(ev, this.thisComp, this.time, layer); } // Sets up an event handler expression_to_event_handler(expr) { return Function(\"event\", \"thisComp\", \"time\", \"thisLayer\", expr); } } class LottieInteractionPlayer { constructor(container, custom_options={}) { if ( typeof container == \"string\" ) this.container = document.getElementById(container); else this.container = container; this.anim = null; this.custom_options = custom_options; // needed by keyup/down if ( !container.hasAttribute(\"tabindex\") ) container.setAttribute(\"tabindex\", \"0\"); this.handlers = {}; this._container_event_listener = this.container_event.bind(this); } // Deep copy lottie JSON lottie_clone(json) { return JSON.parse(JSON.stringify(json)); } load(lottie, resize = true) { // Options var options = { container: this.container, renderer: 'svg', loop: true, autoplay: true, ...this.custom_options, // Note that animationData is deferred }; if ( resize ) { this.container.style.width = lottie.w + \"px\"; this.container.style.height = lottie.h + \"px\"; } // Clean up this.clear(); // Setup handlers this.handlers = {}; if ( lottie.events ) { for ( var [name, func] of Object.entries(lottie.events) ) { this.handlers[name] = this.expression_to_event_handler(func); this.container.addEventListener(name, this._container_event_listener); } } // Create lottie player this.anim = bodymovin.loadAnimation(options); this._patch_renderer(); // Clone because the player modifies the passed object var animation_data = this.lottie_clone(lottie); // Load animation separately so we can patch the renderer this.anim.setupAnimation(animation_data); } _patch_renderer() { // We patch initItems to trigger an event before any expression is evaluated: var old_init = this.anim.renderer.initItems.bind(this.anim.renderer); var post_init = this._lottie_load_event.bind(this) this.anim.renderer.initItems = function(){ old_init(); post_init(); }; // We patch createItem to add event listener. // It takes the JSON layer as input and returns the renderer later object this.layer_elements = []; var old_create = this.anim.renderer.createItem.bind(this.anim.renderer); this.anim.renderer.createItem = (function(layer){ var item = old_create(layer); this._create_item_event(layer, item); return item; }).bind(this); } _create_item_event(lottie, item) { // lottie is the JSON layer // item.layerElement is the DOM element for this layer // item.layerInterface is the expression thisLayer object if ( !lottie.events ) return; // Create a dummy element for Null layers and the like, // it makes it easier to listen for `load` events let element = item.layerElement ?? document.createElement(\"div\"); // Keep track of layer elements so they can have the `load` event too this.layer_elements.push(element); for ( let [name, func] of Object.entries(lottie.events) ) { let handler = this.expression_to_event_handler(func); function listener(ev) { this.prepare_lottie_event(ev); this.handle_lottie_event(ev, handler, item.layerInterface); } element.addEventListener(name, listener.bind(this)); } } _lottie_load_event() { let ev = new Event(\"load\", {}); this.container.dispatchEvent(ev); for ( let layer of this.layer_elements ) layer.dispatchEvent(ev); // We add a method for triggering events from the lottie this.thisComp.trigger_event = (function(type, detail){ this.container.dispatchEvent(new CustomEvent(\"lottie.\" + type, {detail})); }).bind(this); } // Destroy the animation clear() { if ( this.anim != null ) { try { this.anim.destroy(); this.anim = null; } catch ( e ) {} } for ( let name of Object.keys(this.handlers) ) this.container.removeEventListener(name, this._container_event_listener); } // Get the expression `thisComp` global get thisComp() { return this.anim.renderer.compInterface; } // Get the expression `time` global get time() { return this.anim.renderer.renderedFrame / this.anim.renderer.globalData.frameRate; } // Get an expression layer layer(name) { return this.thisComp(name); } // Handles an event from the container element container_event(ev) { this.prepare_lottie_event(ev); if ( this.handlers[ev.type] ) this.handle_lottie_event(ev, this.handlers[ev.type], null); } // Adds useful attributes to an event object prepare_lottie_event(ev) { if ( ev.clientX !== undefined ) { var rect = this.container.getBoundingClientRect(); ev.lottie_x = (ev.clientX - rect.left) / rect.width * this.thisComp.width; ev.lottie_y = (ev.clientY - rect.top) / rect.height * this.thisComp.height; } } // Handles an event given a handler handle_lottie_event(ev, handler, layer) { handler(ev, this.thisComp, this.time, layer); } // Sets up an event handler expression_to_event_handler(expr) { return Function(\"event\", \"thisComp\", \"time\", \"thisLayer\", expr); } }","title":"Resulting Wrapper"},{"location":"advanced_interactions/#animation-or-interaction","text":"It's possible to use the custom load to detect whether the lottie is being played in an environment that supports the custom events. The following example is similar to the click example from level 7 but when a player doesn't have interaction support, the star moves around on its own. Lottie HTML CSS Script Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"click\": \"var star = thisComp('star'); star.px = event.lottie_x; star.py = event.lottie_y;\", \"load\": \"thisComp('star').interactive = true;\" }, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; if ( !thisLayer.interactive ) { thisLayer.dx = 1; thisLayer.dy = 1; thisLayer.prev_time = 0; } } if ( !thisLayer.interactive ) { if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; thisLayer.px += thisLayer.dx * dt * 100; thisLayer.py += thisLayer.dy * dt * 120; var radius = thisLayer.content(1).outerRadius; if ( thisLayer.px < radius ) thisLayer.dx = 1; else if ( thisLayer.px > thisComp.width - radius ) thisLayer.dx = -1; if ( thisLayer.py < radius ) thisLayer.dy = 1; else if ( thisLayer.py > thisComp.height - radius ) thisLayer.dy = -1; } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], } } ] } ] } <div id=\"level9_parent\"> <div id=\"level9_not_interactive\"></div> <div id=\"level9_interactive\"></div> </div> #level9_parent { display: flex; } #level9_interactive, #level9_not_interactive { border: 1px solid #ccc; width: 50%; box-sizing: border-box; } var options = { container: document.getElementById(\"level9_not_interactive\"), renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); var player = new LottieInteractionPlayer(document.getElementById(\"level9_interactive\")); player.load(json, false); #level9_parent { display: flex; } #level9_interactive, #level9_not_interactive { border: 1px solid #ccc; width: 50%; box-sizing: border-box; } (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"events\": { \"click\": \"var star = thisComp('star'); star.px = event.lottie_x; star.py = event.lottie_y;\", \"load\": \"thisComp('star').interactive = true;\" }, \"layers\": [ { \"ty\": 4, \"nm\": \"star\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 0], \"x\": ` // Initialization if ( thisLayer.px === undefined ) { thisLayer.px = thisComp.width / 2; thisLayer.py = thisComp.height / 2; if ( !thisLayer.interactive ) { thisLayer.dx = 1; thisLayer.dy = 1; thisLayer.prev_time = 0; } } if ( !thisLayer.interactive ) { if ( time < thisLayer.prev_time ) thisLayer.prev_time = time; var dt = time - thisLayer.prev_time; thisLayer.prev_time = time; thisLayer.px += thisLayer.dx * dt * 100; thisLayer.py += thisLayer.dy * dt * 120; var radius = thisLayer.content(1).outerRadius; if ( thisLayer.px < radius ) thisLayer.dx = 1; else if ( thisLayer.px > thisComp.width - radius ) thisLayer.dx = -1; if ( thisLayer.py < radius ) thisLayer.dy = 1; else if ( thisLayer.py > thisComp.height - radius ) thisLayer.dy = -1; } // Set value var $bm_rt = [thisLayer.px, thisLayer.py]; `}}, \"shapes\": [ { \"ty\": \"sr\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"or\": {\"a\": 0, \"k\": 70}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0} }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": { \"a\": 0, \"k\": [1, 1, 0.3], } } ] } ] } ; var options = { container: document.getElementById(\"level9_not_interactive\"), renderer: \"svg\", loop: true, autoplay: true, animationData: json, }; var anim = bodymovin.loadAnimation(options); var player = new LottieInteractionPlayer(document.getElementById(\"level9_interactive\")); player.load(json, false); })();","title":"Animation or Interaction"},{"location":"advanced_interactions/#lottie-button-example","text":"This example uses everything we discussed so far. A quick note: to avoid clicks going to the wrong layer we need to define some CSS that gets rid of pointer events for layers we don't want to click. Lottie Script HTML CSS Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"fonts\": {\"list\":[ { \"ascent\": 72, \"fFamily\": \"Roboto\", \"fName\": \"Roboto Regular\", \"fStyle\": \"Regular\", \"fPath\": \"https://fonts.googleapis.com/css2?family=Roboto&display=swap\", \"origin\": 1, } ]}, \"layers\": [ { \"ty\": 5, \"ip\": 0, \"op\": 60, \"st\": 0, \"parent\": 1, \"cl\": \"no-mouse\", \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 25]}, }, \"t\": { \"a\": [], \"d\": { \"x\": \"var $bm_rt = 'Clicks: ' + thisComp('button').clicks;\", \"k\": [ { \"s\": { \"f\": \"Roboto Regular\", \"fc\": [0, 0, 0], \"s\": 70, \"t\": \"\", \"j\": 2, }, \"t\": 0 } ] }, \"m\": { \"a\": {\"a\": 0, \"k\": [0,0]}, \"g\": 3 }, \"p\": {} } }, { \"ty\": 4, \"nm\": \"button\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ind\": 1, \"cl\": \"lottie-button\", \"events\": { \"load\": \"thisLayer.clicks = 0;\", \"click\": \"thisLayer.clicks += 1; thisComp.trigger_event('click', {clicks: thisLayer.clicks});\", \"mouseenter\": \"thisLayer.highlighted = true;\", \"mouseleave\": \"thisLayer.highlighted = false;\" }, \"ks\": { \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": { \"a\": 0, \"k\": [100, 100], \"x\": \"var sz = thisLayer.highlighted ? 120 : 100; var $bm_rt = [sz, sz];\" } }, \"shapes\": [ { \"ty\": \"rc\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [350, 90]}, \"r\": {\"a\": 0, \"k\": 3}, }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 1, 0]}, \"w\": {\"a\": 0, \"k\": 1}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 50, \"x\": \"var $bm_rt = thisLayer.highlighted ? 70 : 30;\"}, \"c\": {\"a\": 0, \"k\": [0.4, 1, 0.4]} } ] } ] } var container = document.getElementById(\"level9_button\"); var player = new LottieInteractionPlayer(container); player.load(json); container.addEventListener(\"lottie.click\", ev => document.getElementById(\"level9_outer\").innerText = `Lottie clicked ${ev.detail.clicks} times` ); <div id=\"level9_button\"></div> <div id=\"level9_outer\">Button not clicked</div> .no-mouse { pointer-events: none; } .lottie-button { cursor: pointer; } Button not clicked .no-mouse { pointer-events: none; } .lottie-button { cursor: pointer; } (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"fonts\": {\"list\":[ { \"ascent\": 72, \"fFamily\": \"Roboto\", \"fName\": \"Roboto Regular\", \"fStyle\": \"Regular\", \"fPath\": \"https://fonts.googleapis.com/css2?family=Roboto&display=swap\", \"origin\": 1, } ]}, \"layers\": [ { \"ty\": 5, \"ip\": 0, \"op\": 60, \"st\": 0, \"parent\": 1, \"cl\": \"no-mouse\", \"ks\": { \"p\": {\"a\": 0, \"k\": [0, 25]}, }, \"t\": { \"a\": [], \"d\": { \"x\": \"var $bm_rt = 'Clicks: ' + thisComp('button').clicks;\", \"k\": [ { \"s\": { \"f\": \"Roboto Regular\", \"fc\": [0, 0, 0], \"s\": 70, \"t\": \"\", \"j\": 2, }, \"t\": 0 } ] }, \"m\": { \"a\": {\"a\": 0, \"k\": [0,0]}, \"g\": 3 }, \"p\": {} } }, { \"ty\": 4, \"nm\": \"button\", \"ip\": 0, \"op\": 60, \"st\": 0, \"ind\": 1, \"cl\": \"lottie-button\", \"events\": { \"load\": \"thisLayer.clicks = 0;\", \"click\": \"thisLayer.clicks += 1; thisComp.trigger_event('click', {clicks: thisLayer.clicks});\", \"mouseenter\": \"thisLayer.highlighted = true;\", \"mouseleave\": \"thisLayer.highlighted = false;\" }, \"ks\": { \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": { \"a\": 0, \"k\": [100, 100], \"x\": \"var sz = thisLayer.highlighted ? 120 : 100; var $bm_rt = [sz, sz];\" } }, \"shapes\": [ { \"ty\": \"rc\", \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [350, 90]}, \"r\": {\"a\": 0, \"k\": 3}, }, { \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 1, 0]}, \"w\": {\"a\": 0, \"k\": 1}, }, { \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 50, \"x\": \"var $bm_rt = thisLayer.highlighted ? 70 : 30;\"}, \"c\": {\"a\": 0, \"k\": [0.4, 1, 0.4]} } ] } ] } ; var container = document.getElementById(\"level9_button\"); var player = new LottieInteractionPlayer(container); player.load(json); container.addEventListener(\"lottie.click\", ev => document.getElementById(\"level9_outer\").innerText = `Lottie clicked ${ev.detail.clicks} times` ); })();","title":"Lottie Button Example"},{"location":"advanced_interactions/#3d","text":"Everything discussed so far was for the lottie-web svg renderer but all the patching works with the html renderer as well. The html renderer supports 3D layers so we can make an interactive 3D scene with little effort. The main caveat is that you need to set position: relative on the container element. On the example below you can click to capture the mouse then have first-person controls. Lottie Script HTML CSS Result { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 180, \"fr\": 60, \"w\": 512, \"h\": 512, \"fonts\": { \"list\": [] }, \"assets\": [], \"layers\": [ { \"nm\": \"Camera\", \"ty\": 13, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 0, 0, -10 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"pe\": { \"a\": 0, \"k\": 256 }, \"ddd\": 1 }, { \"nm\": \"Move Parent\", \"ty\": 3, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"a\": { \"a\": 0, \"k\": [ 0, 0, 0 ], \"x\": \"var dt = thisComp.time_delta(thisLayer, time);\\n\\n if ( thisComp.mouse_dx )\\n {\\n thisComp.char_angle -= dt * thisComp.mouse_dx / 8 * Math.PI;\\n thisComp.mouse_dx = 0;\\n }\\n\\n if ( thisComp.mouse_dy )\\n {\\n thisComp.look_angle += dt * thisComp.mouse_dy / 8 * Math.PI;\\n thisComp.mouse_dy = 0;\\n }\\n\\n\\n var left = thisComp.keys_pressed.ArrowLeft || thisComp.keys_pressed.a;\\n var right = thisComp.keys_pressed.ArrowRight || thisComp.keys_pressed.d;\\n var dx = 0;\\n if ( left && right )\\n dx = 0;\\n else if ( left )\\n dx = -1;\\n else if ( right )\\n dx = 1;\\n\\n var up = thisComp.keys_pressed.ArrowUp || thisComp.keys_pressed.w;\\n var down = thisComp.keys_pressed.ArrowDown || thisComp.keys_pressed.s;\\n var dz = 0;\\n if ( up && down )\\n dz = 0;\\n else if ( up )\\n dz = 1;\\n else if ( down )\\n dz = -1;\\n\\n thisLayer.char_x += dz * dt * -200 * Math.sin(thisComp.char_angle);\\n thisLayer.char_z += dz * dt * 200 * Math.cos(thisComp.char_angle);\\n\\n thisLayer.char_x += dx * dt * -200 * Math.sin(thisComp.char_angle - Math.PI / 2);\\n thisLayer.char_z += dx * dt * 200 * Math.cos(thisComp.char_angle - Math.PI / 2);\\n\\n var $bm_rt = [thisLayer.char_x, thisLayer.char_y, thisLayer.char_z];\\n \\n/**/\" }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ], \"x\": \"var $bm_rt = [thisComp.look_angle * 180 / Math.PI, thisComp.char_angle * 180 / Math.PI, 0];\\n \\n/**/\" } }, \"ind\": 1, \"ddd\": 1, \"events\": { \"load\": \"thisLayer.char_x = 0;\\n thisLayer.char_z = 0;\\n thisLayer.char_y = 0;\\n \\n/**/\" } }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 0, 0, 200 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 0.5, 0.5, 1 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 0, 0, -200 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 0.5, 0.5, 0 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 200, 0, 0 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 90 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 1, 0.5, 0.5 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ -200, 0, 0 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 90 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 0, 0.5, 0.5 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] } ], \"events\": { \"keydown\": \"thisComp.keys_pressed[event.key] = true;\\n\\n if ( event.key != \\\"F5\\\" )\\n event.preventDefault();\\n \\n/**/\", \"keyup\": \"thisComp.keys_pressed[event.key] = false;\\n\\n if ( event.key != \\\"F5\\\" )\\n event.preventDefault();\\n \\n/**/\", \"load\": \"thisComp.keys_pressed = {};\\n thisComp.mouse_dx = 0;\\n thisComp.mouse_dy = 0;\\n thisComp.char_angle = 0;\\n thisComp.look_angle = 0;\\n thisComp.time_delta = function (thisLayer, time) {\\n if ( thisLayer.last_time === undefined || time < thisLayer.last_time )\\n {\\n thisLayer.last_time = time;\\n return 0;\\n }\\n\\n var dt = time - thisLayer.last_time;\\n thisLayer.last_time = time;\\n return dt;\\n };\\n \\n/**/\", \"mouseenter\": \"thisComp.mouse_old_x = thisComp.mouse_x = event.lottie_x;\\n thisComp.mouse_old_y = thisComp.mouse_y = event.lottie_x;\\n \\n/**/\", \"mouseleave\": \"thisComp.mouse_old_x = thisComp.mouse_x = event.lottie_x;\\n thisComp.mouse_old_y = thisComp.mouse_y = event.lottie_x;\\n \\n/**/\", \"mousemove\": \"thisComp.mouse_dx += event.movementX;\\n thisComp.mouse_dy += event.movementY;\\n \\n/**/\" }, \"ddd\": 1 } var container = document.getElementById(\"level9_3d\"); var player = new LottieInteractionPlayer(container, {renderer: \"html\"}); player.load(json); <div id=\"level9_3d\" onclick=\"this.requestPointerLock();\"></div> #level9_3d { position: relative; } #level9_3d { position: relative; } (function(){var json = { \"v\": \"5.9.1\", \"ip\": 0, \"op\": 180, \"fr\": 60, \"w\": 512, \"h\": 512, \"fonts\": { \"list\": [] }, \"assets\": [], \"layers\": [ { \"nm\": \"Camera\", \"ty\": 13, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 0, 0, -10 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"pe\": { \"a\": 0, \"k\": 256 }, \"ddd\": 1 }, { \"nm\": \"Move Parent\", \"ty\": 3, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"a\": { \"a\": 0, \"k\": [ 0, 0, 0 ], \"x\": \"var dt = thisComp.time_delta(thisLayer, time);\\n\\n if ( thisComp.mouse_dx )\\n {\\n thisComp.char_angle -= dt * thisComp.mouse_dx / 8 * Math.PI;\\n thisComp.mouse_dx = 0;\\n }\\n\\n if ( thisComp.mouse_dy )\\n {\\n thisComp.look_angle += dt * thisComp.mouse_dy / 8 * Math.PI;\\n thisComp.mouse_dy = 0;\\n }\\n\\n\\n var left = thisComp.keys_pressed.ArrowLeft || thisComp.keys_pressed.a;\\n var right = thisComp.keys_pressed.ArrowRight || thisComp.keys_pressed.d;\\n var dx = 0;\\n if ( left && right )\\n dx = 0;\\n else if ( left )\\n dx = -1;\\n else if ( right )\\n dx = 1;\\n\\n var up = thisComp.keys_pressed.ArrowUp || thisComp.keys_pressed.w;\\n var down = thisComp.keys_pressed.ArrowDown || thisComp.keys_pressed.s;\\n var dz = 0;\\n if ( up && down )\\n dz = 0;\\n else if ( up )\\n dz = 1;\\n else if ( down )\\n dz = -1;\\n\\n thisLayer.char_x += dz * dt * -200 * Math.sin(thisComp.char_angle);\\n thisLayer.char_z += dz * dt * 200 * Math.cos(thisComp.char_angle);\\n\\n thisLayer.char_x += dx * dt * -200 * Math.sin(thisComp.char_angle - Math.PI / 2);\\n thisLayer.char_z += dx * dt * 200 * Math.cos(thisComp.char_angle - Math.PI / 2);\\n\\n var $bm_rt = [thisLayer.char_x, thisLayer.char_y, thisLayer.char_z];\\n \\n/**/\" }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ], \"x\": \"var $bm_rt = [thisComp.look_angle * 180 / Math.PI, thisComp.char_angle * 180 / Math.PI, 0];\\n \\n/**/\" } }, \"ind\": 1, \"ddd\": 1, \"events\": { \"load\": \"thisLayer.char_x = 0;\\n thisLayer.char_z = 0;\\n thisLayer.char_y = 0;\\n \\n/**/\" } }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 0, 0, 200 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 0.5, 0.5, 1 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 0, 0, -200 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 0 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 0.5, 0.5, 0 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ 200, 0, 0 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 90 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 1, 0.5, 0.5 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] }, { \"ty\": 4, \"ip\": 0, \"op\": 180, \"st\": 0, \"sr\": 1, \"ks\": { \"p\": { \"a\": 0, \"k\": [ -200, 0, 0 ] }, \"rx\": { \"a\": 0, \"k\": 0 }, \"ry\": { \"a\": 0, \"k\": 90 }, \"rz\": { \"a\": 0, \"k\": 0 }, \"or\": { \"a\": 0, \"k\": [ 0, 0, 0 ] } }, \"ddd\": 1, \"parent\": 1, \"shapes\": [ { \"ty\": \"rc\", \"s\": { \"a\": 0, \"k\": [ 200, 200 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"r\": { \"a\": 0, \"k\": 0 } }, { \"ty\": \"fl\", \"c\": { \"a\": 0, \"k\": [ 0, 0.5, 0.5 ] }, \"o\": { \"a\": 0, \"k\": 100 } } ] } ], \"events\": { \"keydown\": \"thisComp.keys_pressed[event.key] = true;\\n\\n if ( event.key != \\\"F5\\\" )\\n event.preventDefault();\\n \\n/**/\", \"keyup\": \"thisComp.keys_pressed[event.key] = false;\\n\\n if ( event.key != \\\"F5\\\" )\\n event.preventDefault();\\n \\n/**/\", \"load\": \"thisComp.keys_pressed = {};\\n thisComp.mouse_dx = 0;\\n thisComp.mouse_dy = 0;\\n thisComp.char_angle = 0;\\n thisComp.look_angle = 0;\\n thisComp.time_delta = function (thisLayer, time) {\\n if ( thisLayer.last_time === undefined || time < thisLayer.last_time )\\n {\\n thisLayer.last_time = time;\\n return 0;\\n }\\n\\n var dt = time - thisLayer.last_time;\\n thisLayer.last_time = time;\\n return dt;\\n };\\n \\n/**/\", \"mouseenter\": \"thisComp.mouse_old_x = thisComp.mouse_x = event.lottie_x;\\n thisComp.mouse_old_y = thisComp.mouse_y = event.lottie_x;\\n \\n/**/\", \"mouseleave\": \"thisComp.mouse_old_x = thisComp.mouse_x = event.lottie_x;\\n thisComp.mouse_old_y = thisComp.mouse_y = event.lottie_x;\\n \\n/**/\", \"mousemove\": \"thisComp.mouse_dx += event.movementX;\\n thisComp.mouse_dy += event.movementY;\\n \\n/**/\" }, \"ddd\": 1 } ; var container = document.getElementById(\"level9_3d\"); var player = new LottieInteractionPlayer(container, {renderer: \"html\"}); player.load(json); })(); document.querySelectorAll(\".nav-tabs a\").forEach( link => link.addEventListener(\"click\", e => jQuery(e.target).tab(\"show\")) );","title":"3D"},{"location":"assets/","text":"Assets Assets are usually referenced by layers of the appropriate type. Asset Composition Diagram for Asset Asset Visual Object File Asset Image Data source Sound Precomposition Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions id string ID Unique identifier used by layers when referencing this asset File Asset Asset referencing a file Composition Diagram for File Asset File Asset Asset Visual Object Image Data source Sound Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions id string ID Unique identifier used by layers when referencing this asset p string File Name Name of the asset file or a data url u string File Path Path to the asset file e 0-1 integer Embedded If '1', 'p' is a Data URL Image Represents a (static) image Composition Diagram for Image Image File Asset Slottable Object Asset Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions id string ID Unique identifier used by layers when referencing this asset p string File Name Name of the asset file or a data url u string File Path Path to the asset file e 0-1 integer Embedded If '1', 'p' is a Data URL sid string Slot Id Identifier to look up the slot w number Width Width of the image h number Height Height of the image t string = 'seq' Type Marks as part of an image sequence if present If the image is embedded, u is empty and p contains a base64-encoded data url: { \"id\": \"my image\", \"h\": 512, \"w\": 512, \"e\": 1, \"u\": \"\", \"p\": \"data:image/png;base64,...\" } If the image is not embedded, u will contain the path to the directory containing the image and p will have the filename. So for example if you want to store the image at /path/to/images/image.png , the asset will look something like this: { \"id\": \"my image\", \"h\": 512, \"w\": 512, \"e\": 0, \"u\": \"/path/to/images/\", \"p\": \"image.png\" } It works similarly for external images. If you want to store the image at https://example.com/images/image.png , you'd have: { \"id\": \"my image\", \"h\": 512, \"w\": 512, \"e\": 0, \"u\": \"https://example.com/images/\", \"p\": \"image.png\" } Sound Similar to Image but for audio files. Composition Diagram for Sound Sound File Asset Asset Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions id string ID Unique identifier used by layers when referencing this asset p string File Name Name of the asset file or a data url u string File Path Path to the asset file e 0-1 integer Embedded If '1', 'p' is a Data URL Precomposition You can think of precompositions as self-contained animation within the main animation file that can be referenced using precomp layers . Within a precomposition you can have precomp layers showing other precompositions, as long as you don't create a dependency cycle. You can find more details in the Precompositions page. Composition Diagram for Precomposition Precomposition Asset Composition Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions id string ID Unique identifier used by layers when referencing this asset layers array of Layer Layers Layers fr number Framerate Framerate in frames per second xt 0-1 integer Extra Extra composition Follows a rather extreme example, that uses precompositions inside precompositions to generate a fractal: var lottie_player_0 = new LottiePlayer( 'lottie_target_0', '../static/examples/fractal.json', true, {} ); Data Source Points to a JSON file for data. Composition Diagram for Data source Data source File Asset Asset Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions id string ID Unique identifier used by layers when referencing this asset p string File Name Name of the asset file or a data url u string File Path Path to the asset file e 0-1 integer Embedded If '1', 'p' is a Data URL t integer = 3 Type Type","title":"Assets"},{"location":"assets/#assets","text":"Assets are usually referenced by layers of the appropriate type.","title":"Assets"},{"location":"assets/#asset","text":"Composition Diagram for Asset Asset Visual Object File Asset Image Data source Sound Precomposition Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions id string ID Unique identifier used by layers when referencing this asset","title":"Asset"},{"location":"assets/#file-asset","text":"Asset referencing a file Composition Diagram for File Asset File Asset Asset Visual Object Image Data source Sound Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions id string ID Unique identifier used by layers when referencing this asset p string File Name Name of the asset file or a data url u string File Path Path to the asset file e 0-1 integer Embedded If '1', 'p' is a Data URL","title":"File Asset"},{"location":"assets/#image","text":"Represents a (static) image Composition Diagram for Image Image File Asset Slottable Object Asset Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions id string ID Unique identifier used by layers when referencing this asset p string File Name Name of the asset file or a data url u string File Path Path to the asset file e 0-1 integer Embedded If '1', 'p' is a Data URL sid string Slot Id Identifier to look up the slot w number Width Width of the image h number Height Height of the image t string = 'seq' Type Marks as part of an image sequence if present If the image is embedded, u is empty and p contains a base64-encoded data url: { \"id\": \"my image\", \"h\": 512, \"w\": 512, \"e\": 1, \"u\": \"\", \"p\": \"data:image/png;base64,...\" } If the image is not embedded, u will contain the path to the directory containing the image and p will have the filename. So for example if you want to store the image at /path/to/images/image.png , the asset will look something like this: { \"id\": \"my image\", \"h\": 512, \"w\": 512, \"e\": 0, \"u\": \"/path/to/images/\", \"p\": \"image.png\" } It works similarly for external images. If you want to store the image at https://example.com/images/image.png , you'd have: { \"id\": \"my image\", \"h\": 512, \"w\": 512, \"e\": 0, \"u\": \"https://example.com/images/\", \"p\": \"image.png\" }","title":"Image"},{"location":"assets/#sound","text":"Similar to Image but for audio files. Composition Diagram for Sound Sound File Asset Asset Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions id string ID Unique identifier used by layers when referencing this asset p string File Name Name of the asset file or a data url u string File Path Path to the asset file e 0-1 integer Embedded If '1', 'p' is a Data URL","title":"Sound"},{"location":"assets/#precomposition","text":"You can think of precompositions as self-contained animation within the main animation file that can be referenced using precomp layers . Within a precomposition you can have precomp layers showing other precompositions, as long as you don't create a dependency cycle. You can find more details in the Precompositions page. Composition Diagram for Precomposition Precomposition Asset Composition Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions id string ID Unique identifier used by layers when referencing this asset layers array of Layer Layers Layers fr number Framerate Framerate in frames per second xt 0-1 integer Extra Extra composition Follows a rather extreme example, that uses precompositions inside precompositions to generate a fractal: var lottie_player_0 = new LottiePlayer( 'lottie_target_0', '../static/examples/fractal.json', true, {} );","title":"Precomposition"},{"location":"assets/#data-source","text":"Points to a JSON file for data. Composition Diagram for Data source Data source File Asset Asset Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions id string ID Unique identifier used by layers when referencing this asset p string File Name Name of the asset file or a data url u string File Path Path to the asset file e 0-1 integer Embedded If '1', 'p' is a Data URL t integer = 3 Type Type","title":"Data Source"},{"location":"compat/","text":"Compatibility with older versions This page describes breaking changes that have been introduced over time. You'd need to check v from Animation to see the the lottie is so old to need to worry about these. The code examples are just for illustrative purposes and are not to be taken as a complete conversion code. [0,255] Colors Until v 4.1.9. Modern Lotties have color components in the [0, 1] range. Older ones have components in the [0, 255] range. Fix: Divide all color components by 255. Static text document Until v 4.4.14. In Text Data , d was not animated. Fix: Wrap into an animated property text_layer.t.d = {\"a\": 0, \"k\": text_layer.t.d} Shape closing Until v 4.4.18. Path objects had a boolean closed property and c was not present in the bezier data. Similarly, Mask had cl that worked the same way. Fix: For each Path , update all the keyframes (or the non-animated value) of ks . Do the same to fix pt in each Mask . shape.ks.k.c = shape.closed ? 1 : 0 Old keyframe style Until v 5.0.0 (?). Keyframes had an e property that specified the end value for that keyframe ( s marking the start value), and the last keyframe would not have s . Fix: Ignore all the e in keyframes, but copy the e from the keyframe before last into the last keyframe. keyframes[keyframes.length - 1].s = keyframes[keyframes.length - 2].e Static text layer properties Until v 5.7.15. In Text Follow Path properties r , a , and p were plain numbers instead of animated properties. Fix: Wrap all of those into animated properties text_layer.t.p.a + {\"a\": 0, \"k\": text_layer.t.p.a}","title":"Compatibility with older versions"},{"location":"compat/#compatibility-with-older-versions","text":"This page describes breaking changes that have been introduced over time. You'd need to check v from Animation to see the the lottie is so old to need to worry about these. The code examples are just for illustrative purposes and are not to be taken as a complete conversion code.","title":"Compatibility with older versions"},{"location":"compat/#0255-colors","text":"Until v 4.1.9. Modern Lotties have color components in the [0, 1] range. Older ones have components in the [0, 255] range. Fix: Divide all color components by 255.","title":"[0,255] Colors"},{"location":"compat/#static-text-document","text":"Until v 4.4.14. In Text Data , d was not animated. Fix: Wrap into an animated property text_layer.t.d = {\"a\": 0, \"k\": text_layer.t.d}","title":"Static text document"},{"location":"compat/#shape-closing","text":"Until v 4.4.18. Path objects had a boolean closed property and c was not present in the bezier data. Similarly, Mask had cl that worked the same way. Fix: For each Path , update all the keyframes (or the non-animated value) of ks . Do the same to fix pt in each Mask . shape.ks.k.c = shape.closed ? 1 : 0","title":"Shape closing"},{"location":"compat/#old-keyframe-style","text":"Until v 5.0.0 (?). Keyframes had an e property that specified the end value for that keyframe ( s marking the start value), and the last keyframe would not have s . Fix: Ignore all the e in keyframes, but copy the e from the keyframe before last into the last keyframe. keyframes[keyframes.length - 1].s = keyframes[keyframes.length - 2].e","title":"Old keyframe style"},{"location":"compat/#static-text-layer-properties","text":"Until v 5.7.15. In Text Follow Path properties r , a , and p were plain numbers instead of animated properties. Fix: Wrap all of those into animated properties text_layer.t.p.a + {\"a\": 0, \"k\": text_layer.t.p.a}","title":"Static text layer properties"},{"location":"composition/","text":"Animation This is the top-level JSON object, describing the document, layers, assets, etc. The size of the canvas is determined by w and h . Duration is expressed in frames with op , and the framerate is in fr . Most of the contents are in layers and assets . Composition Diagram for Animation Animation Visual Object Composition Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions layers array of Layer Layers Layers v string Bodymovin version, on very old versions some things might be slightly different from what is explained here Bodymovin version, on very old versions some things might be slightly different from what is explained here ver integer Specification Version Specification version this Lottie is targeting. This is a 6 digit number with version components encoded as MMmmpp , with MM being major version, mm being minor and pp being patch. fr number Framerate Framerate in frames per second ip number In Point Frame the animation starts at (usually 0) op number Out Point Frame the animation stops/loops at, which makes this the duration in frames when ip is 0 w integer Width Width of the animation h integer Height Height of the animation ddd 0-1 integer Threedimensional Whether the animation has 3D layers assets array of Asset Assets List of assets that can be referenced by layers comps array of Precomposition Extra Compositions List of Extra compositions not referenced by anything fonts Font List Fonts Fonts chars array of Character Data Characters Data defining text characters as lottie shapes. If present a player might only render characters defined here and nothing else. meta Metadata Metadata Document metadata metadata User Metadata User Metadata User Metadata markers array of Marker Markers Markers defining named sections of the composition. mb Motion Blur Motion Blur Motion Blur slots object Slots Dictionary of slot ids that will replace matching properties. Composition An object that contains a list of layers Composition Diagram for Composition Composition Precomposition Animation Attribute Type Title Description layers array of Layer Layers Layers Metadata Some (but not all) lottie files will have a metadata object describing the program used to create the file and other useful information: Document Metadata Attribute Type Title Description a string Author Author d string Description Description tc string Theme Color Theme Color g string Generator Software used to generate the file User Metadata Attribute Type Title Description filename string Filename Filename customProps object Custom Properties Custom Properties Motion Blur Attribute Type Title Description sa number Shutter Angle Angle in degrees sp number Shutter Phase Angle in degrees spf number Samples per Frame Samples per Frame asl number Adaptive Sample Limit Adaptive Sample Limit","title":"Animation"},{"location":"composition/#animation","text":"This is the top-level JSON object, describing the document, layers, assets, etc. The size of the canvas is determined by w and h . Duration is expressed in frames with op , and the framerate is in fr . Most of the contents are in layers and assets . Composition Diagram for Animation Animation Visual Object Composition Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions layers array of Layer Layers Layers v string Bodymovin version, on very old versions some things might be slightly different from what is explained here Bodymovin version, on very old versions some things might be slightly different from what is explained here ver integer Specification Version Specification version this Lottie is targeting. This is a 6 digit number with version components encoded as MMmmpp , with MM being major version, mm being minor and pp being patch. fr number Framerate Framerate in frames per second ip number In Point Frame the animation starts at (usually 0) op number Out Point Frame the animation stops/loops at, which makes this the duration in frames when ip is 0 w integer Width Width of the animation h integer Height Height of the animation ddd 0-1 integer Threedimensional Whether the animation has 3D layers assets array of Asset Assets List of assets that can be referenced by layers comps array of Precomposition Extra Compositions List of Extra compositions not referenced by anything fonts Font List Fonts Fonts chars array of Character Data Characters Data defining text characters as lottie shapes. If present a player might only render characters defined here and nothing else. meta Metadata Metadata Document metadata metadata User Metadata User Metadata User Metadata markers array of Marker Markers Markers defining named sections of the composition. mb Motion Blur Motion Blur Motion Blur slots object Slots Dictionary of slot ids that will replace matching properties.","title":"Animation"},{"location":"composition/#composition","text":"An object that contains a list of layers Composition Diagram for Composition Composition Precomposition Animation Attribute Type Title Description layers array of Layer Layers Layers","title":"Composition"},{"location":"composition/#metadata","text":"Some (but not all) lottie files will have a metadata object describing the program used to create the file and other useful information:","title":"Metadata"},{"location":"composition/#document-metadata","text":"Attribute Type Title Description a string Author Author d string Description Description tc string Theme Color Theme Color g string Generator Software used to generate the file","title":"Document Metadata"},{"location":"composition/#user-metadata","text":"Attribute Type Title Description filename string Filename Filename customProps object Custom Properties Custom Properties","title":"User Metadata"},{"location":"composition/#motion-blur","text":"Attribute Type Title Description sa number Shutter Angle Angle in degrees sp number Shutter Phase Angle in degrees spf number Samples per Frame Samples per Frame asl number Adaptive Sample Limit Adaptive Sample Limit","title":"Motion Blur"},{"location":"constants/","text":"Enumerations Blend Mode Layer and shape blend mode Value Name 0 Normal 1 Multiply 2 Screen 3 Overlay 4 Darken 5 Lighten 6 Color Dodge 7 Color Burn 8 Hard Light 9 Soft Light 10 Difference 11 Exclusion 12 Hue 13 Saturation 14 Color 15 Luminosity 16 Add 17 Hard Mix In the following example you can change the blend mode of the top layer Example Opacity 50 Blend Mode Normal Multiply Screen Overlay Darken Lighten Color Dodge Color Burn Hard Light Soft Light Difference Exclusion Hue Saturation Color Luminosity Add Hard Mix var lottie_player_1 = new PlaygroundPlayer( 1, 'playground_1_3', 'lottie_target_1', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{429ff333-f31c-4124-91c5-5e861412a004}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 1, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{625eab7e-4758-4d4b-b37c-d89115b1442b}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 50}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Ellipse\", \"mn\": \"{dd57d763-ff3b-420f-a94d-eb5503e7faa7}\", \"it\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{fa5c495c-00d1-4253-b30c-cc8cb1b855b2}\", \"p\": {\"a\": 0, \"k\": [400.1910447761194, 240.71641791044777]}, \"s\": {\"a\": 0, \"k\": [195.15223880597017, 180.53731343283584]}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{89437b5f-dca9-42d4-aff9-c57ce08c8c1e}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{352559ca-ebe9-4b11-acdd-09e155612598}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [400.1910447761194, 240.71641791044777]}, \"p\": {\"a\": 0, \"k\": [400.1910447761194, 240.71641791044777]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{b6000853-a4d3-4b13-acdd-2e4f1a192760}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{d647a149-8105-4e08-b395-c8de40669fb0}\", \"p\": {\"a\": 0, \"k\": [110.90149253731343, 216.644776119403]}, \"or\": {\"a\": 0, \"k\": 121.5619125366211}, \"ir\": {\"a\": 0, \"k\": 60.78095626831055}, \"r\": {\"a\": 0, \"k\": 143.04905700683594}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{67a87e2b-afff-4f55-9004-4cc274cefe07}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{39b8d13c-45cf-4ad7-972a-ef5169f1ffbf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [110.90149253731343, 216.644776119403]}, \"p\": {\"a\": 0, \"k\": [159.9044776119403, 247.59402985074627]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}, {\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer 1\", \"mn\": \"{d74c9dcc-e7af-45c3-9eab-554c7b93f6b6}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Rectangle 1\", \"mn\": \"{b22ddad1-738b-471a-86eb-1f072fa45799}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle 1\", \"mn\": \"{0c09bd21-59ab-4f1e-bd3d-547613eb3e2a}\", \"p\": {\"a\": 0, \"k\": [241.57611940298506, 357.6358208955224]}, \"s\": {\"a\": 0, \"k\": [383.4268656716418, 211.4865671641791]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{8cd4fca9-3480-49fa-947f-04bc40ed74f5}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{050089d8-44c4-4312-8e23-3c89df7615aa}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.7686274509803922, 0.8509803921568627, 0.9607843137254902]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [241.57611940298506, 357.6358208955224]}, \"p\": {\"a\": 0, \"k\": [226.1014925373134, 131.53432835820894]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"Rectangle\", \"mn\": \"{700bfca8-0e45-42e9-8559-15ac0ebe93b2}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{0e3ac2ac-22c8-4310-8208-f5d5ba9cd6d9}\", \"p\": {\"a\": 0, \"k\": [277.68358208955226, 148.2985074626866]}, \"s\": {\"a\": 0, \"k\": [335.2835820895522, 162.48358208955224]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{af0c691f-7815-414e-a988-ac2eb6e32128}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{059d8c4e-de02-4fa7-99fe-c069b73218be}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [277.68358208955226, 148.2985074626866]}, \"p\": {\"a\": 0, \"k\": [277.68358208955226, 366.6626865671642]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { lottie.layers[0].bm = Number(data[\"Blend Mode\"]); lottie.layers[0].ks.o.k = data[\"Opacity\"]; this.json_viewer_contents = lottie.layers[0]; }, {} ); Composite How to stack copies in a repeater Value Name Description 1 Below Subsequent copies are added underneath the previous ones. 2 Above Subsequent copies are added on top of the previous ones. Fill Rule Rule used to handle multiple shapes rendered with the same fill object Value Name Description 1 Non Zero Everything is colored (You can think of this as an OR) 2 Even Odd Colored based on intersections and path direction, can be used to create \"holes\" Example Fill Rule Non Zero Even Odd var lottie_player_2 = new PlaygroundPlayer( 2, 'playground_2_2', 'lottie_target_2', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{f5d94f54-bb8f-4f07-be45-232ebd4b9eb1}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{4b0993ed-e35b-48a5-ab12-687dbc147c7c}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Path\", \"mn\": \"{29196ff2-0a65-48b4-a450-f9fbc3a3640d}\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Path\", \"mn\": \"{bb7e6c60-755e-4a21-a7ba-bd054feab5c7}\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [[125.51641791044776, 452.20298507462684], [240.71641791044777, 38.6865671641791], [435.8686567164179, 447.9044776119403], [42.125373134328356, 173.65970149253732], [460.8, 156.46567164179103]], \"i\": [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]], \"o\": [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]]}}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{3af40b83-15f6-4f69-aa2a-96acd03eb3b6}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.98, 0.28]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [251.46268656716418, 245.4447761194029]}, \"p\": {\"a\": 0, \"k\": [251.46268656716418, 245.4447761194029]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var shape = lottie.layers[0].shapes[0].it[1]; shape.r = Number(data[\"Fill Rule\"]); this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; }, {} ); Font Path Origin Value Name 0 Local 1 Css Url 2 Script Url 3 Font Url Gradient Type Whether a Gradient is a linear or radial. Value Name Description 1 Linear Colors transition in a single linear direction. 2 Radial Colors transition outward from a center point. Line Cap Style at the end of a stoked line Value Name 1 Butt 2 Round 3 Square Example Line Cap Butt Round Square var lottie_player_3 = new PlaygroundPlayer( 3, 'playground_3_2', 'lottie_target_3', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"tm\", \"nm\": \"Trim Path\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"s\": {\"a\": 0, \"k\": 0}, \"e\": {\"a\": 0, \"k\": 100}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.98, 0.28]}, \"lc\": 2, \"lj\": 2, \"ml\": 3, \"w\": {\"a\": 0, \"k\": 20}, \"d\": [{\"n\": \"o\", \"nm\": \"offset\", \"v\": {\"a\": 0, \"k\": 0}}, {\"n\": \"d\", \"nm\": \"dash\", \"v\": {\"a\": 0, \"k\": 100}}, {\"n\": \"g\", \"nm\": \"gap\", \"v\": {\"a\": 0, \"k\": 0}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var shape = lottie.layers[0].shapes[2]; shape.lc = Number(data[\"Line Cap\"]); shape.d = undefined; this.json_viewer_contents = lottie.layers[0].shapes[2]; }, {} ); Line Join Style at a sharp corner of a stoked line Value Name 1 Miter 2 Round 3 Bevel Example Line Join Miter Round Bevel Miter Limit 3 var lottie_player_4 = new PlaygroundPlayer( 4, 'playground_4_3', 'lottie_target_4', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"tm\", \"nm\": \"Trim Path\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"s\": {\"a\": 0, \"k\": 0}, \"e\": {\"a\": 0, \"k\": 100}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.98, 0.28]}, \"lc\": 2, \"lj\": 2, \"ml\": 3, \"w\": {\"a\": 0, \"k\": 20}, \"d\": [{\"n\": \"o\", \"nm\": \"offset\", \"v\": {\"a\": 0, \"k\": 0}}, {\"n\": \"d\", \"nm\": \"dash\", \"v\": {\"a\": 0, \"k\": 100}}, {\"n\": \"g\", \"nm\": \"gap\", \"v\": {\"a\": 0, \"k\": 0}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var shape = lottie.layers[0].shapes[2]; shape.lj = Number(data[\"Line Join\"]); shape.ml = data[\"Miter Limit\"]; shape.d = undefined; var trim = lottie.layers[0].shapes[1]; trim.e.k = 100; this.json_viewer_contents = lottie.layers[0].shapes[2]; }, {} ); Mask Mode Describes how a mask interacts (blends) with the preceding masks in the stack. Value Name Description 'n' None The mask is ignored. 'a' Add Mask coverage is added (Normal blending). 's' Subtract Mask coverage is subtracted (Subtract blending). 'i' Intersect Mask coverage is intersected (Source-In blending). 'l' Lighten 'd' Darken 'f' Difference Example Mask Mode None Add Subtract Intersect Lighten Darken Difference Mask1 Opacity 100 Mask2 Opacity 100 var lottie_player_5 = new PlaygroundPlayer( 5, 'playground_5_4', 'lottie_target_5', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{b3d1b083-9de7-4537-a691-fc9aa42f9742}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 2, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Shapes\", \"ks\": {}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{528994b7-40ff-4d12-81f8-603f274da12e}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{ce8756d7-289f-4f84-a135-d225d57c42e0}\", \"p\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"or\": {\"a\": 0, \"k\": 216.4160919189453}, \"ir\": {\"a\": 0, \"k\": 87.03440856933594}, \"r\": {\"a\": 0, \"k\": 261.54803466796875}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{efd05a25-a43b-451d-83d2-53a477087223}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{523ca39c-9e57-4547-bf0e-ba7496003579}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"p\": {\"a\": 0, \"k\": [338.7223880597015, 209.76716417910447]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"Rectangle\", \"mn\": \"{d2d7a5d5-6d91-42e8-b40a-af52a112fe38}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{9ef8604e-7891-4909-a655-445131b4d842}\", \"p\": {\"a\": 0, \"k\": [209.17611940298502, 226.8]}, \"s\": {\"a\": 0, \"k\": [363.3313432835821, 369.3492537313433]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{444584d2-cb59-4cba-83a1-82cc605837fd}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{f75aed67-9b0e-41a9-b859-a14b5b0a320d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.7686274509803922, 0.8509803921568627, 0.9607843137254902]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"p\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}], \"hasMask\": true, \"masksProperties\": [{\"mode\": \"a\", \"o\": {\"a\": 0, \"k\": 100}, \"inv\": false, \"x\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [[247.109, 125.719], [66.109, 306.719], [424.109, 389.719]], \"i\": [[0, 0], [0, 0], [0, 0]], \"o\": [[0, 0], [0, 0], [0, 0]]}}}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let mask1 = lottie.layers[1].masksProperties[0]; let mask2 = lottie.layers[1].masksProperties[1]; mask1.o.k = Number(data[\"Mask1 Opacity\"]); mask2.o.k = Number(data[\"Mask2 Opacity\"]); mask2.mode = data[\"Mask Mode\"]; this.json_viewer_contents = lottie.layers[1].masksProperties[1]; }, {} ); Matte Mode How a layer should mask another layer Value Name Description 0 Normal The layer is not used as a track matte 1 Alpha The masked layer opacity is modulated by the track matte layer opacity 2 Inverted Alpha The masked layer opacity is modulated by the inverted track matte layer opacity 3 Luma The masked layer opacity is modulated by the track matte layer luminance 4 Inverted Luma The masked layer opacity is modulated by the inverted track matte layer luminance Example Matte Mode Normal Alpha Inverted Alpha Luma Inverted Luma var lottie_player_6 = new PlaygroundPlayer( 6, 'playground_6_2', 'lottie_target_6', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{b3d1b083-9de7-4537-a691-fc9aa42f9742}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 1, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Ellipse (Mask)\", \"ks\": {\"a\": {\"a\": 0, \"k\": [153, 294]}, \"p\": {\"a\": 0, \"k\": [346, 211]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{261eddeb-af92-4be1-932c-790b00c23933}\", \"p\": {\"a\": 0, \"k\": [137.0955223880597, 293.60820895522386]}, \"s\": {\"a\": 0, \"k\": [303.42089552238804, 315.55074626865667]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{aa9c282c-253d-4d8d-ab05-4819c592fa85}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{2b2b0002-ff0c-4978-a33b-db4e0498848d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}], \"td\": 1}, {\"ddd\": 0, \"ty\": 4, \"ind\": 2, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Shapes (Masked)\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{528994b7-40ff-4d12-81f8-603f274da12e}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{ce8756d7-289f-4f84-a135-d225d57c42e0}\", \"p\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"or\": {\"a\": 0, \"k\": 216.4160919189453}, \"ir\": {\"a\": 0, \"k\": 87.03440856933594}, \"r\": {\"a\": 0, \"k\": 261.54803466796875}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{efd05a25-a43b-451d-83d2-53a477087223}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{523ca39c-9e57-4547-bf0e-ba7496003579}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"p\": {\"a\": 0, \"k\": [338.7223880597015, 209.76716417910447]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"Rectangle\", \"mn\": \"{d2d7a5d5-6d91-42e8-b40a-af52a112fe38}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{9ef8604e-7891-4909-a655-445131b4d842}\", \"p\": {\"a\": 0, \"k\": [209.17611940298502, 226.8]}, \"s\": {\"a\": 0, \"k\": [363.3313432835821, 369.3492537313433]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{444584d2-cb59-4cba-83a1-82cc605837fd}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{f75aed67-9b0e-41a9-b859-a14b5b0a320d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.7686274509803922, 0.8509803921568627, 0.9607843137254902]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"p\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}], \"tt\": 1, \"tp\": 1}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[1].tt = Number(data[\"Matte Mode\"]); this.json_viewer_contents = {...lottie.layers[1], shapes: [], ks: {}}; }, {} ); Merge Mode Boolean operation on shapes Value Name 1 Normal 2 Add 3 Subtract 4 Intersect 5 Exclude Intersections Shape Direction Drawing direction of the shape curve, useful for trim path Value Name Description 1 Normal Usually clockwise 3 Reversed Usually counter clockwise Shape Direction Normal Reversed var lottie_player_7 = new PlaygroundPlayer( 7, 'playground_7_2', 'lottie_target_7', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [128, 128]}, \"or\": {\"a\": 0, \"k\": 100}, \"ir\": {\"a\": 0, \"k\": 50}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{74587b40-1ef1-445d-b9ab-02b8a42a96aa}\", \"p\": {\"a\": 0, \"k\": [384, 128]}, \"s\": {\"a\": 0, \"k\": [200, 200]}}, {\"ty\": \"rc\", \"nm\": \"Rect\", \"mn\": \"{0776f2df-2619-415c-b10d-f648f2edfa0f}\", \"d\": 1, \"p\": {\"a\": 0, \"k\": [128, 384]}, \"s\": {\"a\": 0, \"k\": [200, 200]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"sr\", \"nm\": \"Triangle\", \"mn\": \"{db373594-d0ae-44ff-9295-30ff72616af2}\", \"p\": {\"a\": 0, \"k\": [384, 384]}, \"or\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 3}, \"sy\": 2, \"os\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"tm\", \"nm\": \"Trim Path\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"s\": {\"a\": 0, \"k\": 0}, \"e\": {\"a\": 0, \"k\": 50}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 20}}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { for ( let shape of lottie.layers[0].shapes ) shape.d = Number(data[\"Shape Direction\"]); this.json_viewer_contents = lottie.layers[0].shapes[1]; }, {} ); Star Type Whether a PolyStar is a star or a polygon Value Name 1 Star 2 Polygon Example Star Type Star Polygon var lottie_player_8 = new PlaygroundPlayer( 8, 'playground_8_2', 'lottie_target_8', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [{\"ty\": 4, \"ddd\": 0, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ip\": 0, \"op\": 180, \"ind\": 0, \"st\": 0, \"sr\": 1, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.979995422293431, 0.28000305180437934]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var star = lottie.layers[0].shapes[0].it[0]; star.sy = Number(data[\"Star Type\"]); if ( data[\"Star Type\"] == \"1\" ) { star[\"ir\"] = {\"a\": 0, \"k\": 100}; star[\"is\"] = {\"a\": 0, \"k\": 0}; } else { delete star[\"ir\"]; delete star[\"is\"]; } lottie.layers[0].shapes[0].it[0] = star; this.json_viewer_contents = lottie.layers[0].shapes[0].it[0]; }, {} ); Stroke Dash Type Type of a dash item in a stroked line Value Name 'd' Dash 'g' Gap 'o' Offset Text Based Value Name 1 Characters 2 Character Excluding Spaces 3 Words 4 Lines Text Grouping Value Name 1 Characters 2 Word 3 Line 4 All Text Justify Text alignment / justification Value Name 0 Left 1 Right 2 Center 3 Justify with Last Line Left 4 Justify with Last Line Right 5 Justify with Last Line Center 6 Justify with Last Line Full Text Shape Defines the function used to determine the interpolating factor on a text range selector. Value Name 1 Square 2 Ramp Up 3 Ramp Down 4 Triangle 5 Round 6 Smooth To better illustrate what the value mean, the graphics below shows an example for each value, including the function itself, based on the range start and end character. Trim Multiple Shapes How to handle multiple shapes in trim path Value Name Description 1 Parallel All shapes apply the trim at the same time 2 Sequential Shapes are considered as a continuous sequence Multiple Shapes Parallel Sequential var lottie_player_9 = new PlaygroundPlayer( 9, 'playground_9_2', 'lottie_target_9', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [128, 128]}, \"or\": {\"a\": 0, \"k\": 100}, \"ir\": {\"a\": 0, \"k\": 50}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{74587b40-1ef1-445d-b9ab-02b8a42a96aa}\", \"p\": {\"a\": 0, \"k\": [384, 128]}, \"s\": {\"a\": 0, \"k\": [200, 200]}}, {\"ty\": \"rc\", \"nm\": \"Rect\", \"mn\": \"{0776f2df-2619-415c-b10d-f648f2edfa0f}\", \"d\": 1, \"p\": {\"a\": 0, \"k\": [128, 384]}, \"s\": {\"a\": 0, \"k\": [200, 200]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"sr\", \"nm\": \"Triangle\", \"mn\": \"{db373594-d0ae-44ff-9295-30ff72616af2}\", \"p\": {\"a\": 0, \"k\": [384, 384]}, \"or\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 3}, \"sy\": 2, \"os\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"tm\", \"nm\": \"Trim Path\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"s\": {\"a\": 0, \"k\": 0}, \"e\": {\"a\": 0, \"k\": 50}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 20}}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { lottie.layers[0].shapes[4].m = Number(data[\"Multiple Shapes\"]); this.json_viewer_contents = lottie.layers[0].shapes[4]; }, {} ); Text Caps Value Name 0 Regular 1 All Caps 2 Small Caps Text Range Units Unit type for a text selector Value Name 1 Percent 2 Index","title":"Enumerations"},{"location":"constants/#enumerations","text":"","title":"Enumerations"},{"location":"constants/#blend-mode","text":"Layer and shape blend mode Value Name 0 Normal 1 Multiply 2 Screen 3 Overlay 4 Darken 5 Lighten 6 Color Dodge 7 Color Burn 8 Hard Light 9 Soft Light 10 Difference 11 Exclusion 12 Hue 13 Saturation 14 Color 15 Luminosity 16 Add 17 Hard Mix In the following example you can change the blend mode of the top layer Example Opacity 50 Blend Mode Normal Multiply Screen Overlay Darken Lighten Color Dodge Color Burn Hard Light Soft Light Difference Exclusion Hue Saturation Color Luminosity Add Hard Mix var lottie_player_1 = new PlaygroundPlayer( 1, 'playground_1_3', 'lottie_target_1', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{429ff333-f31c-4124-91c5-5e861412a004}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 1, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{625eab7e-4758-4d4b-b37c-d89115b1442b}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 50}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Ellipse\", \"mn\": \"{dd57d763-ff3b-420f-a94d-eb5503e7faa7}\", \"it\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{fa5c495c-00d1-4253-b30c-cc8cb1b855b2}\", \"p\": {\"a\": 0, \"k\": [400.1910447761194, 240.71641791044777]}, \"s\": {\"a\": 0, \"k\": [195.15223880597017, 180.53731343283584]}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{89437b5f-dca9-42d4-aff9-c57ce08c8c1e}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{352559ca-ebe9-4b11-acdd-09e155612598}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [400.1910447761194, 240.71641791044777]}, \"p\": {\"a\": 0, \"k\": [400.1910447761194, 240.71641791044777]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{b6000853-a4d3-4b13-acdd-2e4f1a192760}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{d647a149-8105-4e08-b395-c8de40669fb0}\", \"p\": {\"a\": 0, \"k\": [110.90149253731343, 216.644776119403]}, \"or\": {\"a\": 0, \"k\": 121.5619125366211}, \"ir\": {\"a\": 0, \"k\": 60.78095626831055}, \"r\": {\"a\": 0, \"k\": 143.04905700683594}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{67a87e2b-afff-4f55-9004-4cc274cefe07}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{39b8d13c-45cf-4ad7-972a-ef5169f1ffbf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [110.90149253731343, 216.644776119403]}, \"p\": {\"a\": 0, \"k\": [159.9044776119403, 247.59402985074627]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}, {\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer 1\", \"mn\": \"{d74c9dcc-e7af-45c3-9eab-554c7b93f6b6}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Rectangle 1\", \"mn\": \"{b22ddad1-738b-471a-86eb-1f072fa45799}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle 1\", \"mn\": \"{0c09bd21-59ab-4f1e-bd3d-547613eb3e2a}\", \"p\": {\"a\": 0, \"k\": [241.57611940298506, 357.6358208955224]}, \"s\": {\"a\": 0, \"k\": [383.4268656716418, 211.4865671641791]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{8cd4fca9-3480-49fa-947f-04bc40ed74f5}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{050089d8-44c4-4312-8e23-3c89df7615aa}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.7686274509803922, 0.8509803921568627, 0.9607843137254902]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [241.57611940298506, 357.6358208955224]}, \"p\": {\"a\": 0, \"k\": [226.1014925373134, 131.53432835820894]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"Rectangle\", \"mn\": \"{700bfca8-0e45-42e9-8559-15ac0ebe93b2}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{0e3ac2ac-22c8-4310-8208-f5d5ba9cd6d9}\", \"p\": {\"a\": 0, \"k\": [277.68358208955226, 148.2985074626866]}, \"s\": {\"a\": 0, \"k\": [335.2835820895522, 162.48358208955224]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{af0c691f-7815-414e-a988-ac2eb6e32128}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{059d8c4e-de02-4fa7-99fe-c069b73218be}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [277.68358208955226, 148.2985074626866]}, \"p\": {\"a\": 0, \"k\": [277.68358208955226, 366.6626865671642]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { lottie.layers[0].bm = Number(data[\"Blend Mode\"]); lottie.layers[0].ks.o.k = data[\"Opacity\"]; this.json_viewer_contents = lottie.layers[0]; }, {} );","title":"Blend Mode"},{"location":"constants/#composite","text":"How to stack copies in a repeater Value Name Description 1 Below Subsequent copies are added underneath the previous ones. 2 Above Subsequent copies are added on top of the previous ones.","title":"Composite"},{"location":"constants/#fill-rule","text":"Rule used to handle multiple shapes rendered with the same fill object Value Name Description 1 Non Zero Everything is colored (You can think of this as an OR) 2 Even Odd Colored based on intersections and path direction, can be used to create \"holes\" Example Fill Rule Non Zero Even Odd var lottie_player_2 = new PlaygroundPlayer( 2, 'playground_2_2', 'lottie_target_2', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{f5d94f54-bb8f-4f07-be45-232ebd4b9eb1}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{4b0993ed-e35b-48a5-ab12-687dbc147c7c}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Path\", \"mn\": \"{29196ff2-0a65-48b4-a450-f9fbc3a3640d}\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Path\", \"mn\": \"{bb7e6c60-755e-4a21-a7ba-bd054feab5c7}\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [[125.51641791044776, 452.20298507462684], [240.71641791044777, 38.6865671641791], [435.8686567164179, 447.9044776119403], [42.125373134328356, 173.65970149253732], [460.8, 156.46567164179103]], \"i\": [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]], \"o\": [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]]}}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{3af40b83-15f6-4f69-aa2a-96acd03eb3b6}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.98, 0.28]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [251.46268656716418, 245.4447761194029]}, \"p\": {\"a\": 0, \"k\": [251.46268656716418, 245.4447761194029]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var shape = lottie.layers[0].shapes[0].it[1]; shape.r = Number(data[\"Fill Rule\"]); this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; }, {} );","title":"Fill Rule"},{"location":"constants/#font-path-origin","text":"Value Name 0 Local 1 Css Url 2 Script Url 3 Font Url","title":"Font Path Origin"},{"location":"constants/#gradient-type","text":"Whether a Gradient is a linear or radial. Value Name Description 1 Linear Colors transition in a single linear direction. 2 Radial Colors transition outward from a center point.","title":"Gradient Type"},{"location":"constants/#line-cap","text":"Style at the end of a stoked line Value Name 1 Butt 2 Round 3 Square Example Line Cap Butt Round Square var lottie_player_3 = new PlaygroundPlayer( 3, 'playground_3_2', 'lottie_target_3', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"tm\", \"nm\": \"Trim Path\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"s\": {\"a\": 0, \"k\": 0}, \"e\": {\"a\": 0, \"k\": 100}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.98, 0.28]}, \"lc\": 2, \"lj\": 2, \"ml\": 3, \"w\": {\"a\": 0, \"k\": 20}, \"d\": [{\"n\": \"o\", \"nm\": \"offset\", \"v\": {\"a\": 0, \"k\": 0}}, {\"n\": \"d\", \"nm\": \"dash\", \"v\": {\"a\": 0, \"k\": 100}}, {\"n\": \"g\", \"nm\": \"gap\", \"v\": {\"a\": 0, \"k\": 0}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var shape = lottie.layers[0].shapes[2]; shape.lc = Number(data[\"Line Cap\"]); shape.d = undefined; this.json_viewer_contents = lottie.layers[0].shapes[2]; }, {} );","title":"Line Cap"},{"location":"constants/#line-join","text":"Style at a sharp corner of a stoked line Value Name 1 Miter 2 Round 3 Bevel Example Line Join Miter Round Bevel Miter Limit 3 var lottie_player_4 = new PlaygroundPlayer( 4, 'playground_4_3', 'lottie_target_4', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"tm\", \"nm\": \"Trim Path\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"s\": {\"a\": 0, \"k\": 0}, \"e\": {\"a\": 0, \"k\": 100}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.98, 0.28]}, \"lc\": 2, \"lj\": 2, \"ml\": 3, \"w\": {\"a\": 0, \"k\": 20}, \"d\": [{\"n\": \"o\", \"nm\": \"offset\", \"v\": {\"a\": 0, \"k\": 0}}, {\"n\": \"d\", \"nm\": \"dash\", \"v\": {\"a\": 0, \"k\": 100}}, {\"n\": \"g\", \"nm\": \"gap\", \"v\": {\"a\": 0, \"k\": 0}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var shape = lottie.layers[0].shapes[2]; shape.lj = Number(data[\"Line Join\"]); shape.ml = data[\"Miter Limit\"]; shape.d = undefined; var trim = lottie.layers[0].shapes[1]; trim.e.k = 100; this.json_viewer_contents = lottie.layers[0].shapes[2]; }, {} );","title":"Line Join"},{"location":"constants/#mask-mode","text":"Describes how a mask interacts (blends) with the preceding masks in the stack. Value Name Description 'n' None The mask is ignored. 'a' Add Mask coverage is added (Normal blending). 's' Subtract Mask coverage is subtracted (Subtract blending). 'i' Intersect Mask coverage is intersected (Source-In blending). 'l' Lighten 'd' Darken 'f' Difference Example Mask Mode None Add Subtract Intersect Lighten Darken Difference Mask1 Opacity 100 Mask2 Opacity 100 var lottie_player_5 = new PlaygroundPlayer( 5, 'playground_5_4', 'lottie_target_5', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{b3d1b083-9de7-4537-a691-fc9aa42f9742}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 2, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Shapes\", \"ks\": {}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{528994b7-40ff-4d12-81f8-603f274da12e}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{ce8756d7-289f-4f84-a135-d225d57c42e0}\", \"p\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"or\": {\"a\": 0, \"k\": 216.4160919189453}, \"ir\": {\"a\": 0, \"k\": 87.03440856933594}, \"r\": {\"a\": 0, \"k\": 261.54803466796875}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{efd05a25-a43b-451d-83d2-53a477087223}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{523ca39c-9e57-4547-bf0e-ba7496003579}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"p\": {\"a\": 0, \"k\": [338.7223880597015, 209.76716417910447]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"Rectangle\", \"mn\": \"{d2d7a5d5-6d91-42e8-b40a-af52a112fe38}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{9ef8604e-7891-4909-a655-445131b4d842}\", \"p\": {\"a\": 0, \"k\": [209.17611940298502, 226.8]}, \"s\": {\"a\": 0, \"k\": [363.3313432835821, 369.3492537313433]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{444584d2-cb59-4cba-83a1-82cc605837fd}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{f75aed67-9b0e-41a9-b859-a14b5b0a320d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.7686274509803922, 0.8509803921568627, 0.9607843137254902]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"p\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}], \"hasMask\": true, \"masksProperties\": [{\"mode\": \"a\", \"o\": {\"a\": 0, \"k\": 100}, \"inv\": false, \"x\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [[247.109, 125.719], [66.109, 306.719], [424.109, 389.719]], \"i\": [[0, 0], [0, 0], [0, 0]], \"o\": [[0, 0], [0, 0], [0, 0]]}}}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let mask1 = lottie.layers[1].masksProperties[0]; let mask2 = lottie.layers[1].masksProperties[1]; mask1.o.k = Number(data[\"Mask1 Opacity\"]); mask2.o.k = Number(data[\"Mask2 Opacity\"]); mask2.mode = data[\"Mask Mode\"]; this.json_viewer_contents = lottie.layers[1].masksProperties[1]; }, {} );","title":"Mask Mode"},{"location":"constants/#matte-mode","text":"How a layer should mask another layer Value Name Description 0 Normal The layer is not used as a track matte 1 Alpha The masked layer opacity is modulated by the track matte layer opacity 2 Inverted Alpha The masked layer opacity is modulated by the inverted track matte layer opacity 3 Luma The masked layer opacity is modulated by the track matte layer luminance 4 Inverted Luma The masked layer opacity is modulated by the inverted track matte layer luminance Example Matte Mode Normal Alpha Inverted Alpha Luma Inverted Luma var lottie_player_6 = new PlaygroundPlayer( 6, 'playground_6_2', 'lottie_target_6', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{b3d1b083-9de7-4537-a691-fc9aa42f9742}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 1, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Ellipse (Mask)\", \"ks\": {\"a\": {\"a\": 0, \"k\": [153, 294]}, \"p\": {\"a\": 0, \"k\": [346, 211]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{261eddeb-af92-4be1-932c-790b00c23933}\", \"p\": {\"a\": 0, \"k\": [137.0955223880597, 293.60820895522386]}, \"s\": {\"a\": 0, \"k\": [303.42089552238804, 315.55074626865667]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{aa9c282c-253d-4d8d-ab05-4819c592fa85}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{2b2b0002-ff0c-4978-a33b-db4e0498848d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}], \"td\": 1}, {\"ddd\": 0, \"ty\": 4, \"ind\": 2, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Shapes (Masked)\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{528994b7-40ff-4d12-81f8-603f274da12e}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{ce8756d7-289f-4f84-a135-d225d57c42e0}\", \"p\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"or\": {\"a\": 0, \"k\": 216.4160919189453}, \"ir\": {\"a\": 0, \"k\": 87.03440856933594}, \"r\": {\"a\": 0, \"k\": 261.54803466796875}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{efd05a25-a43b-451d-83d2-53a477087223}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{523ca39c-9e57-4547-bf0e-ba7496003579}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"p\": {\"a\": 0, \"k\": [338.7223880597015, 209.76716417910447]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"Rectangle\", \"mn\": \"{d2d7a5d5-6d91-42e8-b40a-af52a112fe38}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{9ef8604e-7891-4909-a655-445131b4d842}\", \"p\": {\"a\": 0, \"k\": [209.17611940298502, 226.8]}, \"s\": {\"a\": 0, \"k\": [363.3313432835821, 369.3492537313433]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{444584d2-cb59-4cba-83a1-82cc605837fd}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{f75aed67-9b0e-41a9-b859-a14b5b0a320d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.7686274509803922, 0.8509803921568627, 0.9607843137254902]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"p\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}], \"tt\": 1, \"tp\": 1}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[1].tt = Number(data[\"Matte Mode\"]); this.json_viewer_contents = {...lottie.layers[1], shapes: [], ks: {}}; }, {} );","title":"Matte Mode"},{"location":"constants/#merge-mode","text":"Boolean operation on shapes Value Name 1 Normal 2 Add 3 Subtract 4 Intersect 5 Exclude Intersections","title":"Merge Mode"},{"location":"constants/#shape-direction","text":"Drawing direction of the shape curve, useful for trim path Value Name Description 1 Normal Usually clockwise 3 Reversed Usually counter clockwise Shape Direction Normal Reversed var lottie_player_7 = new PlaygroundPlayer( 7, 'playground_7_2', 'lottie_target_7', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [128, 128]}, \"or\": {\"a\": 0, \"k\": 100}, \"ir\": {\"a\": 0, \"k\": 50}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{74587b40-1ef1-445d-b9ab-02b8a42a96aa}\", \"p\": {\"a\": 0, \"k\": [384, 128]}, \"s\": {\"a\": 0, \"k\": [200, 200]}}, {\"ty\": \"rc\", \"nm\": \"Rect\", \"mn\": \"{0776f2df-2619-415c-b10d-f648f2edfa0f}\", \"d\": 1, \"p\": {\"a\": 0, \"k\": [128, 384]}, \"s\": {\"a\": 0, \"k\": [200, 200]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"sr\", \"nm\": \"Triangle\", \"mn\": \"{db373594-d0ae-44ff-9295-30ff72616af2}\", \"p\": {\"a\": 0, \"k\": [384, 384]}, \"or\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 3}, \"sy\": 2, \"os\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"tm\", \"nm\": \"Trim Path\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"s\": {\"a\": 0, \"k\": 0}, \"e\": {\"a\": 0, \"k\": 50}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 20}}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { for ( let shape of lottie.layers[0].shapes ) shape.d = Number(data[\"Shape Direction\"]); this.json_viewer_contents = lottie.layers[0].shapes[1]; }, {} );","title":"Shape Direction"},{"location":"constants/#star-type","text":"Whether a PolyStar is a star or a polygon Value Name 1 Star 2 Polygon Example Star Type Star Polygon var lottie_player_8 = new PlaygroundPlayer( 8, 'playground_8_2', 'lottie_target_8', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [{\"ty\": 4, \"ddd\": 0, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ip\": 0, \"op\": 180, \"ind\": 0, \"st\": 0, \"sr\": 1, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.979995422293431, 0.28000305180437934]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var star = lottie.layers[0].shapes[0].it[0]; star.sy = Number(data[\"Star Type\"]); if ( data[\"Star Type\"] == \"1\" ) { star[\"ir\"] = {\"a\": 0, \"k\": 100}; star[\"is\"] = {\"a\": 0, \"k\": 0}; } else { delete star[\"ir\"]; delete star[\"is\"]; } lottie.layers[0].shapes[0].it[0] = star; this.json_viewer_contents = lottie.layers[0].shapes[0].it[0]; }, {} );","title":"Star Type"},{"location":"constants/#stroke-dash-type","text":"Type of a dash item in a stroked line Value Name 'd' Dash 'g' Gap 'o' Offset","title":"Stroke Dash Type"},{"location":"constants/#text-based","text":"Value Name 1 Characters 2 Character Excluding Spaces 3 Words 4 Lines","title":"Text Based"},{"location":"constants/#text-grouping","text":"Value Name 1 Characters 2 Word 3 Line 4 All","title":"Text Grouping"},{"location":"constants/#text-justify","text":"Text alignment / justification Value Name 0 Left 1 Right 2 Center 3 Justify with Last Line Left 4 Justify with Last Line Right 5 Justify with Last Line Center 6 Justify with Last Line Full","title":"Text Justify"},{"location":"constants/#text-shape","text":"Defines the function used to determine the interpolating factor on a text range selector. Value Name 1 Square 2 Ramp Up 3 Ramp Down 4 Triangle 5 Round 6 Smooth To better illustrate what the value mean, the graphics below shows an example for each value, including the function itself, based on the range start and end character.","title":"Text Shape"},{"location":"constants/#trim-multiple-shapes","text":"How to handle multiple shapes in trim path Value Name Description 1 Parallel All shapes apply the trim at the same time 2 Sequential Shapes are considered as a continuous sequence Multiple Shapes Parallel Sequential var lottie_player_9 = new PlaygroundPlayer( 9, 'playground_9_2', 'lottie_target_9', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [128, 128]}, \"or\": {\"a\": 0, \"k\": 100}, \"ir\": {\"a\": 0, \"k\": 50}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{74587b40-1ef1-445d-b9ab-02b8a42a96aa}\", \"p\": {\"a\": 0, \"k\": [384, 128]}, \"s\": {\"a\": 0, \"k\": [200, 200]}}, {\"ty\": \"rc\", \"nm\": \"Rect\", \"mn\": \"{0776f2df-2619-415c-b10d-f648f2edfa0f}\", \"d\": 1, \"p\": {\"a\": 0, \"k\": [128, 384]}, \"s\": {\"a\": 0, \"k\": [200, 200]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"sr\", \"nm\": \"Triangle\", \"mn\": \"{db373594-d0ae-44ff-9295-30ff72616af2}\", \"p\": {\"a\": 0, \"k\": [384, 384]}, \"or\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 3}, \"sy\": 2, \"os\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"tm\", \"nm\": \"Trim Path\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"s\": {\"a\": 0, \"k\": 0}, \"e\": {\"a\": 0, \"k\": 50}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 20}}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { lottie.layers[0].shapes[4].m = Number(data[\"Multiple Shapes\"]); this.json_viewer_contents = lottie.layers[0].shapes[4]; }, {} );","title":"Trim Multiple Shapes"},{"location":"constants/#text-caps","text":"Value Name 0 Regular 1 All Caps 2 Small Caps","title":"Text Caps"},{"location":"constants/#text-range-units","text":"Unit type for a text selector Value Name 1 Percent 2 Index","title":"Text Range Units"},{"location":"effects/","text":"Layer Effects Layers can have post-processing effects applied to them. Effects Composition Diagram for Effect Effect Visual Object Spherize Effect Puppet Effect Tritone Effect Displacement Map Effect Wavy Effect Gaussian Blur Effect Pro Levels Effect Tint Effect Mesh Warp Effect Set Matte Effect Fill Effect Drop Shadow Effect Radial Wipe Stroke Effect Twirl Effect Custom Effect Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array of Effect No Value or Effect Value Angle or Effect Value Checkbox or Effect Value Color or Effect Value Drop Down or Ignored Value or Effect Value Layer or Effect Value Point or Effect Value Slider Effect Values Effect Values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer Type Effect type en 0-1 integer Enabled Enabled Many effects have unused values which are labeled with a number. Effect types: ty Type 5 Custom Effect 27 Displacement Map Effect 25 Drop Shadow Effect None Effect 21 Fill Effect 29 Gaussian Blur Effect 28 Set Matte Effect 31 Mesh Warp Effect 24 Pro Levels Effect 34 Puppet Effect 26 Radial Wipe 33 Spherize Effect 22 Stroke Effect 20 Tint Effect 23 Tritone Effect 30 Twirl Effect 32 Wavy Effect All the examples will use this as their base: var lottie_player_10 = new LottiePlayer( 'lottie_target_10', '../static/examples/image.json', true, {} ); Fill Effect Fill all opaque areas with a solid color Composition Diagram for Fill Effect Fill Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 21 Type Type en 0-1 integer Enabled Enabled Name Type 10 Effect Value Layer 01 Effect Value Drop Down color Effect Value Color 03 Effect Value Drop Down 04 Effect Value Slider 05 Effect Value Slider opacity Effect Value Slider Opacity Color 1 Red 1 Green 0.9 Blue 0 var lottie_player_11 = new PlaygroundPlayer( 11, 'playground_11_5', 'lottie_target_11', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 21, \"ef\": [{\"ty\": 3, \"v\": {\"k\": [0, 0], \"a\": 0}}, {\"ty\": 7, \"v\": {\"k\": 0, \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [1, 0.9, 0, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}, {\"ty\": 7, \"v\": {\"k\": 0, \"a\": 0}}, {\"ty\": 0, \"v\": {\"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"a\": 0, \"k\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[6].v.k = data[\"Opacity\"]; lottie.layers[0].ef[0].ef[2].v.k[0] = data[\"Red\"]; lottie.layers[0].ef[0].ef[2].v.k[1] = data[\"Green\"]; lottie.layers[0].ef[0].ef[2].v.k[2] = data[\"Blue\"]; this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} ); Stroke Effect Composition Diagram for Stroke Effect Stroke Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 22 Type Type en 0-1 integer Enabled Enabled Name Type 00 Effect Value Color 01 Effect Value Checkbox 02 Effect Value Checkbox color Effect Value Color 04 Effect Value Slider 05 Effect Value Slider 06 Effect Value Slider 07 Effect Value Slider 08 Effect Value Slider 09 Effect Value Drop Down type Effect Value Drop Down Tritone Effect Converts the layer to greyscale, then applies the gradient based on bright/mid/dark. Composition Diagram for Tritone Effect Tritone Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 23 Type Type en 0-1 integer Enabled Enabled Name Type bright Effect Value Color mid Effect Value Color dark Effect Value Color Red 1 Green 1 Blue Mid 1 Red 0.3 Green 0.8 Blue Dark 0.3 Red 0 Green 0 Blue 0 var lottie_player_12 = new PlaygroundPlayer( 12, 'playground_12_10', 'lottie_target_12', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 23, \"ef\": [{\"ty\": 2, \"v\": {\"k\": [1, 1, 1, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0.3, 0.8, 0.3, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[0].v.k[0] = data[\"r1\"]; lottie.layers[0].ef[0].ef[0].v.k[1] = data[\"g1\"]; lottie.layers[0].ef[0].ef[0].v.k[2] = data[\"b1\"]; lottie.layers[0].ef[0].ef[1].v.k[0] = data[\"r2\"]; lottie.layers[0].ef[0].ef[1].v.k[1] = data[\"g2\"]; lottie.layers[0].ef[0].ef[1].v.k[2] = data[\"b2\"]; lottie.layers[0].ef[0].ef[2].v.k[0] = data[\"r3\"]; lottie.layers[0].ef[0].ef[2].v.k[1] = data[\"g3\"]; lottie.layers[0].ef[0].ef[2].v.k[2] = data[\"b3\"]; this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} ); Pro Levels Effect Color correction levels. For more information refer to the After Effects Documentation . Composition Diagram for Pro Levels Effect Pro Levels Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 24 Type Type en 0-1 integer Enabled Enabled Name Type 00 Effect Value Drop Down 01 Effect No Value 02 Effect No Value comp_inblack Effect Value Slider comp_inwhite Effect Value Slider comp_gamma Effect Value Slider comp_outblack Effect Value Slider comp_outwhite Effect No Value 08 Effect No Value 09 Effect Value Slider r_inblack Effect Value Slider r_inwhite Effect Value Slider r_gamma Effect Value Slider r_outblack Effect Value Slider r_outwhite Effect Value Slider 15 Effect Value Slider 16 Effect Value Slider g_inblack Effect Value Slider g_inwhite Effect Value Slider g_gamma Effect Value Slider g_outblack Effect Value Slider g_outwhite Effect Value Slider 22 Effect Value Slider 23 Effect Value Slider b_inblack Effect Value Slider b_inwhite Effect Value Slider b_gamma Effect Value Slider b_outblack Effect Value Slider b_outwhite Effect Value Slider 29 Effect Value Slider a_inblack Effect Value Slider a_inwhite Effect Value Slider a_gamma Effect Value Slider a_outblack Effect Value Slider a_outwhite Effect No Value In Black 0 In White 1 Gamma 1 Out Black 0 Out White Red: 1 In Black 0 In White 1 Gamma 1 Out Black 0 Out White Green: 1 In Black 0 In White 1 Gamma 1 Out Black 0 Out White Blue: 1 In Black 0 In White 1 Gamma 1 Out Black 0 Out White 1 var lottie_player_13 = new PlaygroundPlayer( 13, 'playground_13_21', 'lottie_target_13', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 24, \"ef\": [{\"ty\": 7, \"v\": {\"nm\": \"00 Dropdown\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"01\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"02\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"08\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"09 slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"r_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"r_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"r_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"r_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"r_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"15 slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"16 slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"g_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"g_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"g_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"g_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"g_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"22\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"23\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"b_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"b_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"b_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"b_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"b_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"29\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"a_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"a_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"a_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"a_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"a_outwhite slider\", \"a\": 0, \"k\": 1}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[3].v.k = data[\"Composite In Black\"]; lottie.layers[0].ef[0].ef[4].v.k = data[\"Composite In White\"]; lottie.layers[0].ef[0].ef[5].v.k = data[\"Composite Gamma\"]; lottie.layers[0].ef[0].ef[6].v.k = data[\"Composite Out Black\"]; lottie.layers[0].ef[0].ef[7].v.k = data[\"Composite Out White\"]; lottie.layers[0].ef[0].ef[10].v.k = data[\"Red In Black\"]; lottie.layers[0].ef[0].ef[11].v.k = data[\"Red In White\"]; lottie.layers[0].ef[0].ef[12].v.k = data[\"Red Gamma\"]; lottie.layers[0].ef[0].ef[13].v.k = data[\"Red Out Black\"]; lottie.layers[0].ef[0].ef[14].v.k = data[\"Red Out White\"]; lottie.layers[0].ef[0].ef[17].v.k = data[\"Green In Black\"]; lottie.layers[0].ef[0].ef[18].v.k = data[\"Green In White\"]; lottie.layers[0].ef[0].ef[19].v.k = data[\"Green Gamma\"]; lottie.layers[0].ef[0].ef[20].v.k = data[\"Green Out Black\"]; lottie.layers[0].ef[0].ef[21].v.k = data[\"Green Out White\"]; lottie.layers[0].ef[0].ef[24].v.k = data[\"Blue In Black\"]; lottie.layers[0].ef[0].ef[25].v.k = data[\"Blue In White\"]; lottie.layers[0].ef[0].ef[26].v.k = data[\"Blue Gamma\"]; lottie.layers[0].ef[0].ef[27].v.k = data[\"Blue Out Black\"]; lottie.layers[0].ef[0].ef[28].v.k = data[\"Blue Out White\"]; this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} ); Tint Effect The layer is converted to grayscale, then black to white is mapped to the given color. The result is merged back with the original based on the intensity. Composition Diagram for Tint Effect Tint Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 20 Type Type en 0-1 integer Enabled Enabled Name Type Black Color Effect Value Color White Color Effect Value Color Intensity Effect Value Slider Red 0 Green 0 Blue White 0 Red 0 Green 1 Blue Intensity 0 Effect Intensity 90 var lottie_player_14 = new PlaygroundPlayer( 14, 'playground_14_8', 'lottie_target_14', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 20, \"ef\": [{\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0, 1, 0, 1], \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 90, \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[0].v.k[0] = data[\"Black Red\"]; lottie.layers[0].ef[0].ef[0].v.k[1] = data[\"Black Green\"]; lottie.layers[0].ef[0].ef[0].v.k[2] = data[\"Black Blue\"]; lottie.layers[0].ef[0].ef[1].v.k[0] = data[\"White Red\"]; lottie.layers[0].ef[0].ef[1].v.k[1] = data[\"White Green\"]; lottie.layers[0].ef[0].ef[1].v.k[2] = data[\"White Blue\"]; lottie.layers[0].ef[0].ef[2].v.k = data[\"Effect Intensity\"]; this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} ); Matte3 Effect Uses a layer as a mask Composition Diagram for Set Matte Effect Set Matte Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 28 Type Type en 0-1 integer Enabled Enabled Name Type Layer Effect Value Layer Channel Effect Value Drop Down Invert Effect Value Drop Down Stretch To Fit Effect Value Drop Down Show Mask Effect Value Drop Down Premultiply Mask Effect Value Drop Down Layer Circle Rectangle Channel Red Green Blue Alpha Luma Hue Lightness Saturation Full Off Invert Stretch To Fit Show Mask Premultiply Mask var lottie_player_15 = new PlaygroundPlayer( 15, 'playground_15_7', 'lottie_target_15', {\"v\": \"5.9.0\", \"fr\": 29.9700012207031, \"ip\": 0, \"op\": 900.000036657751, \"w\": 1920, \"h\": 1080, \"nm\": \"Comp 1\", \"ddd\": 0, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ind\": 1, \"ty\": 4, \"nm\": \"Star\", \"sr\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100, \"ix\": 11}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 10}, \"p\": {\"a\": 0, \"k\": [960, 540, 0], \"ix\": 2, \"l\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0, 0], \"ix\": 1, \"l\": 2}, \"s\": {\"a\": 0, \"k\": [100, 100, 100], \"ix\": 6, \"l\": 2}}, \"ao\": 0, \"ef\": [{\"ty\": 28, \"nm\": \"Set Matte\", \"np\": 8, \"mn\": \"ADBE Set Matte3\", \"ix\": 1, \"en\": 1, \"ef\": [{\"ty\": 10, \"nm\": \"Take Matte From Layer\", \"mn\": \"ADBE Set Matte3-0001\", \"ix\": 1, \"v\": {\"a\": 0, \"k\": 3, \"ix\": 1}}, {\"ty\": 7, \"nm\": \"Use For Matte\", \"mn\": \"ADBE Set Matte3-0002\", \"ix\": 2, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 2}}, {\"ty\": 7, \"nm\": \"Invert Matte\", \"mn\": \"ADBE Set Matte3-0003\", \"ix\": 3, \"v\": {\"a\": 0, \"k\": 0, \"ix\": 3}}, {\"ty\": 7, \"nm\": \"If Layer Sizes Differ\", \"mn\": \"ADBE Set Matte3-0004\", \"ix\": 4, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 4}}, {\"ty\": 7, \"nm\": \"Composite Matte with Original\", \"mn\": \"ADBE Set Matte3-0005\", \"ix\": 5, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 5}}, {\"ty\": 7, \"nm\": \"Premultiply Matte Layer\", \"mn\": \"ADBE Set Matte3-0006\", \"ix\": 6, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 6}}]}], \"shapes\": [{\"ty\": \"gr\", \"it\": [{\"ty\": \"sr\", \"sy\": 1, \"d\": 1, \"pt\": {\"a\": 0, \"k\": 5, \"ix\": 3}, \"p\": {\"a\": 0, \"k\": [0, 0], \"ix\": 4}, \"r\": {\"a\": 0, \"k\": 222.865, \"ix\": 5}, \"ir\": {\"a\": 0, \"k\": 226.442, \"ix\": 6}, \"is\": {\"a\": 0, \"k\": 0, \"ix\": 8}, \"or\": {\"a\": 0, \"k\": 452.885, \"ix\": 7}, \"os\": {\"a\": 0, \"k\": 0, \"ix\": 9}, \"ix\": 1, \"nm\": \"Polystar Path 1\", \"mn\": \"ADBE Vector Shape - Star\", \"hd\": false}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725], \"ix\": 4}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 5}, \"r\": 1, \"bm\": 0, \"nm\": \"Fill 1\", \"mn\": \"ADBE Vector Graphic - Fill\", \"hd\": false}, {\"ty\": \"tr\", \"p\": {\"a\": 0, \"k\": [124, -148], \"ix\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 1}, \"s\": {\"a\": 0, \"k\": [100, 100], \"ix\": 3}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 6}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 7}, \"sk\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"sa\": {\"a\": 0, \"k\": 0, \"ix\": 5}, \"nm\": \"Transform\"}], \"nm\": \"Polystar 1\", \"np\": 3, \"cix\": 2, \"bm\": 0, \"ix\": 1, \"mn\": \"ADBE Vector Group\", \"hd\": false}], \"ip\": 0, \"op\": 900.000036657751, \"st\": 0, \"bm\": 0}, {\"ddd\": 0, \"ind\": 2, \"ty\": 4, \"nm\": \"Ellipse\", \"sr\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100, \"ix\": 11}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 10}, \"p\": {\"a\": 0, \"k\": [960, 540, 0], \"ix\": 2, \"l\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0, 0], \"ix\": 1, \"l\": 2}, \"s\": {\"a\": 0, \"k\": [100, 100, 100], \"ix\": 6, \"l\": 2}}, \"ao\": 0, \"shapes\": [{\"ty\": \"gr\", \"it\": [{\"d\": 1, \"ty\": \"el\", \"s\": {\"a\": 0, \"k\": [528.102, 545.938], \"ix\": 2}, \"p\": {\"a\": 0, \"k\": [0, 0], \"ix\": 3}, \"nm\": \"Ellipse Path 1\", \"mn\": \"ADBE Vector Shape - Ellipse\", \"hd\": false}, {\"ty\": \"st\", \"c\": {\"a\": 0, \"k\": [1, 1, 1, 1], \"ix\": 3}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 4}, \"w\": {\"a\": 0, \"k\": 2, \"ix\": 5}, \"lc\": 1, \"lj\": 1, \"ml\": 4, \"bm\": 0, \"nm\": \"Stroke 1\", \"mn\": \"ADBE Vector Graphic - Stroke\", \"hd\": false}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.7686274509803922, 0.8509803921568627, 0.9607843137254902], \"ix\": 4}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 5}, \"r\": 1, \"bm\": 0, \"nm\": \"Fill 1\", \"mn\": \"ADBE Vector Graphic - Fill\", \"hd\": false}, {\"ty\": \"tr\", \"p\": {\"a\": 0, \"k\": [409.91, -95.102], \"ix\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 1}, \"s\": {\"a\": 0, \"k\": [100, 100], \"ix\": 3}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 6}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 7}, \"sk\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"sa\": {\"a\": 0, \"k\": 0, \"ix\": 5}, \"nm\": \"Transform\"}], \"nm\": \"Ellipse 1\", \"np\": 3, \"cix\": 2, \"bm\": 0, \"ix\": 1, \"mn\": \"ADBE Vector Group\", \"hd\": false}], \"ip\": 0, \"op\": 900.000036657751, \"st\": 0, \"bm\": 0}, {\"ddd\": 0, \"ind\": 3, \"ty\": 4, \"nm\": \"Rectangle\", \"sr\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100, \"ix\": 11}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 10}, \"p\": {\"a\": 0, \"k\": [960, 540, 0], \"ix\": 2, \"l\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0, 0], \"ix\": 1, \"l\": 2}, \"s\": {\"a\": 0, \"k\": [100, 100, 100], \"ix\": 6, \"l\": 2}}, \"ao\": 0, \"shapes\": [{\"ty\": \"gr\", \"it\": [{\"ty\": \"rc\", \"d\": 1, \"s\": {\"a\": 0, \"k\": [78.482, 70.992], \"ix\": 2}, \"p\": {\"a\": 0, \"k\": [0, 0], \"ix\": 3}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"nm\": \"Rectangle Path 1\", \"mn\": \"ADBE Vector Shape - Rect\", \"hd\": false}, {\"ty\": \"st\", \"c\": {\"a\": 0, \"k\": [1, 1, 1, 1], \"ix\": 3}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 4}, \"w\": {\"a\": 0, \"k\": 2, \"ix\": 5}, \"lc\": 1, \"lj\": 1, \"ml\": 4, \"bm\": 0, \"nm\": \"Stroke 1\", \"mn\": \"ADBE Vector Graphic - Stroke\", \"hd\": false}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098], \"ix\": 4}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 5}, \"r\": 1, \"bm\": 0, \"nm\": \"Fill 1\", \"mn\": \"ADBE Vector Graphic - Fill\", \"hd\": false}, {\"ty\": \"tr\", \"p\": {\"a\": 0, \"k\": [-143.321, -63.043], \"ix\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 1}, \"s\": {\"a\": 0, \"k\": [563.332, 416.105], \"ix\": 3}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 6}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 7}, \"sk\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"sa\": {\"a\": 0, \"k\": 0, \"ix\": 5}, \"nm\": \"Transform\"}], \"nm\": \"Rectangle 1\", \"np\": 3, \"cix\": 2, \"bm\": 0, \"ix\": 1, \"mn\": \"ADBE Vector Group\", \"hd\": false}], \"ip\": 0, \"op\": 900.000036657751, \"st\": 0, \"bm\": 0}], \"markers\": []}, function (lottie, data) { lottie.layers[0].ef[0].ef[0].v.k = Number(data[\"Layer\"]); lottie.layers[0].ef[0].ef[1].v.k = Number(data[\"Channel\"]); lottie.layers[0].ef[0].ef[2].v.k = Number(data[\"Invert\"]); lottie.layers[0].ef[0].ef[3].v.k = Number(data[\"Stretch To Fit\"]); lottie.layers[0].ef[0].ef[4].v.k = Number(data[\"Show Mask\"]); lottie.layers[0].ef[0].ef[5].v.k = Number(data[\"Premultiply Mask\"]); this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} ); Gaussian Blur Effect Composition Diagram for Gaussian Blur Effect Gaussian Blur Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 29 Type Type en 0-1 integer Enabled Enabled Name Type sigma Effect Value Slider direction Effect Value Slider wrap Effect Value Checkbox Sigma 25 Direction Both Horizontal Vertical Wrap var lottie_player_16 = new PlaygroundPlayer( 16, 'playground_16_4', 'lottie_target_16', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 29, \"en\": 1, \"ef\": [{\"ty\": 0, \"v\": {\"a\": 0, \"k\": 25}}, {\"ty\": 0, \"v\": {\"k\": 0, \"a\": 0}}, {\"ty\": 4, \"v\": {\"k\": 0, \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[0].v.k = data[\"Sigma\"]; lottie.layers[0].ef[0].ef[1].v.k = Number(data[\"Direction\"]); lottie.layers[0].ef[0].ef[2].v.k = Number(data[\"Wrap\"]); this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} ); Drop Shadow Effect Composition Diagram for Drop Shadow Effect Drop Shadow Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 25 Type Type en 0-1 integer Enabled Enabled Name Type color Effect Value Color opacity Effect Value Slider angle Effect Value Angle distance Effect Value Slider blur Effect Value Slider Red 0 Green 0 Blue 0 Opacity 128 Angle 135 Distance 10 Blur 7 var lottie_player_17 = new PlaygroundPlayer( 17, 'playground_17_8', 'lottie_target_17', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 25, \"ef\": [{\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 128, \"a\": 0}}, {\"ty\": 1, \"v\": {\"k\": 135, \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 10, \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 7, \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[0].v.k[0] = data[\"Red\"]; lottie.layers[0].ef[0].ef[0].v.k[1] = data[\"Green\"]; lottie.layers[0].ef[0].ef[0].v.k[2] = data[\"Blue\"]; lottie.layers[0].ef[0].ef[1].v.k = data[\"Opacity\"]; lottie.layers[0].ef[0].ef[2].v.k = data[\"Angle\"]; lottie.layers[0].ef[0].ef[3].v.k = data[\"Distance\"]; lottie.layers[0].ef[0].ef[4].v.k = data[\"Blur\"]; this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} ); Radial Wipe Effect Composition Diagram for Radial Wipe Radial Wipe Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 26 Type Type en 0-1 integer Enabled Enabled Name Type Completion Effect Value Slider Start Angle Effect Value Angle Wipe Center Effect Value Point Wipe Effect Value Slider Feather Effect Value Slider Displacement Map Effect Composition Diagram for Displacement Map Effect Displacement Map Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 27 Type Type en 0-1 integer Enabled Enabled Name Type Displacement Map Layer Effect Value Layer Use For Horizontal Displacement Effect Value Drop Down Max Horizontal Displacement Effect Value Slider Use For Vertical Displacement Effect Value Drop Down Max Vertical Displacement Effect Value Slider Displacement Map Behavior Effect Value Drop Down Edge Behavior Effect Value Drop Down Expand Output Effect Value Drop Down Mesh Warp Effect Composition Diagram for Mesh Warp Effect Mesh Warp Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 31 Type Type en 0-1 integer Enabled Enabled Name Type Rows Effect Value Slider Columns Effect Value Slider Quality Effect Value Slider 03 Effect No Value Puppet Effect Composition Diagram for Puppet Effect Puppet Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 34 Type Type en 0-1 integer Enabled Enabled Name Type Puppet Engine Effect Value Drop Down Mesh Rotation Refinement Effect Value Slider On Transparent Effect Value Drop Down 03 Effect No Value Spherize Effect Composition Diagram for Spherize Effect Spherize Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 33 Type Type en 0-1 integer Enabled Enabled Name Type radius Effect Value Slider center Effect Value Point Wavy Effect Composition Diagram for Wavy Effect Wavy Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 32 Type Type en 0-1 integer Enabled Enabled Name Type Radius Effect Value Slider Center Effect Value Point Conversion type Effect Value Drop Down Speed Effect Value Drop Down Width Effect Value Slider Height Effect Value Slider Phase Effect Value Slider Twirl Effect Composition Diagram for Twirl Effect Twirl Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 30 Type Type en 0-1 integer Enabled Enabled Name Type Angle Effect Value Angle Radius Effect Value Slider Center Effect Value Point Custom Effect You might find various different effects all with ty = 5. Sometimes these are used together with expressions. Composition Diagram for Custom Effect Custom Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array of Effect No Value or Effect Value Angle or Effect Value Checkbox or Effect Value Color or Effect Value Drop Down or Ignored Value or Effect Value Layer or Effect Value Point or Effect Value Slider Effect Values Effect Values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 5 Type Type en 0-1 integer Enabled Enabled Effect Values Composition Diagram for Effect Value Effect Value Visual Object Ignored Value Effect Value Angle Effect Value Drop Down Effect Value Point Effect Value Slider Effect Value Color Effect Value Layer Effect Value Checkbox Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ix integer Effect Index Effect Index ty integer Type Type ty Type 1 Effect Value Angle 4 Effect Value Checkbox 2 Effect Value Color 7 Effect Value Drop Down 6 Ignored Value 10 Effect Value Layer 3 Effect Value Point 0 Effect Value Slider No Value Slider Composition Diagram for Effect Value Slider Effect Value Slider Effect Value Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ix integer Effect Index Effect Index ty integer = 0 Type Type v Scalar Value Value Angle Composition Diagram for Effect Value Angle Effect Value Angle Effect Value Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ix integer Effect Index Effect Index ty integer = 1 Type Type v Scalar Value Value Color Composition Diagram for Effect Value Color Effect Value Color Effect Value Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ix integer Effect Index Effect Index ty integer = 2 Type Type v Color Value Value Point Composition Diagram for Effect Value Point Effect Value Point Effect Value Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ix integer Effect Index Effect Index ty integer = 3 Type Type v Vector Value Value Checkbox Composition Diagram for Effect Value Checkbox Effect Value Checkbox Effect Value Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ix integer Effect Index Effect Index ty integer = 4 Type Type v Scalar Value Value Ignored Composition Diagram for Ignored Value Ignored Value Effect Value Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ix integer Effect Index Effect Index ty integer = 6 Type Type v number Value Value Drop Down Composition Diagram for Effect Value Drop Down Effect Value Drop Down Effect Value Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ix integer Effect Index Effect Index ty integer = 7 Type Type v Scalar Value Value Layer Composition Diagram for Effect Value Layer Effect Value Layer Effect Value Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ix integer Effect Index Effect Index ty integer = 10 Type Type v Scalar Value Value Layer Style A layer can also have a list of styles applied to it Composition Diagram for Layer Style Layer Style Visual Object Outer Glow Layer Stroke Drop Shadow Inner Glow Satin Color Overlay Inner Shadow Gradient Overlay Bevel Emboss Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ty integer Type Style Type Style types: ty Type 5 Bevel Emboss 7 Color Overlay 1 Drop Shadow 8 Gradient Overlay 4 Inner Glow 2 Inner Shadow 3 Outer Glow 6 Satin 0 Layer Stroke Stroke Style Composition Diagram for Layer Stroke Layer Stroke Layer Style Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ty integer = 0 Type Layer Type s Scalar Size Size c Color Color Color Drop Shadow Style Composition Diagram for Drop Shadow Drop Shadow Layer Style Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ty integer = 1 Type Layer Type c Color Color Color o Scalar Opacity Opacity a Scalar Angle Local light angle s Scalar Size Blur size d Scalar Distance Distance ch Scalar Choke Spread Choke Spread bm Scalar Blend Mode Blend Mode no Scalar Noise Noise lc Scalar Layer Conceal Layer knowck out drop shadow Inner Shadow Style Composition Diagram for Inner Shadow Inner Shadow Layer Style Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ty integer = 2 Type Layer Type c Color Color Color o Scalar Opacity Opacity a Scalar Angle Local light angle s Scalar Size Blur size d Scalar Distance Distance ch Scalar Choke Spread Choke Spread bm Scalar Blend Mode Blend Mode no Scalar Noise Noise Outer Glow Style Composition Diagram for Outer Glow Outer Glow Layer Style Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ty integer = 3 Type Layer Type c Color Color Color o Scalar Opacity Opacity r Scalar Range Range ch Scalar Choke Spread Choke Spread bm Scalar Blend Mode Blend Mode no Scalar Noise Noise j Scalar Jitter Jitter Inner Glow Style Composition Diagram for Inner Glow Inner Glow Layer Style Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ty integer = 4 Type Layer Type c Color Color Color o Scalar Opacity Opacity r Scalar Range Range sr Scalar Source Source ch Scalar Choke Spread Choke Spread bm Scalar Blend Mode Blend Mode no Scalar Noise Noise j Scalar Jitter Jitter Bevel / Emboss Style Composition Diagram for Bevel Emboss Bevel Emboss Layer Style Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ty integer = 5 Type Layer Type bs Scalar Bevel Style Bevel Style bt Scalar Technique Technique sr Scalar Strength Strength s Scalar Size Size sf Scalar Soften Soften ga Scalar Global Angle Use global light a Scalar Angle Local lighting angle ll Scalar Altitude Local lighting altitude hm Scalar Highlight Mode Highlight Mode hc Color Highlight Color Highlight Color ho Scalar Highlight Opacity Highlight Opacity sm Scalar Shadow Mode Shadow Mode sc Color Shadow Color Shadow Color so Scalar Shadow Opacity Shadow Opacity Satin Style Composition Diagram for Satin Satin Layer Style Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ty integer = 6 Type Layer Type bm Scalar Blend Mode Blend Mode c Color Color Color o Scalar Opacity Opacity a Scalar Angle Angle d Scalar Distance Distance s Scalar Size Size in Scalar Invert Invert Color Overlay Style Composition Diagram for Color Overlay Color Overlay Layer Style Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ty integer = 7 Type Layer Type bm Scalar Blend Mode Blend Mode c Color Color Color so Scalar Opacity Opacity Gradient Overlay Style Composition Diagram for Gradient Overlay Gradient Overlay Layer Style Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ty integer = 8 Type Layer Type bm Scalar Blend Mode Blend Mode o Scalar Opacity Opacity gf Gradient Gradient Gradient gs Scalar Smoothness Smoothness a Scalar Angle Angle gt Gradient Type Gradient Type Gradient Type re Scalar Reverse Reverse al Scalar Align Align with layer s Scalar Scale Scale of Scalar Offset Offset","title":"Layer Effects"},{"location":"effects/#layer-effects","text":"Layers can have post-processing effects applied to them.","title":"Layer Effects"},{"location":"effects/#effect","text":"Composition Diagram for Effect Effect Visual Object Spherize Effect Puppet Effect Tritone Effect Displacement Map Effect Wavy Effect Gaussian Blur Effect Pro Levels Effect Tint Effect Mesh Warp Effect Set Matte Effect Fill Effect Drop Shadow Effect Radial Wipe Stroke Effect Twirl Effect Custom Effect Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array of Effect No Value or Effect Value Angle or Effect Value Checkbox or Effect Value Color or Effect Value Drop Down or Ignored Value or Effect Value Layer or Effect Value Point or Effect Value Slider Effect Values Effect Values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer Type Effect type en 0-1 integer Enabled Enabled Many effects have unused values which are labeled with a number. Effect types: ty Type 5 Custom Effect 27 Displacement Map Effect 25 Drop Shadow Effect None Effect 21 Fill Effect 29 Gaussian Blur Effect 28 Set Matte Effect 31 Mesh Warp Effect 24 Pro Levels Effect 34 Puppet Effect 26 Radial Wipe 33 Spherize Effect 22 Stroke Effect 20 Tint Effect 23 Tritone Effect 30 Twirl Effect 32 Wavy Effect All the examples will use this as their base: var lottie_player_10 = new LottiePlayer( 'lottie_target_10', '../static/examples/image.json', true, {} );","title":"Effects"},{"location":"effects/#fill-effect","text":"Fill all opaque areas with a solid color Composition Diagram for Fill Effect Fill Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 21 Type Type en 0-1 integer Enabled Enabled Name Type 10 Effect Value Layer 01 Effect Value Drop Down color Effect Value Color 03 Effect Value Drop Down 04 Effect Value Slider 05 Effect Value Slider opacity Effect Value Slider Opacity Color 1 Red 1 Green 0.9 Blue 0 var lottie_player_11 = new PlaygroundPlayer( 11, 'playground_11_5', 'lottie_target_11', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 21, \"ef\": [{\"ty\": 3, \"v\": {\"k\": [0, 0], \"a\": 0}}, {\"ty\": 7, \"v\": {\"k\": 0, \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [1, 0.9, 0, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}, {\"ty\": 7, \"v\": {\"k\": 0, \"a\": 0}}, {\"ty\": 0, \"v\": {\"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"a\": 0, \"k\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[6].v.k = data[\"Opacity\"]; lottie.layers[0].ef[0].ef[2].v.k[0] = data[\"Red\"]; lottie.layers[0].ef[0].ef[2].v.k[1] = data[\"Green\"]; lottie.layers[0].ef[0].ef[2].v.k[2] = data[\"Blue\"]; this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} );","title":"Fill Effect"},{"location":"effects/#stroke-effect","text":"Composition Diagram for Stroke Effect Stroke Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 22 Type Type en 0-1 integer Enabled Enabled Name Type 00 Effect Value Color 01 Effect Value Checkbox 02 Effect Value Checkbox color Effect Value Color 04 Effect Value Slider 05 Effect Value Slider 06 Effect Value Slider 07 Effect Value Slider 08 Effect Value Slider 09 Effect Value Drop Down type Effect Value Drop Down","title":"Stroke Effect"},{"location":"effects/#tritone-effect","text":"Converts the layer to greyscale, then applies the gradient based on bright/mid/dark. Composition Diagram for Tritone Effect Tritone Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 23 Type Type en 0-1 integer Enabled Enabled Name Type bright Effect Value Color mid Effect Value Color dark Effect Value Color Red 1 Green 1 Blue Mid 1 Red 0.3 Green 0.8 Blue Dark 0.3 Red 0 Green 0 Blue 0 var lottie_player_12 = new PlaygroundPlayer( 12, 'playground_12_10', 'lottie_target_12', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 23, \"ef\": [{\"ty\": 2, \"v\": {\"k\": [1, 1, 1, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0.3, 0.8, 0.3, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[0].v.k[0] = data[\"r1\"]; lottie.layers[0].ef[0].ef[0].v.k[1] = data[\"g1\"]; lottie.layers[0].ef[0].ef[0].v.k[2] = data[\"b1\"]; lottie.layers[0].ef[0].ef[1].v.k[0] = data[\"r2\"]; lottie.layers[0].ef[0].ef[1].v.k[1] = data[\"g2\"]; lottie.layers[0].ef[0].ef[1].v.k[2] = data[\"b2\"]; lottie.layers[0].ef[0].ef[2].v.k[0] = data[\"r3\"]; lottie.layers[0].ef[0].ef[2].v.k[1] = data[\"g3\"]; lottie.layers[0].ef[0].ef[2].v.k[2] = data[\"b3\"]; this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} );","title":"Tritone Effect"},{"location":"effects/#pro-levels-effect","text":"Color correction levels. For more information refer to the After Effects Documentation . Composition Diagram for Pro Levels Effect Pro Levels Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 24 Type Type en 0-1 integer Enabled Enabled Name Type 00 Effect Value Drop Down 01 Effect No Value 02 Effect No Value comp_inblack Effect Value Slider comp_inwhite Effect Value Slider comp_gamma Effect Value Slider comp_outblack Effect Value Slider comp_outwhite Effect No Value 08 Effect No Value 09 Effect Value Slider r_inblack Effect Value Slider r_inwhite Effect Value Slider r_gamma Effect Value Slider r_outblack Effect Value Slider r_outwhite Effect Value Slider 15 Effect Value Slider 16 Effect Value Slider g_inblack Effect Value Slider g_inwhite Effect Value Slider g_gamma Effect Value Slider g_outblack Effect Value Slider g_outwhite Effect Value Slider 22 Effect Value Slider 23 Effect Value Slider b_inblack Effect Value Slider b_inwhite Effect Value Slider b_gamma Effect Value Slider b_outblack Effect Value Slider b_outwhite Effect Value Slider 29 Effect Value Slider a_inblack Effect Value Slider a_inwhite Effect Value Slider a_gamma Effect Value Slider a_outblack Effect Value Slider a_outwhite Effect No Value In Black 0 In White 1 Gamma 1 Out Black 0 Out White Red: 1 In Black 0 In White 1 Gamma 1 Out Black 0 Out White Green: 1 In Black 0 In White 1 Gamma 1 Out Black 0 Out White Blue: 1 In Black 0 In White 1 Gamma 1 Out Black 0 Out White 1 var lottie_player_13 = new PlaygroundPlayer( 13, 'playground_13_21', 'lottie_target_13', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 24, \"ef\": [{\"ty\": 7, \"v\": {\"nm\": \"00 Dropdown\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"01\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"02\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"08\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"09 slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"r_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"r_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"r_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"r_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"r_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"15 slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"16 slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"g_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"g_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"g_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"g_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"g_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"22\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"23\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"b_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"b_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"b_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"b_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"b_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"29\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"a_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"a_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"a_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"a_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"a_outwhite slider\", \"a\": 0, \"k\": 1}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[3].v.k = data[\"Composite In Black\"]; lottie.layers[0].ef[0].ef[4].v.k = data[\"Composite In White\"]; lottie.layers[0].ef[0].ef[5].v.k = data[\"Composite Gamma\"]; lottie.layers[0].ef[0].ef[6].v.k = data[\"Composite Out Black\"]; lottie.layers[0].ef[0].ef[7].v.k = data[\"Composite Out White\"]; lottie.layers[0].ef[0].ef[10].v.k = data[\"Red In Black\"]; lottie.layers[0].ef[0].ef[11].v.k = data[\"Red In White\"]; lottie.layers[0].ef[0].ef[12].v.k = data[\"Red Gamma\"]; lottie.layers[0].ef[0].ef[13].v.k = data[\"Red Out Black\"]; lottie.layers[0].ef[0].ef[14].v.k = data[\"Red Out White\"]; lottie.layers[0].ef[0].ef[17].v.k = data[\"Green In Black\"]; lottie.layers[0].ef[0].ef[18].v.k = data[\"Green In White\"]; lottie.layers[0].ef[0].ef[19].v.k = data[\"Green Gamma\"]; lottie.layers[0].ef[0].ef[20].v.k = data[\"Green Out Black\"]; lottie.layers[0].ef[0].ef[21].v.k = data[\"Green Out White\"]; lottie.layers[0].ef[0].ef[24].v.k = data[\"Blue In Black\"]; lottie.layers[0].ef[0].ef[25].v.k = data[\"Blue In White\"]; lottie.layers[0].ef[0].ef[26].v.k = data[\"Blue Gamma\"]; lottie.layers[0].ef[0].ef[27].v.k = data[\"Blue Out Black\"]; lottie.layers[0].ef[0].ef[28].v.k = data[\"Blue Out White\"]; this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} );","title":"Pro Levels Effect"},{"location":"effects/#tint-effect","text":"The layer is converted to grayscale, then black to white is mapped to the given color. The result is merged back with the original based on the intensity. Composition Diagram for Tint Effect Tint Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 20 Type Type en 0-1 integer Enabled Enabled Name Type Black Color Effect Value Color White Color Effect Value Color Intensity Effect Value Slider Red 0 Green 0 Blue White 0 Red 0 Green 1 Blue Intensity 0 Effect Intensity 90 var lottie_player_14 = new PlaygroundPlayer( 14, 'playground_14_8', 'lottie_target_14', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 20, \"ef\": [{\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0, 1, 0, 1], \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 90, \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[0].v.k[0] = data[\"Black Red\"]; lottie.layers[0].ef[0].ef[0].v.k[1] = data[\"Black Green\"]; lottie.layers[0].ef[0].ef[0].v.k[2] = data[\"Black Blue\"]; lottie.layers[0].ef[0].ef[1].v.k[0] = data[\"White Red\"]; lottie.layers[0].ef[0].ef[1].v.k[1] = data[\"White Green\"]; lottie.layers[0].ef[0].ef[1].v.k[2] = data[\"White Blue\"]; lottie.layers[0].ef[0].ef[2].v.k = data[\"Effect Intensity\"]; this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} );","title":"Tint Effect"},{"location":"effects/#matte3-effect","text":"Uses a layer as a mask Composition Diagram for Set Matte Effect Set Matte Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 28 Type Type en 0-1 integer Enabled Enabled Name Type Layer Effect Value Layer Channel Effect Value Drop Down Invert Effect Value Drop Down Stretch To Fit Effect Value Drop Down Show Mask Effect Value Drop Down Premultiply Mask Effect Value Drop Down Layer Circle Rectangle Channel Red Green Blue Alpha Luma Hue Lightness Saturation Full Off Invert Stretch To Fit Show Mask Premultiply Mask var lottie_player_15 = new PlaygroundPlayer( 15, 'playground_15_7', 'lottie_target_15', {\"v\": \"5.9.0\", \"fr\": 29.9700012207031, \"ip\": 0, \"op\": 900.000036657751, \"w\": 1920, \"h\": 1080, \"nm\": \"Comp 1\", \"ddd\": 0, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ind\": 1, \"ty\": 4, \"nm\": \"Star\", \"sr\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100, \"ix\": 11}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 10}, \"p\": {\"a\": 0, \"k\": [960, 540, 0], \"ix\": 2, \"l\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0, 0], \"ix\": 1, \"l\": 2}, \"s\": {\"a\": 0, \"k\": [100, 100, 100], \"ix\": 6, \"l\": 2}}, \"ao\": 0, \"ef\": [{\"ty\": 28, \"nm\": \"Set Matte\", \"np\": 8, \"mn\": \"ADBE Set Matte3\", \"ix\": 1, \"en\": 1, \"ef\": [{\"ty\": 10, \"nm\": \"Take Matte From Layer\", \"mn\": \"ADBE Set Matte3-0001\", \"ix\": 1, \"v\": {\"a\": 0, \"k\": 3, \"ix\": 1}}, {\"ty\": 7, \"nm\": \"Use For Matte\", \"mn\": \"ADBE Set Matte3-0002\", \"ix\": 2, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 2}}, {\"ty\": 7, \"nm\": \"Invert Matte\", \"mn\": \"ADBE Set Matte3-0003\", \"ix\": 3, \"v\": {\"a\": 0, \"k\": 0, \"ix\": 3}}, {\"ty\": 7, \"nm\": \"If Layer Sizes Differ\", \"mn\": \"ADBE Set Matte3-0004\", \"ix\": 4, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 4}}, {\"ty\": 7, \"nm\": \"Composite Matte with Original\", \"mn\": \"ADBE Set Matte3-0005\", \"ix\": 5, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 5}}, {\"ty\": 7, \"nm\": \"Premultiply Matte Layer\", \"mn\": \"ADBE Set Matte3-0006\", \"ix\": 6, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 6}}]}], \"shapes\": [{\"ty\": \"gr\", \"it\": [{\"ty\": \"sr\", \"sy\": 1, \"d\": 1, \"pt\": {\"a\": 0, \"k\": 5, \"ix\": 3}, \"p\": {\"a\": 0, \"k\": [0, 0], \"ix\": 4}, \"r\": {\"a\": 0, \"k\": 222.865, \"ix\": 5}, \"ir\": {\"a\": 0, \"k\": 226.442, \"ix\": 6}, \"is\": {\"a\": 0, \"k\": 0, \"ix\": 8}, \"or\": {\"a\": 0, \"k\": 452.885, \"ix\": 7}, \"os\": {\"a\": 0, \"k\": 0, \"ix\": 9}, \"ix\": 1, \"nm\": \"Polystar Path 1\", \"mn\": \"ADBE Vector Shape - Star\", \"hd\": false}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725], \"ix\": 4}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 5}, \"r\": 1, \"bm\": 0, \"nm\": \"Fill 1\", \"mn\": \"ADBE Vector Graphic - Fill\", \"hd\": false}, {\"ty\": \"tr\", \"p\": {\"a\": 0, \"k\": [124, -148], \"ix\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 1}, \"s\": {\"a\": 0, \"k\": [100, 100], \"ix\": 3}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 6}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 7}, \"sk\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"sa\": {\"a\": 0, \"k\": 0, \"ix\": 5}, \"nm\": \"Transform\"}], \"nm\": \"Polystar 1\", \"np\": 3, \"cix\": 2, \"bm\": 0, \"ix\": 1, \"mn\": \"ADBE Vector Group\", \"hd\": false}], \"ip\": 0, \"op\": 900.000036657751, \"st\": 0, \"bm\": 0}, {\"ddd\": 0, \"ind\": 2, \"ty\": 4, \"nm\": \"Ellipse\", \"sr\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100, \"ix\": 11}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 10}, \"p\": {\"a\": 0, \"k\": [960, 540, 0], \"ix\": 2, \"l\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0, 0], \"ix\": 1, \"l\": 2}, \"s\": {\"a\": 0, \"k\": [100, 100, 100], \"ix\": 6, \"l\": 2}}, \"ao\": 0, \"shapes\": [{\"ty\": \"gr\", \"it\": [{\"d\": 1, \"ty\": \"el\", \"s\": {\"a\": 0, \"k\": [528.102, 545.938], \"ix\": 2}, \"p\": {\"a\": 0, \"k\": [0, 0], \"ix\": 3}, \"nm\": \"Ellipse Path 1\", \"mn\": \"ADBE Vector Shape - Ellipse\", \"hd\": false}, {\"ty\": \"st\", \"c\": {\"a\": 0, \"k\": [1, 1, 1, 1], \"ix\": 3}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 4}, \"w\": {\"a\": 0, \"k\": 2, \"ix\": 5}, \"lc\": 1, \"lj\": 1, \"ml\": 4, \"bm\": 0, \"nm\": \"Stroke 1\", \"mn\": \"ADBE Vector Graphic - Stroke\", \"hd\": false}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.7686274509803922, 0.8509803921568627, 0.9607843137254902], \"ix\": 4}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 5}, \"r\": 1, \"bm\": 0, \"nm\": \"Fill 1\", \"mn\": \"ADBE Vector Graphic - Fill\", \"hd\": false}, {\"ty\": \"tr\", \"p\": {\"a\": 0, \"k\": [409.91, -95.102], \"ix\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 1}, \"s\": {\"a\": 0, \"k\": [100, 100], \"ix\": 3}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 6}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 7}, \"sk\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"sa\": {\"a\": 0, \"k\": 0, \"ix\": 5}, \"nm\": \"Transform\"}], \"nm\": \"Ellipse 1\", \"np\": 3, \"cix\": 2, \"bm\": 0, \"ix\": 1, \"mn\": \"ADBE Vector Group\", \"hd\": false}], \"ip\": 0, \"op\": 900.000036657751, \"st\": 0, \"bm\": 0}, {\"ddd\": 0, \"ind\": 3, \"ty\": 4, \"nm\": \"Rectangle\", \"sr\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100, \"ix\": 11}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 10}, \"p\": {\"a\": 0, \"k\": [960, 540, 0], \"ix\": 2, \"l\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0, 0], \"ix\": 1, \"l\": 2}, \"s\": {\"a\": 0, \"k\": [100, 100, 100], \"ix\": 6, \"l\": 2}}, \"ao\": 0, \"shapes\": [{\"ty\": \"gr\", \"it\": [{\"ty\": \"rc\", \"d\": 1, \"s\": {\"a\": 0, \"k\": [78.482, 70.992], \"ix\": 2}, \"p\": {\"a\": 0, \"k\": [0, 0], \"ix\": 3}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"nm\": \"Rectangle Path 1\", \"mn\": \"ADBE Vector Shape - Rect\", \"hd\": false}, {\"ty\": \"st\", \"c\": {\"a\": 0, \"k\": [1, 1, 1, 1], \"ix\": 3}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 4}, \"w\": {\"a\": 0, \"k\": 2, \"ix\": 5}, \"lc\": 1, \"lj\": 1, \"ml\": 4, \"bm\": 0, \"nm\": \"Stroke 1\", \"mn\": \"ADBE Vector Graphic - Stroke\", \"hd\": false}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098], \"ix\": 4}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 5}, \"r\": 1, \"bm\": 0, \"nm\": \"Fill 1\", \"mn\": \"ADBE Vector Graphic - Fill\", \"hd\": false}, {\"ty\": \"tr\", \"p\": {\"a\": 0, \"k\": [-143.321, -63.043], \"ix\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 1}, \"s\": {\"a\": 0, \"k\": [563.332, 416.105], \"ix\": 3}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 6}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 7}, \"sk\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"sa\": {\"a\": 0, \"k\": 0, \"ix\": 5}, \"nm\": \"Transform\"}], \"nm\": \"Rectangle 1\", \"np\": 3, \"cix\": 2, \"bm\": 0, \"ix\": 1, \"mn\": \"ADBE Vector Group\", \"hd\": false}], \"ip\": 0, \"op\": 900.000036657751, \"st\": 0, \"bm\": 0}], \"markers\": []}, function (lottie, data) { lottie.layers[0].ef[0].ef[0].v.k = Number(data[\"Layer\"]); lottie.layers[0].ef[0].ef[1].v.k = Number(data[\"Channel\"]); lottie.layers[0].ef[0].ef[2].v.k = Number(data[\"Invert\"]); lottie.layers[0].ef[0].ef[3].v.k = Number(data[\"Stretch To Fit\"]); lottie.layers[0].ef[0].ef[4].v.k = Number(data[\"Show Mask\"]); lottie.layers[0].ef[0].ef[5].v.k = Number(data[\"Premultiply Mask\"]); this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} );","title":"Matte3 Effect"},{"location":"effects/#gaussian-blur-effect","text":"Composition Diagram for Gaussian Blur Effect Gaussian Blur Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 29 Type Type en 0-1 integer Enabled Enabled Name Type sigma Effect Value Slider direction Effect Value Slider wrap Effect Value Checkbox Sigma 25 Direction Both Horizontal Vertical Wrap var lottie_player_16 = new PlaygroundPlayer( 16, 'playground_16_4', 'lottie_target_16', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 29, \"en\": 1, \"ef\": [{\"ty\": 0, \"v\": {\"a\": 0, \"k\": 25}}, {\"ty\": 0, \"v\": {\"k\": 0, \"a\": 0}}, {\"ty\": 4, \"v\": {\"k\": 0, \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[0].v.k = data[\"Sigma\"]; lottie.layers[0].ef[0].ef[1].v.k = Number(data[\"Direction\"]); lottie.layers[0].ef[0].ef[2].v.k = Number(data[\"Wrap\"]); this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} );","title":"Gaussian Blur Effect"},{"location":"effects/#drop-shadow-effect","text":"Composition Diagram for Drop Shadow Effect Drop Shadow Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 25 Type Type en 0-1 integer Enabled Enabled Name Type color Effect Value Color opacity Effect Value Slider angle Effect Value Angle distance Effect Value Slider blur Effect Value Slider Red 0 Green 0 Blue 0 Opacity 128 Angle 135 Distance 10 Blur 7 var lottie_player_17 = new PlaygroundPlayer( 17, 'playground_17_8', 'lottie_target_17', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 25, \"ef\": [{\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 128, \"a\": 0}}, {\"ty\": 1, \"v\": {\"k\": 135, \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 10, \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 7, \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ef[0].ef[0].v.k[0] = data[\"Red\"]; lottie.layers[0].ef[0].ef[0].v.k[1] = data[\"Green\"]; lottie.layers[0].ef[0].ef[0].v.k[2] = data[\"Blue\"]; lottie.layers[0].ef[0].ef[1].v.k = data[\"Opacity\"]; lottie.layers[0].ef[0].ef[2].v.k = data[\"Angle\"]; lottie.layers[0].ef[0].ef[3].v.k = data[\"Distance\"]; lottie.layers[0].ef[0].ef[4].v.k = data[\"Blur\"]; this.json_viewer_contents = lottie.layers[0].ef[0]; }, {} );","title":"Drop Shadow Effect"},{"location":"effects/#radial-wipe-effect","text":"Composition Diagram for Radial Wipe Radial Wipe Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 26 Type Type en 0-1 integer Enabled Enabled Name Type Completion Effect Value Slider Start Angle Effect Value Angle Wipe Center Effect Value Point Wipe Effect Value Slider Feather Effect Value Slider","title":"Radial Wipe Effect"},{"location":"effects/#displacement-map-effect","text":"Composition Diagram for Displacement Map Effect Displacement Map Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 27 Type Type en 0-1 integer Enabled Enabled Name Type Displacement Map Layer Effect Value Layer Use For Horizontal Displacement Effect Value Drop Down Max Horizontal Displacement Effect Value Slider Use For Vertical Displacement Effect Value Drop Down Max Vertical Displacement Effect Value Slider Displacement Map Behavior Effect Value Drop Down Edge Behavior Effect Value Drop Down Expand Output Effect Value Drop Down","title":"Displacement Map Effect"},{"location":"effects/#mesh-warp-effect","text":"Composition Diagram for Mesh Warp Effect Mesh Warp Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 31 Type Type en 0-1 integer Enabled Enabled Name Type Rows Effect Value Slider Columns Effect Value Slider Quality Effect Value Slider 03 Effect No Value","title":"Mesh Warp Effect"},{"location":"effects/#puppet-effect","text":"Composition Diagram for Puppet Effect Puppet Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 34 Type Type en 0-1 integer Enabled Enabled Name Type Puppet Engine Effect Value Drop Down Mesh Rotation Refinement Effect Value Slider On Transparent Effect Value Drop Down 03 Effect No Value","title":"Puppet Effect"},{"location":"effects/#spherize-effect","text":"Composition Diagram for Spherize Effect Spherize Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 33 Type Type en 0-1 integer Enabled Enabled Name Type radius Effect Value Slider center Effect Value Point","title":"Spherize Effect"},{"location":"effects/#wavy-effect","text":"Composition Diagram for Wavy Effect Wavy Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 32 Type Type en 0-1 integer Enabled Enabled Name Type Radius Effect Value Slider Center Effect Value Point Conversion type Effect Value Drop Down Speed Effect Value Drop Down Width Effect Value Slider Height Effect Value Slider Phase Effect Value Slider","title":"Wavy Effect"},{"location":"effects/#twirl-effect","text":"Composition Diagram for Twirl Effect Twirl Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array Effect values Effect values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 30 Type Type en 0-1 integer Enabled Enabled Name Type Angle Effect Value Angle Radius Effect Value Slider Center Effect Value Point","title":"Twirl Effect"},{"location":"effects/#custom-effect","text":"You might find various different effects all with ty = 5. Sometimes these are used together with expressions. Composition Diagram for Custom Effect Custom Effect Effect Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ef array of Effect No Value or Effect Value Angle or Effect Value Checkbox or Effect Value Color or Effect Value Drop Down or Ignored Value or Effect Value Layer or Effect Value Point or Effect Value Slider Effect Values Effect Values np integer Property Count Number of values in ef ix integer Effect Index Effect Index ty integer = 5 Type Type en 0-1 integer Enabled Enabled","title":"Custom Effect"},{"location":"effects/#effect-value","text":"Composition Diagram for Effect Value Effect Value Visual Object Ignored Value Effect Value Angle Effect Value Drop Down Effect Value Point Effect Value Slider Effect Value Color Effect Value Layer Effect Value Checkbox Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ix integer Effect Index Effect Index ty integer Type Type ty Type 1 Effect Value Angle 4 Effect Value Checkbox 2 Effect Value Color 7 Effect Value Drop Down 6 Ignored Value 10 Effect Value Layer 3 Effect Value Point 0 Effect Value Slider","title":"Effect Values"},{"location":"effects/#no-value","text":"","title":"No Value"},{"location":"effects/#slider","text":"Composition Diagram for Effect Value Slider Effect Value Slider Effect Value Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ix integer Effect Index Effect Index ty integer = 0 Type Type v Scalar Value Value","title":"Slider"},{"location":"effects/#angle","text":"Composition Diagram for Effect Value Angle Effect Value Angle Effect Value Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ix integer Effect Index Effect Index ty integer = 1 Type Type v Scalar Value Value","title":"Angle"},{"location":"effects/#color","text":"Composition Diagram for Effect Value Color Effect Value Color Effect Value Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ix integer Effect Index Effect Index ty integer = 2 Type Type v Color Value Value","title":"Color"},{"location":"effects/#point","text":"Composition Diagram for Effect Value Point Effect Value Point Effect Value Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ix integer Effect Index Effect Index ty integer = 3 Type Type v Vector Value Value","title":"Point"},{"location":"effects/#checkbox","text":"Composition Diagram for Effect Value Checkbox Effect Value Checkbox Effect Value Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ix integer Effect Index Effect Index ty integer = 4 Type Type v Scalar Value Value","title":"Checkbox"},{"location":"effects/#ignored","text":"Composition Diagram for Ignored Value Ignored Value Effect Value Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ix integer Effect Index Effect Index ty integer = 6 Type Type v number Value Value","title":"Ignored"},{"location":"effects/#drop-down","text":"Composition Diagram for Effect Value Drop Down Effect Value Drop Down Effect Value Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ix integer Effect Index Effect Index ty integer = 7 Type Type v Scalar Value Value","title":"Drop Down"},{"location":"effects/#layer","text":"Composition Diagram for Effect Value Layer Effect Value Layer Effect Value Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ix integer Effect Index Effect Index ty integer = 10 Type Type v Scalar Value Value","title":"Layer"},{"location":"effects/#layer-style","text":"A layer can also have a list of styles applied to it Composition Diagram for Layer Style Layer Style Visual Object Outer Glow Layer Stroke Drop Shadow Inner Glow Satin Color Overlay Inner Shadow Gradient Overlay Bevel Emboss Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ty integer Type Style Type Style types: ty Type 5 Bevel Emboss 7 Color Overlay 1 Drop Shadow 8 Gradient Overlay 4 Inner Glow 2 Inner Shadow 3 Outer Glow 6 Satin 0 Layer Stroke","title":"Layer Style"},{"location":"effects/#stroke-style","text":"Composition Diagram for Layer Stroke Layer Stroke Layer Style Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ty integer = 0 Type Layer Type s Scalar Size Size c Color Color Color","title":"Stroke Style"},{"location":"effects/#drop-shadow-style","text":"Composition Diagram for Drop Shadow Drop Shadow Layer Style Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ty integer = 1 Type Layer Type c Color Color Color o Scalar Opacity Opacity a Scalar Angle Local light angle s Scalar Size Blur size d Scalar Distance Distance ch Scalar Choke Spread Choke Spread bm Scalar Blend Mode Blend Mode no Scalar Noise Noise lc Scalar Layer Conceal Layer knowck out drop shadow","title":"Drop Shadow Style"},{"location":"effects/#inner-shadow-style","text":"Composition Diagram for Inner Shadow Inner Shadow Layer Style Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ty integer = 2 Type Layer Type c Color Color Color o Scalar Opacity Opacity a Scalar Angle Local light angle s Scalar Size Blur size d Scalar Distance Distance ch Scalar Choke Spread Choke Spread bm Scalar Blend Mode Blend Mode no Scalar Noise Noise","title":"Inner Shadow Style"},{"location":"effects/#outer-glow-style","text":"Composition Diagram for Outer Glow Outer Glow Layer Style Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ty integer = 3 Type Layer Type c Color Color Color o Scalar Opacity Opacity r Scalar Range Range ch Scalar Choke Spread Choke Spread bm Scalar Blend Mode Blend Mode no Scalar Noise Noise j Scalar Jitter Jitter","title":"Outer Glow Style"},{"location":"effects/#inner-glow-style","text":"Composition Diagram for Inner Glow Inner Glow Layer Style Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ty integer = 4 Type Layer Type c Color Color Color o Scalar Opacity Opacity r Scalar Range Range sr Scalar Source Source ch Scalar Choke Spread Choke Spread bm Scalar Blend Mode Blend Mode no Scalar Noise Noise j Scalar Jitter Jitter","title":"Inner Glow Style"},{"location":"effects/#bevel-emboss-style","text":"Composition Diagram for Bevel Emboss Bevel Emboss Layer Style Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ty integer = 5 Type Layer Type bs Scalar Bevel Style Bevel Style bt Scalar Technique Technique sr Scalar Strength Strength s Scalar Size Size sf Scalar Soften Soften ga Scalar Global Angle Use global light a Scalar Angle Local lighting angle ll Scalar Altitude Local lighting altitude hm Scalar Highlight Mode Highlight Mode hc Color Highlight Color Highlight Color ho Scalar Highlight Opacity Highlight Opacity sm Scalar Shadow Mode Shadow Mode sc Color Shadow Color Shadow Color so Scalar Shadow Opacity Shadow Opacity","title":"Bevel / Emboss Style"},{"location":"effects/#satin-style","text":"Composition Diagram for Satin Satin Layer Style Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ty integer = 6 Type Layer Type bm Scalar Blend Mode Blend Mode c Color Color Color o Scalar Opacity Opacity a Scalar Angle Angle d Scalar Distance Distance s Scalar Size Size in Scalar Invert Invert","title":"Satin Style"},{"location":"effects/#color-overlay-style","text":"Composition Diagram for Color Overlay Color Overlay Layer Style Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ty integer = 7 Type Layer Type bm Scalar Blend Mode Blend Mode c Color Color Color so Scalar Opacity Opacity","title":"Color Overlay Style"},{"location":"effects/#gradient-overlay-style","text":"Composition Diagram for Gradient Overlay Gradient Overlay Layer Style Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ty integer = 8 Type Layer Type bm Scalar Blend Mode Blend Mode o Scalar Opacity Opacity gf Gradient Gradient Gradient gs Scalar Smoothness Smoothness a Scalar Angle Angle gt Gradient Type Gradient Type Gradient Type re Scalar Reverse Reverse al Scalar Align Align with layer s Scalar Scale Scale of Scalar Offset Offset","title":"Gradient Overlay Style"},{"location":"expressions/","text":"Expressions Properties can have expressions associated with them, when this is the case the value of such properties can be modified by using the expression. The expression language is based on JavaScript / ECMAScript. For the most part it uses what is described in the After Effects expressions. More resources on AE expressions: Expression Language Reference After Effects Expression Reference Global objects $bm_rt Name $bm_rt Type Depends on the property Description Output value for the expression Notes Must be declared and be assigned a value in every expression The special variable $bm_rt is used to determine the value of the expression. This variable must be declared by the expression and must have a value compatible with the property; var $bm_rt; $bm_rt = 60; Rotation Expression var $bm_rt = 60; var $bm_rt = 60; Position Expression var $bm_rt = [256, 256]; var $bm_rt = [256, 256]; var lottie_player_18 = new PlaygroundPlayer( 18, 'playground_18_3', 'lottie_target_18', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"nm\": \"foo\", \"mn\": \"bar\", \"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [256, 256], \"a\": 0}, \"p\": {\"k\": [256, 256], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ks.r.x = data[\"Rotation Expression\"]; lottie.layers[0].ks.p.x = data[\"Position Expression\"]; this.json_viewer_contents = lottie.layers[0].ks; }, {} ); time Name time Type number Description The current time within the composition in seconds Notes Read only Rotation Expression var $bm_rt = time * 360; var $bm_rt = time * 360; var lottie_player_19 = new PlaygroundPlayer( 19, 'playground_19_2', 'lottie_target_19', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"nm\": \"foo\", \"mn\": \"bar\", \"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [256, 256], \"a\": 0}, \"p\": {\"k\": [256, 256], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ks.r.x = data[\"Rotation Expression\"]; this.json_viewer_contents = lottie.layers[0].ks.r; }, {} ); value Name value Type Depends on the property Description The value the property would have without expressions Notes Read only Position Expression var $bm_rt = []; $bm_rt[0] = value[0] + Math.cos(2 * Math.PI * time) * 100; $bm_rt[1] = value[1]; var $bm_rt = []; $bm_rt[0] = value[0] + Math.cos(2 * Math.PI * time) * 100; $bm_rt[1] = value[1]; var lottie_player_20 = new PlaygroundPlayer( 20, 'playground_20_2', 'lottie_target_20', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"nm\": \"foo\", \"mn\": \"bar\", \"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [256, 256], \"a\": 0}, \"p\": {\"k\": [256, 256], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ks.p.x = data[\"Position Expression\"]; this.json_viewer_contents = lottie.layers[0].ks.p; }, {} ); thisProperty Name thisProperty Type Property Description Property the expression is operating on Notes Read only thisComp Name thisComp Type Composition Description Composition the property is in Notes Read only thisLayer Name thisLayer Type Layer Description Layer the property is in Notes Read only Animation Structure functions comp() Synopsis comp ( name: string ): Composition Parameters Name Type Default Description name string Composition name Return Type Composition Description Composition object matching the given name Misc Functions posterizeTime() Synopsis posterizeTime ( fps: number ) The rest of the expression will only be updated this many times per second Parameters Name Type Default Description fps number Frames per second timeToFrames() Synopsis timeToFrames ( time: number = time + thisComp.displayStartTime fps: number = 1.0 / thisComp.frameDuration ): number Converts a time in seconds to a number of frames Parameters Name Type Default Description time number time + thisComp.displayStartTime Time in seconds fps number 1.0 / thisComp.frameDuration Frames per second Return Type number Description Number of frames framesToTime() Synopsis framesToTime ( frames: number fps: number = 1.0 / thisComp.frameDuration ): number Converts a number of frames to a time in seconds Parameters Name Type Default Description frames number Number of frames fps number 1.0 / thisComp.frameDuration Frames per second Return Type number Description Time in seconds rgbToHsl() Synopsis rgbToHsl ( rgb: array[3]|array[4] ): array[3]|array[4] Parameters Name Type Default Description rgb array[3] | array[4] RGB(A) color, with components in 0, 1 Return Type array[3] | array[4] Description HSL(A) color, with components in 0, 1 hslToRgb() Synopsis hslToRgb ( hsl: array[3]|array[4] ): array[3]|array[4] Parameters Name Type Default Description hsl array[3] | array[4] HSL(A) color, with components in 0, 1 Return Type array[3] | array[4] Description RGB(A) color, with components in 0, 1 createPath() Synopsis createPath ( points: array in_tangents: array = [] out_tangents: array = [] is_closed: boolean = true ): Path Creates bezier path data Parameters Name Type Default Description points array Array of points (each point is a list with 2 numbers) in_tangents array [] Array of in tangents correponding to the point with the same index out_tangents array [] Array of out tangents correponding to the point with the same index is_closed boolean true Whether the path is closed Return Type Path Math functions add() Synopsis add ( a: any b: any ): any Parameters Name Type Default Description a any b any Return Type any If a and b are numbers, it will return their sum. If they string, their concatenation. If they are vectors, their element-wise sum. If one is a vector and the other a number, it will return the sum of the number by the first element of the vector. This function is also available as $bm_sum and sum . sub() Synopsis sub ( a: any b: any ): any Parameters Name Type Default Description a any b any Return Type any If a and b are numbers, or can be converted to numbers, it will return their difference. If they are vectors, their element-wise difference. This function is also avilable as $bm_sub . mul() Synopsis mul ( a: any b: any ): any Parameters Name Type Default Description a any b any Return Type any If a and b are numbers, or can be converted to numbers, it will return their product. If one of them is a vector and the other a number, it will return a vector with each element multiplied by the number. This function is also avilable as $bm_mul . div() Synopsis div ( a: any b: any ): any Parameters Name Type Default Description a any b any Return Type any If a and b are numbers, or can be converted to numbers, it will return their division. If one of them is a vector and the other a number, it will return a vector with each element divided by the number. This function is also avilable as $bm_div . mod() Synopsis mod ( a: any b: any ): any Parameters Name Type Default Description a any b any Return Type any clamp() Synopsis clamp ( value: number minimum: number maximum: number ): number Clamps a value inside a range Parameters Name Type Default Description value number The value to clamp minimum number Minimum value maximum number Maximum value Return Type number normalize() Synopsis normalize ( vector: array ): number Divides a vector by its length Parameters Name Type Default Description vector array Return Type number Description same as div(vector, length(vector)) length() Synopsis length ( vector: array ): number Parameters Name Type Default Description vector array Return Type number Description length of vector Synopsis length ( a: array b: array ): number Parameters Name Type Default Description a array b array Return Type number Description Distance between a and b . looAt() Synopsis lookAt ( from_point: array[3] to_point: array[3] ): number Parameters Name Type Default Description from_point array[3] to_point array[3] Return Type number Description length of vector seedRandom() Synopsis seedRandom ( seed: number ) Sets the seed for random functions Parameters Name Type Default Description seed number random() Synopsis random (): number Return Type number Description Random number between 0 and 1 Synopsis random ( max: number|array ): number|array Parameters Name Type Default Description max number | array Return Type number | array Description Random number between 0 and max , element wise if the argument is an array Synopsis random ( min: number|array max: number|array ): number|array Parameters Name Type Default Description min number | array max number | array Return Type number | array Description Random number between min and max , element wise if the arguments are arrays linear() Synopsis linear ( t: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between 0 and 1 value1 number | array value2 number | array Return Type number | array Description Linear interpolation between value1 and value2 Synopsis linear ( t: number t_min: number t_max: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between t_min and t_max t_min number Lower bound for the t range t_max number Lower bound for the t range value1 number | array value2 number | array Return Type number | array Description Linear interpolation between value1 and value2 , t is first normalized inside t_min and t_max ease() Works the same as linear() but with a smooth cubic interpolation. Synopsis ease ( t: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between 0 and 1 value1 number | array value2 number | array Return Type number | array Description Interpolation between value1 and value2 Synopsis ease ( t: number t_min: number t_max: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between t_min and t_max t_min number Lower bound for the t range t_max number Lower bound for the t range value1 number | array value2 number | array Return Type number | array Description Interpolation between value1 and value2 , t is first normalized inside t_min and t_max easeIn() Interpolation, starts the same as ease() and ends the same as linear() Synopsis easeIn ( t: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between 0 and 1 value1 number | array value2 number | array Return Type number | array Description Interpolation between value1 and value2 Synopsis easeIn ( t: number t_min: number t_max: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between t_min and t_max t_min number Lower bound for the t range t_max number Lower bound for the t range value1 number | array value2 number | array Return Type number | array Description Interpolation between value1 and value2 , t is first normalized inside t_min and t_max easeOut() Interpolation, starts the same as linear() and ends the same as ease() Synopsis easeOut ( t: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between 0 and 1 value1 number | array value2 number | array Return Type number | array Description Interpolation between value1 and value2 Synopsis easeOut ( t: number t_min: number t_max: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between t_min and t_max t_min number Lower bound for the t range t_max number Lower bound for the t range value1 number | array value2 number | array Return Type number | array Description Interpolation between value1 and value2 , t is first normalized inside t_min and t_max degreesToRadians() Synopsis degreesToRadians ( degrees: number ): number Parameters Name Type Default Description degrees number Angle in degrees Return Type number Description Angle in radians radiansToDegrees() Synopsis radiansToDegrees ( radians: number ): number Parameters Name Type Default Description radians number Angle in radians Return Type number Description Angle in degrees Property Property.value Name value Type Depends on the property Description The current value the property Notes Read only Property.numKeys Name numKeys Type number Description Number of keyframes Notes Read only Property.propertyIndex Name propertyIndex Type number Description Value of ix in the JSON for this property Notes Read only Property.valueAtTime() Synopsis valueAtTime ( t: number ): any Parameters Name Type Default Description t number Time in seconds Return Type Depends on the property Description The value of the property at the given time (without expressions) Property.getVelocityAtTime() Synopsis getVelocityAtTime ( t: number ): any Parameters Name Type Default Description t number Time in seconds Return Type Depends on the property Description The rate of change for the property, with the same dimensions as the value Property.getSpeedAtTime() Synopsis getSpeedAtTime ( t: number ): number Parameters Name Type Default Description t number Time in seconds Return Type number Description The rate of change for the property as a scalar Property.smooth() Synopsis smooth ( width: number samples: number ): any Parameters Name Type Default Description width number samples number Return Type Depends on the property Property.loopIn() Synopsis loopIn ( type: string duration: number wrap: boolean ): any Parameters Name Type Default Description type string duration number wrap boolean Return Type Depends on the property Property.loopOut() Synopsis loopOut ( type: string duration: number wrap: boolean ): any Parameters Name Type Default Description type string duration number wrap boolean Return Type Depends on the property Composition Composition object Position Expression var $bm_rt = [256, 256] var rotation = comp(\"Animation\").layer(\"Layer\").transform.rotation / 180 * Math.PI; $bm_rt[0] += Math.cos(rotation) * 200; $bm_rt[1] += Math.sin(rotation) * 200; var $bm_rt = [256, 256] var rotation = comp(\"Animation\").layer(\"Layer\").transform.rotation / 180 * Math.PI; $bm_rt[0] += Math.cos(rotation) * 200; $bm_rt[1] += Math.sin(rotation) * 200; var lottie_player_21 = new PlaygroundPlayer( 21, 'playground_21_2', 'lottie_target_21', {\"v\": \"5.5.2\", \"nm\": \"Animation\", \"fr\": 60, \"ip\": 0, \"op\": 180, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}, {\"id\": \"precomp0\", \"nm\": \"Precomp\", \"layers\": []}], \"layers\": [{\"nm\": \"Layer\", \"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"nm\": \"Transform\", \"a\": {\"k\": [256, 256], \"a\": 0}, \"p\": {\"k\": [256, 256], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"nm\": \"Rotation\", \"ix\": 123, \"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"i\": {\"x\": [1], \"y\": [1]}, \"o\": {\"x\": [1], \"y\": [1]}}, {\"t\": 180, \"s\": [360]}]}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 180, \"st\": 0, \"bm\": 0, \"ind\": 0, \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ks.p.x = data[\"Position Expression\"]; this.json_viewer_contents = lottie.layers[0].ks.p; }, {} ); As a function As a function a composition object can give you access to the layers by name or index Position Expression var $bm_rt = [256, 256] var rotation = thisComp(\"Layer\").transform.rotation / 180 * Math.PI; $bm_rt[0] += Math.cos(rotation) * 200; $bm_rt[1] += Math.sin(rotation) * 200; var $bm_rt = [256, 256] var rotation = thisComp(\"Layer\").transform.rotation / 180 * Math.PI; $bm_rt[0] += Math.cos(rotation) * 200; $bm_rt[1] += Math.sin(rotation) * 200; var lottie_player_22 = new PlaygroundPlayer( 22, 'playground_22_2', 'lottie_target_22', {\"v\": \"5.5.2\", \"nm\": \"Animation\", \"fr\": 60, \"ip\": 0, \"op\": 180, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}, {\"id\": \"precomp0\", \"nm\": \"Precomp\", \"layers\": []}], \"layers\": [{\"nm\": \"Layer\", \"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"nm\": \"Transform\", \"a\": {\"k\": [256, 256], \"a\": 0}, \"p\": {\"k\": [256, 256], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"nm\": \"Rotation\", \"ix\": 123, \"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"i\": {\"x\": [1], \"y\": [1]}, \"o\": {\"x\": [1], \"y\": [1]}}, {\"t\": 180, \"s\": [360]}]}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 180, \"st\": 0, \"bm\": 0, \"ind\": 0, \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ks.p.x = data[\"Position Expression\"]; this.json_viewer_contents = lottie.layers[0].ks.p; }, {} ); Composition.numLayers Name numLayers Type number Description Number of layers in the composition Composition.width Name width Type number Description Width of the composition, same as w in the JSON Composition.height Name height Type number Description Height of the composition, same as h in the JSON Composition.displayStartTime Name displayStartTime Type number Description Start time of the composition, in seconds. Similar to ip in the JSON but converted into seconds Composition.frameDuration Name frameDuration Type number Description Duration of a frame in second, reciprocal of frames per second Composition.pixelAspect Name pixelAspect Type number Description Pixel aspect ratio, generally 1 Composition.layer() Synopsis layer ( layer: number|string ): Layer Returns the given layer Parameters Name Type Default Description layer number | string Layer name or index Return Type Layer Layer Layer object. Note that it also has all the attributes from Transform . Layer.index Name index Type number Description Layer index, same as ind in the JSON Layer.inPoint Name inPoint Type number Description Same as ip in the JSON but in seconds Layer.outPoint Name outPoint Type number Description Same as op in the JSON but in seconds Layer.startTime Name startTime Type number Description Same as st in the JSON but in seconds Layer.transform Transform attributes can also be accessed from the layer object directly Name transofrm Type Transform Description Layer.source Name source Type string Description For layers referencing an asset, the id of that asses. (Same as refId in the JSON) Layer.width Name width Type number Description Same as Layer.sourceRectAtTime().width Layer.height Name height Type number Description Same as Layer.sourceRectAtTime().height Layer.hasParent Name hasParent Type boolean Description Whether the layer has a parent Layer.parent Name parent Type Layer Description Parent layer Layer.sourceRectAtTime Synopsis sourceRectAtTime (): object Return Type object Description Object with these attributes Layer.effect Synopsis effect ( effect: number|string ): Effect Returns the given effect Parameters Name Type Default Description effect number | string Name or index Return Type Effect Layer.contents Synopsis contents ( shape: number|string ): Shape For shape layers, returns the given shape Parameters Name Type Default Description shape number | string Name or index Return Type Shape Layer space transforms These methods convert between coordinates systems within a layer. Some of these functions have a Vec suffix, which means they should be used for difference between points (the version without this suffix is for points). Layer.toComp Synopsis toComp ( point: Array time: number = time ): Array Maps a point from Layer coordinates to composition coordinates Parameters Name Type Default Description point Array Point time number time Time Return Type Array Layer.fromComp Synopsis toComp ( point: Array time: number = time ): Array Maps a point from composition coordinates to Layer coordinates Parameters Name Type Default Description point Array Point time number time Time Return Type Array Layer.toCompVec Synopsis toComp ( point: Array time: number = time ): Array Maps a vector from Layer coordinates to composition coordinates Parameters Name Type Default Description point Array Vector time number time Time Return Type Array Layer.fromCompVec Synopsis toComp ( point: Array time: number = time ): Array Maps a vector from composition coordinates to Layer coordinates Parameters Name Type Default Description point Array Vector time number time Time Return Type Array Layer.toWorld Synopsis toWorld ( point: Array time: number = time ): Array Maps a point from Layer coordinates to world coordinates Parameters Name Type Default Description point Array Point time number time Time Return Type Array Layer.fromWorld Synopsis toWorld ( point: Array time: number = time ): Array Maps a point from world coordinates to Layer coordinates Parameters Name Type Default Description point Array Point time number time Time Return Type Array Layer.toWorldVec Synopsis toWorld ( point: Array time: number = time ): Array Maps a vector from Layer coordinates to world coordinates Parameters Name Type Default Description point Array Vector time number time Time Return Type Array Layer.fromWorldVec Synopsis toWorld ( point: Array time: number = time ): Array Maps a vector from world coordinates to Layer coordinates Parameters Name Type Default Description point Array Vector time number time Time Return Type Array Transform Name anchorPoint Type array[2] Description Value of a Name position Type array[2] Description Value of p Name scale Type number Description Value of s Name rotation Type number Description Value of r Name opacity Type number Description Value of o Name skew Type number Description Value of sk Name skewAxis Type number Description Value of sa Effect Name active Type boolean Description Whether the effect is active Effect() Synopsis ( property: number|string ): number|Array Returns the value for the given property of the effect Parameters Name Type Default Description property number | string Name or index of the property Return Type number | Array","title":"Expressions"},{"location":"expressions/#expressions","text":"Properties can have expressions associated with them, when this is the case the value of such properties can be modified by using the expression. The expression language is based on JavaScript / ECMAScript. For the most part it uses what is described in the After Effects expressions. More resources on AE expressions: Expression Language Reference After Effects Expression Reference","title":"Expressions"},{"location":"expressions/#global-objects","text":"","title":"Global objects"},{"location":"expressions/#bm_rt","text":"Name $bm_rt Type Depends on the property Description Output value for the expression Notes Must be declared and be assigned a value in every expression The special variable $bm_rt is used to determine the value of the expression. This variable must be declared by the expression and must have a value compatible with the property; var $bm_rt; $bm_rt = 60; Rotation Expression var $bm_rt = 60; var $bm_rt = 60; Position Expression var $bm_rt = [256, 256]; var $bm_rt = [256, 256]; var lottie_player_18 = new PlaygroundPlayer( 18, 'playground_18_3', 'lottie_target_18', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"nm\": \"foo\", \"mn\": \"bar\", \"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [256, 256], \"a\": 0}, \"p\": {\"k\": [256, 256], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ks.r.x = data[\"Rotation Expression\"]; lottie.layers[0].ks.p.x = data[\"Position Expression\"]; this.json_viewer_contents = lottie.layers[0].ks; }, {} );","title":"$bm_rt"},{"location":"expressions/#time","text":"Name time Type number Description The current time within the composition in seconds Notes Read only Rotation Expression var $bm_rt = time * 360; var $bm_rt = time * 360; var lottie_player_19 = new PlaygroundPlayer( 19, 'playground_19_2', 'lottie_target_19', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"nm\": \"foo\", \"mn\": \"bar\", \"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [256, 256], \"a\": 0}, \"p\": {\"k\": [256, 256], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ks.r.x = data[\"Rotation Expression\"]; this.json_viewer_contents = lottie.layers[0].ks.r; }, {} );","title":"time"},{"location":"expressions/#value","text":"Name value Type Depends on the property Description The value the property would have without expressions Notes Read only Position Expression var $bm_rt = []; $bm_rt[0] = value[0] + Math.cos(2 * Math.PI * time) * 100; $bm_rt[1] = value[1]; var $bm_rt = []; $bm_rt[0] = value[0] + Math.cos(2 * Math.PI * time) * 100; $bm_rt[1] = value[1]; var lottie_player_20 = new PlaygroundPlayer( 20, 'playground_20_2', 'lottie_target_20', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"nm\": \"foo\", \"mn\": \"bar\", \"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [256, 256], \"a\": 0}, \"p\": {\"k\": [256, 256], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ks.p.x = data[\"Position Expression\"]; this.json_viewer_contents = lottie.layers[0].ks.p; }, {} );","title":"value"},{"location":"expressions/#thisproperty","text":"Name thisProperty Type Property Description Property the expression is operating on Notes Read only","title":"thisProperty"},{"location":"expressions/#thiscomp","text":"Name thisComp Type Composition Description Composition the property is in Notes Read only","title":"thisComp"},{"location":"expressions/#thislayer","text":"Name thisLayer Type Layer Description Layer the property is in Notes Read only","title":"thisLayer"},{"location":"expressions/#animation-structure-functions","text":"","title":"Animation Structure functions"},{"location":"expressions/#comp","text":"Synopsis comp ( name: string ): Composition Parameters Name Type Default Description name string Composition name Return Type Composition Description Composition object matching the given name","title":"comp()"},{"location":"expressions/#misc-functions","text":"","title":"Misc Functions"},{"location":"expressions/#posterizetime","text":"Synopsis posterizeTime ( fps: number ) The rest of the expression will only be updated this many times per second Parameters Name Type Default Description fps number Frames per second","title":"posterizeTime()"},{"location":"expressions/#timetoframes","text":"Synopsis timeToFrames ( time: number = time + thisComp.displayStartTime fps: number = 1.0 / thisComp.frameDuration ): number Converts a time in seconds to a number of frames Parameters Name Type Default Description time number time + thisComp.displayStartTime Time in seconds fps number 1.0 / thisComp.frameDuration Frames per second Return Type number Description Number of frames","title":"timeToFrames()"},{"location":"expressions/#framestotime","text":"Synopsis framesToTime ( frames: number fps: number = 1.0 / thisComp.frameDuration ): number Converts a number of frames to a time in seconds Parameters Name Type Default Description frames number Number of frames fps number 1.0 / thisComp.frameDuration Frames per second Return Type number Description Time in seconds","title":"framesToTime()"},{"location":"expressions/#rgbtohsl","text":"Synopsis rgbToHsl ( rgb: array[3]|array[4] ): array[3]|array[4] Parameters Name Type Default Description rgb array[3] | array[4] RGB(A) color, with components in 0, 1 Return Type array[3] | array[4] Description HSL(A) color, with components in 0, 1","title":"rgbToHsl()"},{"location":"expressions/#hsltorgb","text":"Synopsis hslToRgb ( hsl: array[3]|array[4] ): array[3]|array[4] Parameters Name Type Default Description hsl array[3] | array[4] HSL(A) color, with components in 0, 1 Return Type array[3] | array[4] Description RGB(A) color, with components in 0, 1","title":"hslToRgb()"},{"location":"expressions/#createpath","text":"Synopsis createPath ( points: array in_tangents: array = [] out_tangents: array = [] is_closed: boolean = true ): Path Creates bezier path data Parameters Name Type Default Description points array Array of points (each point is a list with 2 numbers) in_tangents array [] Array of in tangents correponding to the point with the same index out_tangents array [] Array of out tangents correponding to the point with the same index is_closed boolean true Whether the path is closed Return Type Path","title":"createPath()"},{"location":"expressions/#math-functions","text":"","title":"Math functions"},{"location":"expressions/#add","text":"Synopsis add ( a: any b: any ): any Parameters Name Type Default Description a any b any Return Type any If a and b are numbers, it will return their sum. If they string, their concatenation. If they are vectors, their element-wise sum. If one is a vector and the other a number, it will return the sum of the number by the first element of the vector. This function is also available as $bm_sum and sum .","title":"add()"},{"location":"expressions/#sub","text":"Synopsis sub ( a: any b: any ): any Parameters Name Type Default Description a any b any Return Type any If a and b are numbers, or can be converted to numbers, it will return their difference. If they are vectors, their element-wise difference. This function is also avilable as $bm_sub .","title":"sub()"},{"location":"expressions/#mul","text":"Synopsis mul ( a: any b: any ): any Parameters Name Type Default Description a any b any Return Type any If a and b are numbers, or can be converted to numbers, it will return their product. If one of them is a vector and the other a number, it will return a vector with each element multiplied by the number. This function is also avilable as $bm_mul .","title":"mul()"},{"location":"expressions/#div","text":"Synopsis div ( a: any b: any ): any Parameters Name Type Default Description a any b any Return Type any If a and b are numbers, or can be converted to numbers, it will return their division. If one of them is a vector and the other a number, it will return a vector with each element divided by the number. This function is also avilable as $bm_div .","title":"div()"},{"location":"expressions/#mod","text":"Synopsis mod ( a: any b: any ): any Parameters Name Type Default Description a any b any Return Type any","title":"mod()"},{"location":"expressions/#clamp","text":"Synopsis clamp ( value: number minimum: number maximum: number ): number Clamps a value inside a range Parameters Name Type Default Description value number The value to clamp minimum number Minimum value maximum number Maximum value Return Type number","title":"clamp()"},{"location":"expressions/#normalize","text":"Synopsis normalize ( vector: array ): number Divides a vector by its length Parameters Name Type Default Description vector array Return Type number Description same as div(vector, length(vector))","title":"normalize()"},{"location":"expressions/#length","text":"Synopsis length ( vector: array ): number Parameters Name Type Default Description vector array Return Type number Description length of vector Synopsis length ( a: array b: array ): number Parameters Name Type Default Description a array b array Return Type number Description Distance between a and b .","title":"length()"},{"location":"expressions/#looat","text":"Synopsis lookAt ( from_point: array[3] to_point: array[3] ): number Parameters Name Type Default Description from_point array[3] to_point array[3] Return Type number Description length of vector","title":"looAt()"},{"location":"expressions/#seedrandom","text":"Synopsis seedRandom ( seed: number ) Sets the seed for random functions Parameters Name Type Default Description seed number","title":"seedRandom()"},{"location":"expressions/#random","text":"Synopsis random (): number Return Type number Description Random number between 0 and 1 Synopsis random ( max: number|array ): number|array Parameters Name Type Default Description max number | array Return Type number | array Description Random number between 0 and max , element wise if the argument is an array Synopsis random ( min: number|array max: number|array ): number|array Parameters Name Type Default Description min number | array max number | array Return Type number | array Description Random number between min and max , element wise if the arguments are arrays","title":"random()"},{"location":"expressions/#linear","text":"Synopsis linear ( t: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between 0 and 1 value1 number | array value2 number | array Return Type number | array Description Linear interpolation between value1 and value2 Synopsis linear ( t: number t_min: number t_max: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between t_min and t_max t_min number Lower bound for the t range t_max number Lower bound for the t range value1 number | array value2 number | array Return Type number | array Description Linear interpolation between value1 and value2 , t is first normalized inside t_min and t_max","title":"linear()"},{"location":"expressions/#ease","text":"Works the same as linear() but with a smooth cubic interpolation. Synopsis ease ( t: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between 0 and 1 value1 number | array value2 number | array Return Type number | array Description Interpolation between value1 and value2 Synopsis ease ( t: number t_min: number t_max: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between t_min and t_max t_min number Lower bound for the t range t_max number Lower bound for the t range value1 number | array value2 number | array Return Type number | array Description Interpolation between value1 and value2 , t is first normalized inside t_min and t_max","title":"ease()"},{"location":"expressions/#easein","text":"Interpolation, starts the same as ease() and ends the same as linear() Synopsis easeIn ( t: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between 0 and 1 value1 number | array value2 number | array Return Type number | array Description Interpolation between value1 and value2 Synopsis easeIn ( t: number t_min: number t_max: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between t_min and t_max t_min number Lower bound for the t range t_max number Lower bound for the t range value1 number | array value2 number | array Return Type number | array Description Interpolation between value1 and value2 , t is first normalized inside t_min and t_max","title":"easeIn()"},{"location":"expressions/#easeout","text":"Interpolation, starts the same as linear() and ends the same as ease() Synopsis easeOut ( t: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between 0 and 1 value1 number | array value2 number | array Return Type number | array Description Interpolation between value1 and value2 Synopsis easeOut ( t: number t_min: number t_max: number value1: number|array value2: number|array ): number|array Parameters Name Type Default Description t number Interpolation factor between t_min and t_max t_min number Lower bound for the t range t_max number Lower bound for the t range value1 number | array value2 number | array Return Type number | array Description Interpolation between value1 and value2 , t is first normalized inside t_min and t_max","title":"easeOut()"},{"location":"expressions/#degreestoradians","text":"Synopsis degreesToRadians ( degrees: number ): number Parameters Name Type Default Description degrees number Angle in degrees Return Type number Description Angle in radians","title":"degreesToRadians()"},{"location":"expressions/#radianstodegrees","text":"Synopsis radiansToDegrees ( radians: number ): number Parameters Name Type Default Description radians number Angle in radians Return Type number Description Angle in degrees","title":"radiansToDegrees()"},{"location":"expressions/#property","text":"","title":"Property"},{"location":"expressions/#propertyvalue","text":"Name value Type Depends on the property Description The current value the property Notes Read only","title":"Property.value"},{"location":"expressions/#propertynumkeys","text":"Name numKeys Type number Description Number of keyframes Notes Read only","title":"Property.numKeys"},{"location":"expressions/#propertypropertyindex","text":"Name propertyIndex Type number Description Value of ix in the JSON for this property Notes Read only","title":"Property.propertyIndex"},{"location":"expressions/#propertyvalueattime","text":"Synopsis valueAtTime ( t: number ): any Parameters Name Type Default Description t number Time in seconds Return Type Depends on the property Description The value of the property at the given time (without expressions)","title":"Property.valueAtTime()"},{"location":"expressions/#propertygetvelocityattime","text":"Synopsis getVelocityAtTime ( t: number ): any Parameters Name Type Default Description t number Time in seconds Return Type Depends on the property Description The rate of change for the property, with the same dimensions as the value","title":"Property.getVelocityAtTime()"},{"location":"expressions/#propertygetspeedattime","text":"Synopsis getSpeedAtTime ( t: number ): number Parameters Name Type Default Description t number Time in seconds Return Type number Description The rate of change for the property as a scalar","title":"Property.getSpeedAtTime()"},{"location":"expressions/#propertysmooth","text":"Synopsis smooth ( width: number samples: number ): any Parameters Name Type Default Description width number samples number Return Type Depends on the property","title":"Property.smooth()"},{"location":"expressions/#propertyloopin","text":"Synopsis loopIn ( type: string duration: number wrap: boolean ): any Parameters Name Type Default Description type string duration number wrap boolean Return Type Depends on the property","title":"Property.loopIn()"},{"location":"expressions/#propertyloopout","text":"Synopsis loopOut ( type: string duration: number wrap: boolean ): any Parameters Name Type Default Description type string duration number wrap boolean Return Type Depends on the property","title":"Property.loopOut()"},{"location":"expressions/#composition","text":"Composition object Position Expression var $bm_rt = [256, 256] var rotation = comp(\"Animation\").layer(\"Layer\").transform.rotation / 180 * Math.PI; $bm_rt[0] += Math.cos(rotation) * 200; $bm_rt[1] += Math.sin(rotation) * 200; var $bm_rt = [256, 256] var rotation = comp(\"Animation\").layer(\"Layer\").transform.rotation / 180 * Math.PI; $bm_rt[0] += Math.cos(rotation) * 200; $bm_rt[1] += Math.sin(rotation) * 200; var lottie_player_21 = new PlaygroundPlayer( 21, 'playground_21_2', 'lottie_target_21', {\"v\": \"5.5.2\", \"nm\": \"Animation\", \"fr\": 60, \"ip\": 0, \"op\": 180, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}, {\"id\": \"precomp0\", \"nm\": \"Precomp\", \"layers\": []}], \"layers\": [{\"nm\": \"Layer\", \"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"nm\": \"Transform\", \"a\": {\"k\": [256, 256], \"a\": 0}, \"p\": {\"k\": [256, 256], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"nm\": \"Rotation\", \"ix\": 123, \"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"i\": {\"x\": [1], \"y\": [1]}, \"o\": {\"x\": [1], \"y\": [1]}}, {\"t\": 180, \"s\": [360]}]}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 180, \"st\": 0, \"bm\": 0, \"ind\": 0, \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ks.p.x = data[\"Position Expression\"]; this.json_viewer_contents = lottie.layers[0].ks.p; }, {} );","title":"Composition"},{"location":"expressions/#as-a-function","text":"As a function a composition object can give you access to the layers by name or index Position Expression var $bm_rt = [256, 256] var rotation = thisComp(\"Layer\").transform.rotation / 180 * Math.PI; $bm_rt[0] += Math.cos(rotation) * 200; $bm_rt[1] += Math.sin(rotation) * 200; var $bm_rt = [256, 256] var rotation = thisComp(\"Layer\").transform.rotation / 180 * Math.PI; $bm_rt[0] += Math.cos(rotation) * 200; $bm_rt[1] += Math.sin(rotation) * 200; var lottie_player_22 = new PlaygroundPlayer( 22, 'playground_22_2', 'lottie_target_22', {\"v\": \"5.5.2\", \"nm\": \"Animation\", \"fr\": 60, \"ip\": 0, \"op\": 180, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}, {\"id\": \"precomp0\", \"nm\": \"Precomp\", \"layers\": []}], \"layers\": [{\"nm\": \"Layer\", \"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"nm\": \"Transform\", \"a\": {\"k\": [256, 256], \"a\": 0}, \"p\": {\"k\": [256, 256], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"nm\": \"Rotation\", \"ix\": 123, \"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"i\": {\"x\": [1], \"y\": [1]}, \"o\": {\"x\": [1], \"y\": [1]}}, {\"t\": 180, \"s\": [360]}]}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 180, \"st\": 0, \"bm\": 0, \"ind\": 0, \"refId\": \"blep\"}]}, function (lottie, data) { lottie.layers[0].ks.p.x = data[\"Position Expression\"]; this.json_viewer_contents = lottie.layers[0].ks.p; }, {} );","title":"As a function"},{"location":"expressions/#compositionnumlayers","text":"Name numLayers Type number Description Number of layers in the composition","title":"Composition.numLayers"},{"location":"expressions/#compositionwidth","text":"Name width Type number Description Width of the composition, same as w in the JSON","title":"Composition.width"},{"location":"expressions/#compositionheight","text":"Name height Type number Description Height of the composition, same as h in the JSON","title":"Composition.height"},{"location":"expressions/#compositiondisplaystarttime","text":"Name displayStartTime Type number Description Start time of the composition, in seconds. Similar to ip in the JSON but converted into seconds","title":"Composition.displayStartTime"},{"location":"expressions/#compositionframeduration","text":"Name frameDuration Type number Description Duration of a frame in second, reciprocal of frames per second","title":"Composition.frameDuration"},{"location":"expressions/#compositionpixelaspect","text":"Name pixelAspect Type number Description Pixel aspect ratio, generally 1","title":"Composition.pixelAspect"},{"location":"expressions/#compositionlayer","text":"Synopsis layer ( layer: number|string ): Layer Returns the given layer Parameters Name Type Default Description layer number | string Layer name or index Return Type Layer","title":"Composition.layer()"},{"location":"expressions/#layer","text":"Layer object. Note that it also has all the attributes from Transform .","title":"Layer"},{"location":"expressions/#layerindex","text":"Name index Type number Description Layer index, same as ind in the JSON","title":"Layer.index"},{"location":"expressions/#layerinpoint","text":"Name inPoint Type number Description Same as ip in the JSON but in seconds","title":"Layer.inPoint"},{"location":"expressions/#layeroutpoint","text":"Name outPoint Type number Description Same as op in the JSON but in seconds","title":"Layer.outPoint"},{"location":"expressions/#layerstarttime","text":"Name startTime Type number Description Same as st in the JSON but in seconds","title":"Layer.startTime"},{"location":"expressions/#layertransform","text":"Transform attributes can also be accessed from the layer object directly Name transofrm Type Transform Description","title":"Layer.transform"},{"location":"expressions/#layersource","text":"Name source Type string Description For layers referencing an asset, the id of that asses. (Same as refId in the JSON)","title":"Layer.source"},{"location":"expressions/#layerwidth","text":"Name width Type number Description Same as Layer.sourceRectAtTime().width","title":"Layer.width"},{"location":"expressions/#layerheight","text":"Name height Type number Description Same as Layer.sourceRectAtTime().height","title":"Layer.height"},{"location":"expressions/#layerhasparent","text":"Name hasParent Type boolean Description Whether the layer has a parent","title":"Layer.hasParent"},{"location":"expressions/#layerparent","text":"Name parent Type Layer Description Parent layer","title":"Layer.parent"},{"location":"expressions/#layersourcerectattime","text":"Synopsis sourceRectAtTime (): object Return Type object Description Object with these attributes","title":"Layer.sourceRectAtTime"},{"location":"expressions/#layereffect","text":"Synopsis effect ( effect: number|string ): Effect Returns the given effect Parameters Name Type Default Description effect number | string Name or index Return Type Effect","title":"Layer.effect"},{"location":"expressions/#layercontents","text":"Synopsis contents ( shape: number|string ): Shape For shape layers, returns the given shape Parameters Name Type Default Description shape number | string Name or index Return Type Shape","title":"Layer.contents"},{"location":"expressions/#layer-space-transforms","text":"These methods convert between coordinates systems within a layer. Some of these functions have a Vec suffix, which means they should be used for difference between points (the version without this suffix is for points).","title":"Layer space transforms"},{"location":"expressions/#layertocomp","text":"Synopsis toComp ( point: Array time: number = time ): Array Maps a point from Layer coordinates to composition coordinates Parameters Name Type Default Description point Array Point time number time Time Return Type Array","title":"Layer.toComp"},{"location":"expressions/#layerfromcomp","text":"Synopsis toComp ( point: Array time: number = time ): Array Maps a point from composition coordinates to Layer coordinates Parameters Name Type Default Description point Array Point time number time Time Return Type Array","title":"Layer.fromComp"},{"location":"expressions/#layertocompvec","text":"Synopsis toComp ( point: Array time: number = time ): Array Maps a vector from Layer coordinates to composition coordinates Parameters Name Type Default Description point Array Vector time number time Time Return Type Array","title":"Layer.toCompVec"},{"location":"expressions/#layerfromcompvec","text":"Synopsis toComp ( point: Array time: number = time ): Array Maps a vector from composition coordinates to Layer coordinates Parameters Name Type Default Description point Array Vector time number time Time Return Type Array","title":"Layer.fromCompVec"},{"location":"expressions/#layertoworld","text":"Synopsis toWorld ( point: Array time: number = time ): Array Maps a point from Layer coordinates to world coordinates Parameters Name Type Default Description point Array Point time number time Time Return Type Array","title":"Layer.toWorld"},{"location":"expressions/#layerfromworld","text":"Synopsis toWorld ( point: Array time: number = time ): Array Maps a point from world coordinates to Layer coordinates Parameters Name Type Default Description point Array Point time number time Time Return Type Array","title":"Layer.fromWorld"},{"location":"expressions/#layertoworldvec","text":"Synopsis toWorld ( point: Array time: number = time ): Array Maps a vector from Layer coordinates to world coordinates Parameters Name Type Default Description point Array Vector time number time Time Return Type Array","title":"Layer.toWorldVec"},{"location":"expressions/#layerfromworldvec","text":"Synopsis toWorld ( point: Array time: number = time ): Array Maps a vector from world coordinates to Layer coordinates Parameters Name Type Default Description point Array Vector time number time Time Return Type Array","title":"Layer.fromWorldVec"},{"location":"expressions/#transform","text":"Name anchorPoint Type array[2] Description Value of a Name position Type array[2] Description Value of p Name scale Type number Description Value of s Name rotation Type number Description Value of r Name opacity Type number Description Value of o Name skew Type number Description Value of sk Name skewAxis Type number Description Value of sa","title":"Transform"},{"location":"expressions/#effect","text":"Name active Type boolean Description Whether the effect is active","title":"Effect"},{"location":"expressions/#effect_1","text":"Synopsis ( property: number|string ): number|Array Returns the value for the given property of the effect Parameters Name Type Default Description property number | string Name or index of the property Return Type number | Array","title":"Effect()"},{"location":"helpers/","text":"Helpers Transform This represents a layer or shape transform. It has the properties from Visual Object and its own properties are all animated : Composition Diagram for Transform Transform Transform Shape Repeater Transform Text Style Attribute Type Title Description a Position Anchor Point Anchor point: a position (relative to its parent) around which transformations are applied (ie: center for rotation / scale) p Splittable Position Position Position / Translation r Scalar Rotation Rotation in degrees, clockwise s Vector Scale Scale factor, [100, 100] for no scaling o Scalar Opacity Opacity sk Scalar Skew Skew amount as an angle in degrees sa Scalar Skew Axis Direction along which skew is applied, in degrees ( 0 skews along the X axis, 90 along the Y axis) rx Scalar X Rotation Split rotation component ry Scalar Y Rotation Split rotation component rz Scalar Z Rotation Split rotation component, equivalent to r when not split or Vector Orientation Orientation To make the anchor point properly line up with the center of location, p and a should have the same value. This example allows you to tweak transform attributes and see how the shape changes. The anchor point is highlighted with an orange dot. Anchor X 256 Anchor Y 256 Position X 256 Position Y 256 Scale X 100 Scale Y 100 Rotation 0 Skew 0 Skew Angle 0 Opacity 100 var lottie_player_23 = new PlaygroundPlayer( 23, 'playground_23_11', 'lottie_target_23', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{a3bb98c7-d0dd-4484-b6da-74a0e70eaf2f}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 2, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Anchor\", \"mn\": \"{04f9b742-3603-49fa-9552-ea04de1a3f33}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{4251e46a-bb13-464b-913c-e67c44a218da}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{7d3070ed-88a3-41aa-a62e-7db8df1bd312}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}]}, {\"ddd\": 0, \"ty\": 4, \"ind\": 1, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Transformed\", \"mn\": \"{d00298c4-66b4-4ae4-a730-22c1eb85c188}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}, \"sk\": {\"a\": 0, \"k\": 0}, \"sa\": {\"a\": 0, \"k\": 0}}, \"shapes\": [{\"ty\": \"rc\", \"nm\": \"Rectangle 1\", \"mn\": \"{bf8ad877-113b-4df8-a2e2-3bb4af32edf7}\", \"p\": {\"a\": 0, \"k\": [252.75223880597017, 250.60298507462684]}, \"s\": {\"a\": 0, \"k\": [319.8089552238806, 330.98507462686564]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"nm\": \"Fill 1\", \"mn\": \"{b9040dc8-0753-4a6e-b5f1-d508d17bbd4f}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}]}, {\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Reference\", \"mn\": \"{8f351be7-8a51-4310-9dc3-59ed21594815}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{cb4f7b74-bed1-493b-a0e6-01b00566aedd}\", \"p\": {\"a\": 0, \"k\": [252.75223880597017, 250.60298507462684]}, \"s\": {\"a\": 0, \"k\": [319.8089552238806, 330.98507462686564]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{05064670-7e14-4141-89c1-e0f0f3a1c57d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.1607843137254902, 0.1843137254901961, 0.4588235294117647]}, \"r\": 1}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { lottie.layers[0].ks.p.k[0] = data[\"Anchor X\"]; lottie.layers[1].ks.a.k[0] = data[\"Anchor X\"]; lottie.layers[0].ks.p.k[1] = data[\"Anchor Y\"]; lottie.layers[1].ks.a.k[1] = data[\"Anchor Y\"]; lottie.layers[1].ks.p.k[0] = data[\"Position X\"]; lottie.layers[1].ks.p.k[1] = data[\"Position Y\"]; lottie.layers[1].ks.s.k[0] = data[\"Scale X\"]; lottie.layers[1].ks.s.k[1] = data[\"Scale Y\"]; lottie.layers[1].ks.r.k = data[\"Rotation\"]; lottie.layers[1].ks.sk.k = data[\"Skew\"]; lottie.layers[1].ks.sa.k = data[\"Skew Angle\"]; lottie.layers[1].ks.o.k = data[\"Opacity\"]; this.json_viewer_contents = lottie.layers[1].ks; }, {} ); Sometimes p might be split into separate components animated independently. Visual Object Composition Diagram for Visual Object Visual Object Asset File Asset Image Data source Sound Precomposition Animation Effect Value Ignored Value Effect Value Angle Effect Value Drop Down Effect Value Point Effect Value Slider Effect Value Color Effect Value Layer Effect Value Checkbox Effect Spherize Effect Puppet Effect Tritone Effect Displacement Map Effect Wavy Effect Gaussian Blur Effect Pro Levels Effect Tint Effect Mesh Warp Effect Set Matte Effect Fill Effect Drop Shadow Effect Radial Wipe Stroke Effect Twirl Effect Custom Effect Layer Data Layer Audio Layer Camera Layer Visual Layer Precomposition Layer Null Layer Image Layer Solid Layer Text Layer Shape Layer Stroke Dash Graphic Element Shape Rectangle Ellipse Path PolyStar Merge Transform Shape Shape Style Gradient Stroke Stroke No Style Gradient Fill Modifier Twist Rounded Corners Offset Path Trim Path Zig Zag Repeater Pucker Bloat Group Layer Style Outer Glow Layer Stroke Drop Shadow Inner Glow Satin Color Overlay Inner Shadow Gradient Overlay Bevel Emboss Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions Marker Defines named portions of the composition. Attribute Type Title Description cm string Comment Comment tm number Time Time dr number Duration Duration Slots Slots are a way to define a property value once and use the value in multiple properties. Slot definitions are in a dictionary, the slot definition key is the key that is used to match all properties with a sid field to the same key for replacement. Slot Defines a property value that will be set to all matched properties Attribute Type Title Description p Property Value Property Value Slotabble Object Object that may have its value replaced with a slot value Composition Diagram for Slottable Object Slottable Object Image Attribute Type Title Description sid string Slot Id Identifier to look up the slot Scale X 100 Scale Y 100 Rotation 0 Opacity 100 var lottie_player_24 = new PlaygroundPlayer( 24, 'playground_24_5', 'lottie_target_24', {\"v\": \"5.12.2\", \"fr\": 29.9700012207031, \"ip\": 0, \"op\": 900.000036657751, \"w\": 512, \"h\": 512, \"nm\": \"SlotDemo\", \"ddd\": 0, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ind\": 1, \"ty\": 4, \"nm\": \"Shape Layer 1\", \"sr\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100, \"ix\": 11}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 10}, \"p\": {\"a\": 0, \"k\": [256, 256, 0], \"ix\": 2, \"l\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0, 0], \"ix\": 1, \"l\": 2}, \"s\": {\"a\": 0, \"k\": [100, 100, 100], \"ix\": 6, \"l\": 2}}, \"ao\": 0, \"shapes\": [{\"ty\": \"gr\", \"it\": [{\"ty\": \"sr\", \"sy\": 2, \"d\": 1, \"pt\": {\"a\": 0, \"k\": 3, \"ix\": 3}, \"p\": {\"a\": 0, \"k\": [0, 0], \"ix\": 4}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 5}, \"or\": {\"a\": 0, \"k\": 100, \"ix\": 7}, \"os\": {\"a\": 0, \"k\": 0, \"ix\": 9}, \"ix\": 1, \"nm\": \"Polystar Path 1\", \"mn\": \"ADBE Vector Shape - Star\", \"hd\": false}, {\"ty\": \"st\", \"c\": {\"a\": 0, \"k\": [0.271324008119, 0.323676015816, 0.880510995902, 1], \"ix\": 3}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 4}, \"w\": {\"a\": 0, \"k\": 6, \"ix\": 5}, \"lc\": 1, \"lj\": 1, \"ml\": 4, \"bm\": 0, \"nm\": \"Stroke 1\", \"mn\": \"ADBE Vector Graphic - Stroke\", \"hd\": false}, {\"ty\": \"tr\", \"p\": {\"a\": 0, \"k\": [-128, 128], \"ix\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 1}, \"s\": {\"a\": 0, \"k\": [100, 100], \"ix\": 3, \"sid\": \"scale\"}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 6, \"sid\": \"rotation\"}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 7, \"sid\": \"opacity\"}, \"sk\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"sa\": {\"a\": 0, \"k\": 0, \"ix\": 5}, \"nm\": \"Transform\"}], \"nm\": \"Polystar 2\", \"np\": 3, \"cix\": 2, \"bm\": 0, \"ix\": 1, \"mn\": \"ADBE Vector Group\", \"hd\": false}, {\"ty\": \"gr\", \"it\": [{\"d\": 1, \"ty\": \"el\", \"s\": {\"a\": 0, \"k\": [149.971, 150], \"ix\": 2}, \"p\": {\"a\": 0, \"k\": [0, 0], \"ix\": 3}, \"nm\": \"Ellipse Path 1\", \"mn\": \"ADBE Vector Shape - Ellipse\", \"hd\": false}, {\"ty\": \"st\", \"c\": {\"a\": 0, \"k\": [0.271324008119, 0.323676015816, 0.880510995902, 1], \"ix\": 3}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 4}, \"w\": {\"a\": 0, \"k\": 6, \"ix\": 5}, \"lc\": 1, \"lj\": 1, \"ml\": 4, \"bm\": 0, \"nm\": \"Stroke 1\", \"mn\": \"ADBE Vector Graphic - Stroke\", \"hd\": false}, {\"ty\": \"tr\", \"p\": {\"a\": 0, \"k\": [128, -128], \"ix\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 1}, \"s\": {\"a\": 0, \"k\": [100, 100], \"ix\": 3, \"sid\": \"scale\"}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 6, \"sid\": \"rotation\"}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 7, \"sid\": \"opacity\"}, \"sk\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"sa\": {\"a\": 0, \"k\": 0, \"ix\": 5}, \"nm\": \"Transform\"}], \"nm\": \"Ellipse 1\", \"np\": 3, \"cix\": 2, \"bm\": 0, \"ix\": 2, \"mn\": \"ADBE Vector Group\", \"hd\": false}, {\"ty\": \"gr\", \"it\": [{\"ty\": \"sr\", \"sy\": 1, \"d\": 1, \"pt\": {\"a\": 0, \"k\": 5, \"ix\": 3}, \"p\": {\"a\": 0, \"k\": [0, 0], \"ix\": 4}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 5}, \"ir\": {\"a\": 0, \"k\": 50, \"ix\": 6}, \"is\": {\"a\": 0, \"k\": 0, \"ix\": 8}, \"or\": {\"a\": 0, \"k\": 100, \"ix\": 7}, \"os\": {\"a\": 0, \"k\": 0, \"ix\": 9}, \"ix\": 1, \"nm\": \"Polystar Path 1\", \"mn\": \"ADBE Vector Shape - Star\", \"hd\": false}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.271324008119, 0.323676015816, 0.880510995902, 1], \"ix\": 4}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 5}, \"r\": 1, \"bm\": 0, \"nm\": \"Fill 1\", \"mn\": \"ADBE Vector Graphic - Fill\", \"hd\": false}, {\"ty\": \"tr\", \"p\": {\"a\": 0, \"k\": [128, 128], \"ix\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 1}, \"s\": {\"a\": 0, \"k\": [100, 100], \"ix\": 3, \"sid\": \"scale\"}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 6, \"sid\": \"rotation\"}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 7, \"sid\": \"opacity\"}, \"sk\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"sa\": {\"a\": 0, \"k\": 0, \"ix\": 5}, \"nm\": \"Transform\"}], \"nm\": \"Polystar 1\", \"np\": 3, \"cix\": 2, \"bm\": 0, \"ix\": 3, \"mn\": \"ADBE Vector Group\", \"hd\": false}, {\"ty\": \"gr\", \"it\": [{\"ty\": \"rc\", \"d\": 1, \"s\": {\"a\": 0, \"k\": [150, 150], \"ix\": 2}, \"p\": {\"a\": 0, \"k\": [0, 0], \"ix\": 3}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"nm\": \"Rectangle Path 1\", \"mn\": \"ADBE Vector Shape - Rect\", \"hd\": false}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.271324008119, 0.323676015816, 0.880510995902, 1], \"ix\": 4}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 5}, \"r\": 1, \"bm\": 0, \"nm\": \"Fill 1\", \"mn\": \"ADBE Vector Graphic - Fill\", \"hd\": false}, {\"ty\": \"tr\", \"p\": {\"a\": 0, \"k\": [-128, -128], \"ix\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 1}, \"s\": {\"a\": 0, \"k\": [100, 100], \"ix\": 3, \"sid\": \"scale\"}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 6, \"sid\": \"rotation\"}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 7, \"sid\": \"opacity\"}, \"sk\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"sa\": {\"a\": 0, \"k\": 0, \"ix\": 5}, \"nm\": \"Transform\"}], \"nm\": \"Rectangle 1\", \"np\": 3, \"cix\": 2, \"bm\": 0, \"ix\": 4, \"mn\": \"ADBE Vector Group\", \"hd\": false}], \"ip\": 0, \"op\": 900.000036657751, \"st\": 0, \"ct\": 1, \"bm\": 0}], \"markers\": [], \"props\": {}, \"slots\": {\"rotation\": {\"p\": {\"a\": 0, \"k\": 0}}, \"opacity\": {\"p\": {\"a\": 0, \"k\": 100}}, \"scale\": {\"p\": {\"a\": 0, \"k\": [100, 100]}}}}, function (lottie, data) { lottie.slots.rotation.p.k = data[\"Rotation\"]; lottie.slots.opacity.p.k = data[\"Opacity\"]; lottie.slots.scale.p.k[0] = data[\"Scale X\"]; lottie.slots.scale.p.k[1] = data[\"Scale Y\"]; this.json_viewer_contents = lottie.slots; }, {} ); Mask Mask for layer content. Attribute Type Title Description mode Mask Mode Mode Mode o Scalar Opacity Mask opacity, as a percentage [0..100]. pt Bezier Shape Mask shape x Scalar Expand Expand inv boolean Inverted Inverted Masks provide single-channel coverage information (alpha channel) that modulates the layer's content. When multiple masks are specified, they are combined (blended) into a single coverage buffer, in order, based on the mode operator. Masks are specified in terms of a Path plus additional properties. For a given mask path, the coverage C p a t h is 1 inside the path, 0 outside the path, and possibly in the [ 0 . .1 ] range along the path edges (anti-aliasing). The coverage for a given Mask is C = { C p a t h \u00b7 o p a c i t y , when i n v = f a l s e C p a t h \u2212 1 \u00b7 o p a c i t y , when i n v = t r u e and the cumulative coverage for all masks is C c u m u l a t i v e = \u220f k = 1 n C k where the product operator is determined by mode . Then the final layer coverage (alpha channel) is C l a y e r \u2032 = C l a y e r \u00b7 C c u m u l a t i v e Example Opacity 100 var lottie_player_25 = new PlaygroundPlayer( 25, 'playground_25_2', 'lottie_target_25', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{b3d1b083-9de7-4537-a691-fc9aa42f9742}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 2, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Shapes\", \"ks\": {}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{528994b7-40ff-4d12-81f8-603f274da12e}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{ce8756d7-289f-4f84-a135-d225d57c42e0}\", \"p\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"or\": {\"a\": 0, \"k\": 216.4160919189453}, \"ir\": {\"a\": 0, \"k\": 87.03440856933594}, \"r\": {\"a\": 0, \"k\": 261.54803466796875}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{efd05a25-a43b-451d-83d2-53a477087223}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{523ca39c-9e57-4547-bf0e-ba7496003579}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"p\": {\"a\": 0, \"k\": [338.7223880597015, 209.76716417910447]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"Rectangle\", \"mn\": \"{d2d7a5d5-6d91-42e8-b40a-af52a112fe38}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{9ef8604e-7891-4909-a655-445131b4d842}\", \"p\": {\"a\": 0, \"k\": [209.17611940298502, 226.8]}, \"s\": {\"a\": 0, \"k\": [363.3313432835821, 369.3492537313433]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{444584d2-cb59-4cba-83a1-82cc605837fd}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{f75aed67-9b0e-41a9-b859-a14b5b0a320d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.7686274509803922, 0.8509803921568627, 0.9607843137254902]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"p\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}], \"hasMask\": true, \"masksProperties\": [{\"mode\": \"a\", \"o\": {\"a\": 0, \"k\": 100}, \"inv\": false, \"x\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [[247.109, 125.719], [66.109, 306.719], [424.109, 389.719]], \"i\": [[0, 0], [0, 0], [0, 0]], \"o\": [[0, 0], [0, 0], [0, 0]]}}}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let mask = lottie.layers[1].masksProperties[0]; mask.o.k = Number(data[\"Opacity\"]); this.json_viewer_contents = lottie.layers[1].masksProperties[0]; }, {} );","title":"Helpers"},{"location":"helpers/#helpers","text":"","title":"Helpers"},{"location":"helpers/#transform","text":"This represents a layer or shape transform. It has the properties from Visual Object and its own properties are all animated : Composition Diagram for Transform Transform Transform Shape Repeater Transform Text Style Attribute Type Title Description a Position Anchor Point Anchor point: a position (relative to its parent) around which transformations are applied (ie: center for rotation / scale) p Splittable Position Position Position / Translation r Scalar Rotation Rotation in degrees, clockwise s Vector Scale Scale factor, [100, 100] for no scaling o Scalar Opacity Opacity sk Scalar Skew Skew amount as an angle in degrees sa Scalar Skew Axis Direction along which skew is applied, in degrees ( 0 skews along the X axis, 90 along the Y axis) rx Scalar X Rotation Split rotation component ry Scalar Y Rotation Split rotation component rz Scalar Z Rotation Split rotation component, equivalent to r when not split or Vector Orientation Orientation To make the anchor point properly line up with the center of location, p and a should have the same value. This example allows you to tweak transform attributes and see how the shape changes. The anchor point is highlighted with an orange dot. Anchor X 256 Anchor Y 256 Position X 256 Position Y 256 Scale X 100 Scale Y 100 Rotation 0 Skew 0 Skew Angle 0 Opacity 100 var lottie_player_23 = new PlaygroundPlayer( 23, 'playground_23_11', 'lottie_target_23', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{a3bb98c7-d0dd-4484-b6da-74a0e70eaf2f}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 2, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Anchor\", \"mn\": \"{04f9b742-3603-49fa-9552-ea04de1a3f33}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{4251e46a-bb13-464b-913c-e67c44a218da}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{7d3070ed-88a3-41aa-a62e-7db8df1bd312}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}]}, {\"ddd\": 0, \"ty\": 4, \"ind\": 1, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Transformed\", \"mn\": \"{d00298c4-66b4-4ae4-a730-22c1eb85c188}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}, \"sk\": {\"a\": 0, \"k\": 0}, \"sa\": {\"a\": 0, \"k\": 0}}, \"shapes\": [{\"ty\": \"rc\", \"nm\": \"Rectangle 1\", \"mn\": \"{bf8ad877-113b-4df8-a2e2-3bb4af32edf7}\", \"p\": {\"a\": 0, \"k\": [252.75223880597017, 250.60298507462684]}, \"s\": {\"a\": 0, \"k\": [319.8089552238806, 330.98507462686564]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"nm\": \"Fill 1\", \"mn\": \"{b9040dc8-0753-4a6e-b5f1-d508d17bbd4f}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}]}, {\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Reference\", \"mn\": \"{8f351be7-8a51-4310-9dc3-59ed21594815}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{cb4f7b74-bed1-493b-a0e6-01b00566aedd}\", \"p\": {\"a\": 0, \"k\": [252.75223880597017, 250.60298507462684]}, \"s\": {\"a\": 0, \"k\": [319.8089552238806, 330.98507462686564]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{05064670-7e14-4141-89c1-e0f0f3a1c57d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.1607843137254902, 0.1843137254901961, 0.4588235294117647]}, \"r\": 1}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { lottie.layers[0].ks.p.k[0] = data[\"Anchor X\"]; lottie.layers[1].ks.a.k[0] = data[\"Anchor X\"]; lottie.layers[0].ks.p.k[1] = data[\"Anchor Y\"]; lottie.layers[1].ks.a.k[1] = data[\"Anchor Y\"]; lottie.layers[1].ks.p.k[0] = data[\"Position X\"]; lottie.layers[1].ks.p.k[1] = data[\"Position Y\"]; lottie.layers[1].ks.s.k[0] = data[\"Scale X\"]; lottie.layers[1].ks.s.k[1] = data[\"Scale Y\"]; lottie.layers[1].ks.r.k = data[\"Rotation\"]; lottie.layers[1].ks.sk.k = data[\"Skew\"]; lottie.layers[1].ks.sa.k = data[\"Skew Angle\"]; lottie.layers[1].ks.o.k = data[\"Opacity\"]; this.json_viewer_contents = lottie.layers[1].ks; }, {} ); Sometimes p might be split into separate components animated independently.","title":"Transform"},{"location":"helpers/#visual-object","text":"Composition Diagram for Visual Object Visual Object Asset File Asset Image Data source Sound Precomposition Animation Effect Value Ignored Value Effect Value Angle Effect Value Drop Down Effect Value Point Effect Value Slider Effect Value Color Effect Value Layer Effect Value Checkbox Effect Spherize Effect Puppet Effect Tritone Effect Displacement Map Effect Wavy Effect Gaussian Blur Effect Pro Levels Effect Tint Effect Mesh Warp Effect Set Matte Effect Fill Effect Drop Shadow Effect Radial Wipe Stroke Effect Twirl Effect Custom Effect Layer Data Layer Audio Layer Camera Layer Visual Layer Precomposition Layer Null Layer Image Layer Solid Layer Text Layer Shape Layer Stroke Dash Graphic Element Shape Rectangle Ellipse Path PolyStar Merge Transform Shape Shape Style Gradient Stroke Stroke No Style Gradient Fill Modifier Twist Rounded Corners Offset Path Trim Path Zig Zag Repeater Pucker Bloat Group Layer Style Outer Glow Layer Stroke Drop Shadow Inner Glow Satin Color Overlay Inner Shadow Gradient Overlay Bevel Emboss Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions","title":"Visual Object"},{"location":"helpers/#marker","text":"Defines named portions of the composition. Attribute Type Title Description cm string Comment Comment tm number Time Time dr number Duration Duration","title":"Marker"},{"location":"helpers/#slots","text":"Slots are a way to define a property value once and use the value in multiple properties. Slot definitions are in a dictionary, the slot definition key is the key that is used to match all properties with a sid field to the same key for replacement.","title":"Slots"},{"location":"helpers/#slot","text":"Defines a property value that will be set to all matched properties Attribute Type Title Description p Property Value Property Value","title":"Slot"},{"location":"helpers/#slottable-object","text":"Object that may have its value replaced with a slot value Composition Diagram for Slottable Object Slottable Object Image Attribute Type Title Description sid string Slot Id Identifier to look up the slot Scale X 100 Scale Y 100 Rotation 0 Opacity 100 var lottie_player_24 = new PlaygroundPlayer( 24, 'playground_24_5', 'lottie_target_24', {\"v\": \"5.12.2\", \"fr\": 29.9700012207031, \"ip\": 0, \"op\": 900.000036657751, \"w\": 512, \"h\": 512, \"nm\": \"SlotDemo\", \"ddd\": 0, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ind\": 1, \"ty\": 4, \"nm\": \"Shape Layer 1\", \"sr\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100, \"ix\": 11}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 10}, \"p\": {\"a\": 0, \"k\": [256, 256, 0], \"ix\": 2, \"l\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0, 0], \"ix\": 1, \"l\": 2}, \"s\": {\"a\": 0, \"k\": [100, 100, 100], \"ix\": 6, \"l\": 2}}, \"ao\": 0, \"shapes\": [{\"ty\": \"gr\", \"it\": [{\"ty\": \"sr\", \"sy\": 2, \"d\": 1, \"pt\": {\"a\": 0, \"k\": 3, \"ix\": 3}, \"p\": {\"a\": 0, \"k\": [0, 0], \"ix\": 4}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 5}, \"or\": {\"a\": 0, \"k\": 100, \"ix\": 7}, \"os\": {\"a\": 0, \"k\": 0, \"ix\": 9}, \"ix\": 1, \"nm\": \"Polystar Path 1\", \"mn\": \"ADBE Vector Shape - Star\", \"hd\": false}, {\"ty\": \"st\", \"c\": {\"a\": 0, \"k\": [0.271324008119, 0.323676015816, 0.880510995902, 1], \"ix\": 3}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 4}, \"w\": {\"a\": 0, \"k\": 6, \"ix\": 5}, \"lc\": 1, \"lj\": 1, \"ml\": 4, \"bm\": 0, \"nm\": \"Stroke 1\", \"mn\": \"ADBE Vector Graphic - Stroke\", \"hd\": false}, {\"ty\": \"tr\", \"p\": {\"a\": 0, \"k\": [-128, 128], \"ix\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 1}, \"s\": {\"a\": 0, \"k\": [100, 100], \"ix\": 3, \"sid\": \"scale\"}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 6, \"sid\": \"rotation\"}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 7, \"sid\": \"opacity\"}, \"sk\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"sa\": {\"a\": 0, \"k\": 0, \"ix\": 5}, \"nm\": \"Transform\"}], \"nm\": \"Polystar 2\", \"np\": 3, \"cix\": 2, \"bm\": 0, \"ix\": 1, \"mn\": \"ADBE Vector Group\", \"hd\": false}, {\"ty\": \"gr\", \"it\": [{\"d\": 1, \"ty\": \"el\", \"s\": {\"a\": 0, \"k\": [149.971, 150], \"ix\": 2}, \"p\": {\"a\": 0, \"k\": [0, 0], \"ix\": 3}, \"nm\": \"Ellipse Path 1\", \"mn\": \"ADBE Vector Shape - Ellipse\", \"hd\": false}, {\"ty\": \"st\", \"c\": {\"a\": 0, \"k\": [0.271324008119, 0.323676015816, 0.880510995902, 1], \"ix\": 3}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 4}, \"w\": {\"a\": 0, \"k\": 6, \"ix\": 5}, \"lc\": 1, \"lj\": 1, \"ml\": 4, \"bm\": 0, \"nm\": \"Stroke 1\", \"mn\": \"ADBE Vector Graphic - Stroke\", \"hd\": false}, {\"ty\": \"tr\", \"p\": {\"a\": 0, \"k\": [128, -128], \"ix\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 1}, \"s\": {\"a\": 0, \"k\": [100, 100], \"ix\": 3, \"sid\": \"scale\"}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 6, \"sid\": \"rotation\"}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 7, \"sid\": \"opacity\"}, \"sk\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"sa\": {\"a\": 0, \"k\": 0, \"ix\": 5}, \"nm\": \"Transform\"}], \"nm\": \"Ellipse 1\", \"np\": 3, \"cix\": 2, \"bm\": 0, \"ix\": 2, \"mn\": \"ADBE Vector Group\", \"hd\": false}, {\"ty\": \"gr\", \"it\": [{\"ty\": \"sr\", \"sy\": 1, \"d\": 1, \"pt\": {\"a\": 0, \"k\": 5, \"ix\": 3}, \"p\": {\"a\": 0, \"k\": [0, 0], \"ix\": 4}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 5}, \"ir\": {\"a\": 0, \"k\": 50, \"ix\": 6}, \"is\": {\"a\": 0, \"k\": 0, \"ix\": 8}, \"or\": {\"a\": 0, \"k\": 100, \"ix\": 7}, \"os\": {\"a\": 0, \"k\": 0, \"ix\": 9}, \"ix\": 1, \"nm\": \"Polystar Path 1\", \"mn\": \"ADBE Vector Shape - Star\", \"hd\": false}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.271324008119, 0.323676015816, 0.880510995902, 1], \"ix\": 4}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 5}, \"r\": 1, \"bm\": 0, \"nm\": \"Fill 1\", \"mn\": \"ADBE Vector Graphic - Fill\", \"hd\": false}, {\"ty\": \"tr\", \"p\": {\"a\": 0, \"k\": [128, 128], \"ix\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 1}, \"s\": {\"a\": 0, \"k\": [100, 100], \"ix\": 3, \"sid\": \"scale\"}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 6, \"sid\": \"rotation\"}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 7, \"sid\": \"opacity\"}, \"sk\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"sa\": {\"a\": 0, \"k\": 0, \"ix\": 5}, \"nm\": \"Transform\"}], \"nm\": \"Polystar 1\", \"np\": 3, \"cix\": 2, \"bm\": 0, \"ix\": 3, \"mn\": \"ADBE Vector Group\", \"hd\": false}, {\"ty\": \"gr\", \"it\": [{\"ty\": \"rc\", \"d\": 1, \"s\": {\"a\": 0, \"k\": [150, 150], \"ix\": 2}, \"p\": {\"a\": 0, \"k\": [0, 0], \"ix\": 3}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"nm\": \"Rectangle Path 1\", \"mn\": \"ADBE Vector Shape - Rect\", \"hd\": false}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.271324008119, 0.323676015816, 0.880510995902, 1], \"ix\": 4}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 5}, \"r\": 1, \"bm\": 0, \"nm\": \"Fill 1\", \"mn\": \"ADBE Vector Graphic - Fill\", \"hd\": false}, {\"ty\": \"tr\", \"p\": {\"a\": 0, \"k\": [-128, -128], \"ix\": 2}, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 1}, \"s\": {\"a\": 0, \"k\": [100, 100], \"ix\": 3, \"sid\": \"scale\"}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 6, \"sid\": \"rotation\"}, \"o\": {\"a\": 0, \"k\": 100, \"ix\": 7, \"sid\": \"opacity\"}, \"sk\": {\"a\": 0, \"k\": 0, \"ix\": 4}, \"sa\": {\"a\": 0, \"k\": 0, \"ix\": 5}, \"nm\": \"Transform\"}], \"nm\": \"Rectangle 1\", \"np\": 3, \"cix\": 2, \"bm\": 0, \"ix\": 4, \"mn\": \"ADBE Vector Group\", \"hd\": false}], \"ip\": 0, \"op\": 900.000036657751, \"st\": 0, \"ct\": 1, \"bm\": 0}], \"markers\": [], \"props\": {}, \"slots\": {\"rotation\": {\"p\": {\"a\": 0, \"k\": 0}}, \"opacity\": {\"p\": {\"a\": 0, \"k\": 100}}, \"scale\": {\"p\": {\"a\": 0, \"k\": [100, 100]}}}}, function (lottie, data) { lottie.slots.rotation.p.k = data[\"Rotation\"]; lottie.slots.opacity.p.k = data[\"Opacity\"]; lottie.slots.scale.p.k[0] = data[\"Scale X\"]; lottie.slots.scale.p.k[1] = data[\"Scale Y\"]; this.json_viewer_contents = lottie.slots; }, {} );","title":"Slotabble Object"},{"location":"helpers/#mask","text":"Mask for layer content. Attribute Type Title Description mode Mask Mode Mode Mode o Scalar Opacity Mask opacity, as a percentage [0..100]. pt Bezier Shape Mask shape x Scalar Expand Expand inv boolean Inverted Inverted Masks provide single-channel coverage information (alpha channel) that modulates the layer's content. When multiple masks are specified, they are combined (blended) into a single coverage buffer, in order, based on the mode operator. Masks are specified in terms of a Path plus additional properties. For a given mask path, the coverage C p a t h is 1 inside the path, 0 outside the path, and possibly in the [ 0 . .1 ] range along the path edges (anti-aliasing). The coverage for a given Mask is C = { C p a t h \u00b7 o p a c i t y , when i n v = f a l s e C p a t h \u2212 1 \u00b7 o p a c i t y , when i n v = t r u e and the cumulative coverage for all masks is C c u m u l a t i v e = \u220f k = 1 n C k where the product operator is determined by mode . Then the final layer coverage (alpha channel) is C l a y e r \u2032 = C l a y e r \u00b7 C c u m u l a t i v e Example Opacity 100 var lottie_player_25 = new PlaygroundPlayer( 25, 'playground_25_2', 'lottie_target_25', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{b3d1b083-9de7-4537-a691-fc9aa42f9742}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 2, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Shapes\", \"ks\": {}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{528994b7-40ff-4d12-81f8-603f274da12e}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{ce8756d7-289f-4f84-a135-d225d57c42e0}\", \"p\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"or\": {\"a\": 0, \"k\": 216.4160919189453}, \"ir\": {\"a\": 0, \"k\": 87.03440856933594}, \"r\": {\"a\": 0, \"k\": 261.54803466796875}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{efd05a25-a43b-451d-83d2-53a477087223}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{523ca39c-9e57-4547-bf0e-ba7496003579}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"p\": {\"a\": 0, \"k\": [338.7223880597015, 209.76716417910447]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"Rectangle\", \"mn\": \"{d2d7a5d5-6d91-42e8-b40a-af52a112fe38}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{9ef8604e-7891-4909-a655-445131b4d842}\", \"p\": {\"a\": 0, \"k\": [209.17611940298502, 226.8]}, \"s\": {\"a\": 0, \"k\": [363.3313432835821, 369.3492537313433]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{444584d2-cb59-4cba-83a1-82cc605837fd}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{f75aed67-9b0e-41a9-b859-a14b5b0a320d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.7686274509803922, 0.8509803921568627, 0.9607843137254902]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"p\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}], \"hasMask\": true, \"masksProperties\": [{\"mode\": \"a\", \"o\": {\"a\": 0, \"k\": 100}, \"inv\": false, \"x\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [[247.109, 125.719], [66.109, 306.719], [424.109, 389.719]], \"i\": [[0, 0], [0, 0], [0, 0]], \"o\": [[0, 0], [0, 0], [0, 0]]}}}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let mask = lottie.layers[1].masksProperties[0]; mask.o.k = Number(data[\"Opacity\"]); this.json_viewer_contents = lottie.layers[1].masksProperties[0]; }, {} );","title":"Mask"},{"location":"layers/","text":"Layers Layer Common properties for all layers Composition Diagram for Layer Layer Visual Object Data Layer Audio Layer Camera Layer Visual Layer Precomposition Layer Null Layer Image Layer Solid Layer Text Layer Shape Layer Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ddd 0-1 integer Threedimensional Whether the layer is threedimensional hd boolean Hidden Whether the layer is hidden ty integer Type Layer Type ind integer Index Index that can be used for parenting and referenced in expressions parent integer Parent Index Must be the ind property of another layer sr number Time Stretch Time Stretch ip number In Point Frame when the layer becomes visible op number Out Point Frame when the layer becomes invisible st number Start Time Start Time The ty property defines the specific layer type based on the following values: ty Type 0 Precomposition Layer 1 Solid Layer 2 Image Layer 3 Null Layer 4 Shape Layer 5 Text Layer 6 Audio Layer 15 Data Layer 13 Camera Layer Visual Layer Layer used to affect visual elements Composition Diagram for Visual Layer Visual Layer Layer Visual Object Precomposition Layer Null Layer Image Layer Solid Layer Text Layer Shape Layer Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ddd 0-1 integer Threedimensional Whether the layer is threedimensional hd boolean Hidden Whether the layer is hidden ty integer Type Layer Type ind integer Index Index that can be used for parenting and referenced in expressions parent integer Parent Index Must be the ind property of another layer sr number Time Stretch Time Stretch ip number In Point Frame when the layer becomes visible op number Out Point Frame when the layer becomes invisible st number Start Time Start Time ks Transform Transform Layer transform ao 0-1 integer Auto Orient If 1, the layer will rotate itself to match its animated position path tt Matte Mode Matte Mode Defines the track matte mode for the layer tp integer Matte Parent Index of the layer used as matte, if omitted assume the layer above the current one td 0-1 integer Matte Target If set to 1, it means a layer is using this layer as a track matte hasMask boolean Has Masks Whether the layer has masks applied masksProperties array of Mask Masks Optional array of masks for the layer. ef array of Effect Effects List of layer effects mb boolean Motion Blur Whether motion blur is enabled for the layer sy array of Layer Style Layer style Styling effects for this layer bm Blend Mode Blend Mode Blend Mode cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer tg string Layer XML tag name tag name used by the SVG renderer cp boolean Collapse Transform This is deprecated in favour of ct ct 0-1 integer Collapse Transform Marks that transforms should be applied before masks Note that layers that don't have a visual component (Audio layers for example), won't have a transform and similar. The layer is only visible between its ip and op . If they match the corresponding attributes in Animation , the layer will be visible the whole time, otherwise it will become visible at the frame ip and disappear at op . Parenting Within a list of layers, the ind attribute (if present) must be unique. Layers having a parent attribute matching another layer will inherit their parent's transform (except for opacity). Basically you need multiply the transform matrix by the parent's transform matrix to get a child layer's final transform. The flat layer structure and flexible parenting allows more flexibility but it's different from the more traditional approach of nesting child layers inside the parent layer (like a folder structure). One of the advantages of flexible parenting is you can have children of the same layer be intermixed with unrelated layers. In the following example, the star and the ellipse are in separate layers, but both have the same parent, which moves left and right. Between the two there's an additional layer with the rectangle. var lottie_player_26 = new LottiePlayer( 'lottie_target_26', '../static/examples/parenting.json', true, {} ); Auto Orient When true, if the transform position is animated, it rotates the layer along the path the position follows. In the following example there are two arrows animated along the same path, with no rotation when the position moves towards the right. The transparent one keeps its rotation the same ( ao is 0), while the solid one follows the path ( ao is 1). var lottie_player_27 = new LottiePlayer( 'lottie_target_27', '../static/examples/auto_orient.json', true, {} ); Mattes A matte allows using a layer as a mask for another layer. The way it works is the layer defining the mask has a tt attribute with the appropriate value . By defaults it affects the layer on top (the layer before it in the layer list, which has the td attribute), otherwise check the tp attribute. In this example there's a layer with a rectangle and a star being masked by an ellipse: Example Enable Matte Matte Mode Normal Alpha Inverted Alpha Luma Inverted Luma var lottie_player_28 = new PlaygroundPlayer( 28, 'playground_28_3', 'lottie_target_28', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{b3d1b083-9de7-4537-a691-fc9aa42f9742}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 1, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Ellipse (Mask)\", \"ks\": {\"a\": {\"a\": 0, \"k\": [153, 294]}, \"p\": {\"a\": 0, \"k\": [346, 211]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{261eddeb-af92-4be1-932c-790b00c23933}\", \"p\": {\"a\": 0, \"k\": [137.0955223880597, 293.60820895522386]}, \"s\": {\"a\": 0, \"k\": [303.42089552238804, 315.55074626865667]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{aa9c282c-253d-4d8d-ab05-4819c592fa85}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{2b2b0002-ff0c-4978-a33b-db4e0498848d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}], \"td\": 1}, {\"ddd\": 0, \"ty\": 4, \"ind\": 2, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Shapes (Masked)\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{528994b7-40ff-4d12-81f8-603f274da12e}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{ce8756d7-289f-4f84-a135-d225d57c42e0}\", \"p\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"or\": {\"a\": 0, \"k\": 216.4160919189453}, \"ir\": {\"a\": 0, \"k\": 87.03440856933594}, \"r\": {\"a\": 0, \"k\": 261.54803466796875}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{efd05a25-a43b-451d-83d2-53a477087223}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{523ca39c-9e57-4547-bf0e-ba7496003579}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"p\": {\"a\": 0, \"k\": [338.7223880597015, 209.76716417910447]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"Rectangle\", \"mn\": \"{d2d7a5d5-6d91-42e8-b40a-af52a112fe38}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{9ef8604e-7891-4909-a655-445131b4d842}\", \"p\": {\"a\": 0, \"k\": [209.17611940298502, 226.8]}, \"s\": {\"a\": 0, \"k\": [363.3313432835821, 369.3492537313433]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{444584d2-cb59-4cba-83a1-82cc605837fd}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{f75aed67-9b0e-41a9-b859-a14b5b0a320d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.7686274509803922, 0.8509803921568627, 0.9607843137254902]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"p\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}], \"tt\": 1, \"tp\": 1}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { if ( data[\"Enable Matte\"] ) { lottie.layers[1].tt = Number(data[\"Matte Mode\"]); lottie.layers[1].tp = 1; lottie.layers[0].td = 1; } else { lottie.layers[1].tt = undefined; lottie.layers[1].tp = undefined; lottie.layers[0].td = undefined; } this.json_viewer_contents = {...lottie.layers[1], shapes: [], ks: {}}; }, {} ); Masks A layer can have an array of masks that clip the contents of the layer to a shape. This is similar to mattes , but there are a few differences. With mattes, you use a layer to define the clipping area, while with masks you use an animated bezier curve . Example Mode None Add Subtract Intersect Lighten Darken Difference Opacity 100 Invert Expand 0 var lottie_player_29 = new PlaygroundPlayer( 29, 'playground_29_5', 'lottie_target_29', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{b3d1b083-9de7-4537-a691-fc9aa42f9742}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 2, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Shapes\", \"ks\": {}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{528994b7-40ff-4d12-81f8-603f274da12e}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{ce8756d7-289f-4f84-a135-d225d57c42e0}\", \"p\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"or\": {\"a\": 0, \"k\": 216.4160919189453}, \"ir\": {\"a\": 0, \"k\": 87.03440856933594}, \"r\": {\"a\": 0, \"k\": 261.54803466796875}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{efd05a25-a43b-451d-83d2-53a477087223}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{523ca39c-9e57-4547-bf0e-ba7496003579}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"p\": {\"a\": 0, \"k\": [338.7223880597015, 209.76716417910447]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"Rectangle\", \"mn\": \"{d2d7a5d5-6d91-42e8-b40a-af52a112fe38}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{9ef8604e-7891-4909-a655-445131b4d842}\", \"p\": {\"a\": 0, \"k\": [209.17611940298502, 226.8]}, \"s\": {\"a\": 0, \"k\": [363.3313432835821, 369.3492537313433]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{444584d2-cb59-4cba-83a1-82cc605837fd}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{f75aed67-9b0e-41a9-b859-a14b5b0a320d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.7686274509803922, 0.8509803921568627, 0.9607843137254902]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"p\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}], \"hasMask\": true, \"masksProperties\": [{\"mode\": \"a\", \"o\": {\"a\": 0, \"k\": 100}, \"inv\": false, \"x\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [[247.109, 125.719], [66.109, 306.719], [424.109, 389.719]], \"i\": [[0, 0], [0, 0], [0, 0]], \"o\": [[0, 0], [0, 0], [0, 0]]}}}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let mask = lottie.layers[0].masksProperties[0]; mask.o.k = Number(data[\"Opacity\"]); mask.inv = data[\"Invert\"]; mask.x.k = Number(data[\"Expand\"]); mask.mode = data[\"Mode\"]; this.json_viewer_contents = lottie.layers[0].masksProperties[0]; }, {} ); Lists of layers and shapes Such lists appear Precomposition, Animation, ShapeLayer, and Groop. In such lists, items coming first will be rendered on top So if you have for example: [Ellipse, Rectangle] The ellipse will show on top of the rectangle: var lottie_player_30 = new LottiePlayer( 'lottie_target_30', '../static/examples/layer_order.json', true, {} ); This means the render order goes from the last element to the first. Shape Layer Renders vector data. The only special property for this layer is shapes , an array of shapes . Composition Diagram for Shape Layer Shape Layer Visual Layer Layer Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ddd 0-1 integer Threedimensional Whether the layer is threedimensional hd boolean Hidden Whether the layer is hidden ty integer = 4 Type Layer type ind integer Index Index that can be used for parenting and referenced in expressions parent integer Parent Index Must be the ind property of another layer sr number Time Stretch Time Stretch ip number In Point Frame when the layer becomes visible op number Out Point Frame when the layer becomes invisible st number Start Time Start Time ks Transform Transform Layer transform ao 0-1 integer Auto Orient If 1, the layer will rotate itself to match its animated position path tt Matte Mode Matte Mode Defines the track matte mode for the layer tp integer Matte Parent Index of the layer used as matte, if omitted assume the layer above the current one td 0-1 integer Matte Target If set to 1, it means a layer is using this layer as a track matte hasMask boolean Has Masks Whether the layer has masks applied masksProperties array of Mask Masks Optional array of masks for the layer. ef array of Effect Effects List of layer effects mb boolean Motion Blur Whether motion blur is enabled for the layer sy array of Layer Style Layer style Styling effects for this layer bm Blend Mode Blend Mode Blend Mode cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer tg string Layer XML tag name tag name used by the SVG renderer cp boolean Collapse Transform This is deprecated in favour of ct ct 0-1 integer Collapse Transform Marks that transforms should be applied before masks shapes array of Graphic Element Shapes Shapes Precomposition Layer This layer renders a precomposition . You can find more details in the Precompositions page. Composition Diagram for Precomposition Layer Precomposition Layer Visual Layer Layer Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ddd 0-1 integer Threedimensional Whether the layer is threedimensional hd boolean Hidden Whether the layer is hidden ty integer = 0 Type Layer type ind integer Index Index that can be used for parenting and referenced in expressions parent integer Parent Index Must be the ind property of another layer sr number Time Stretch Time Stretch ip number In Point Frame when the layer becomes visible op number Out Point Frame when the layer becomes invisible st number Start Time Start Time ks Transform Transform Layer transform ao 0-1 integer Auto Orient If 1, the layer will rotate itself to match its animated position path tt Matte Mode Matte Mode Defines the track matte mode for the layer tp integer Matte Parent Index of the layer used as matte, if omitted assume the layer above the current one td 0-1 integer Matte Target If set to 1, it means a layer is using this layer as a track matte hasMask boolean Has Masks Whether the layer has masks applied masksProperties array of Mask Masks Optional array of masks for the layer. ef array of Effect Effects List of layer effects mb boolean Motion Blur Whether motion blur is enabled for the layer sy array of Layer Style Layer style Styling effects for this layer bm Blend Mode Blend Mode Blend Mode cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer tg string Layer XML tag name tag name used by the SVG renderer cp boolean Collapse Transform This is deprecated in favour of ct ct 0-1 integer Collapse Transform Marks that transforms should be applied before masks refId string Reference Id ID of the precomp as specified in the assets w integer Width Width of the clipping rect h integer Height Height of the clipping rect tm Scalar Time Remap Timeline remap function (frame index -> time in seconds) Time remapping The tm property maps the time in seconds of the precomposition to show. Basically you get the value of tm at the current frame, then assume that's a time in seconds since the start of the animation, and render the corresponding frame of the precomposition. Follows an example of this, here there are two layers showing the same precomposition, the one at the top right keeps the original time while the bottom one remaps time as follows: frame 0 (0s) maps to 0s (frame 0) in the precomp frame 30 (0.5s) maps to 3s (frame 180) in the precomp frame 60 (1s) maps to 1.5s (frame 90) in the precomp frame 180 (3s) maps to 3s (frame 180) in the precomp Basically it makes the precomp play in the first half second, then rewind to half way for the next half second, and plays back to the end for the remaining 2 seconds. var lottie_player_31 = new PlaygroundPlayer( 31, 'playground_31_1', 'lottie_target_31', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{7820523d-dd32-453b-b311-50323a49e4df}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"nm\": \"Composition\", \"mn\": \"{4d838004-a221-48cb-966f-399347c5acb8}\", \"id\": \"{4d838004-a221-48cb-966f-399347c5acb8}\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer 1\", \"mn\": \"{8afc4794-97eb-4533-814b-f92676e324f5}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar 1\", \"mn\": \"{600eb536-73f0-415d-8743-01dd2f26e2b7}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar 1\", \"mn\": \"{0d81b309-da59-4646-812d-ed9212679e27}\", \"p\": {\"a\": 0, \"k\": [166.49999999999997, 144.89999999999998]}, \"or\": {\"a\": 0, \"k\": 103.60950469970703}, \"ir\": {\"a\": 0, \"k\": 51.804752349853516}, \"r\": {\"a\": 0, \"k\": 147.41429138183594}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{5271148f-841e-4e99-9f23-e0b201b46def}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{c72fab9f-6a71-4e30-966c-1b863389d19a}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [166.49999999999997, 144.89999999999998]}, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [106.19999999999997, 126.89999999999998], \"h\": 0, \"o\": {\"x\": [0.3333333333333333], \"y\": [0]}, \"i\": {\"x\": [0.6666666666666666], \"y\": [1]}, \"e\": [413.99999999999994, 413.09999999999997]}, {\"t\": 180, \"s\": [413.99999999999994, 413.09999999999997]}]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}]}], \"layers\": [{\"ty\": 0, \"ddd\": 0, \"nm\": \"Composition\", \"mn\": \"{e3aa5446-47d2-454e-8d20-ed3c5f15612e}\", \"ip\": 0, \"op\": 180, \"ind\": 2, \"st\": 0, \"sr\": 1, \"ks\": {\"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [50, 50]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"refId\": \"{4d838004-a221-48cb-966f-399347c5acb8}\", \"w\": 512, \"h\": 512}, {\"ty\": 0, \"ddd\": 0, \"nm\": \"Remapped\", \"mn\": \"{0f7b917c-b0e8-450f-bb63-812dff786620}\", \"ip\": 0, \"op\": 180, \"ind\": 1, \"st\": 0, \"sr\": 1, \"tm\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 30, \"s\": [3], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 60, \"s\": [1.5], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 180, \"s\": [3], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}]}, \"ks\": {\"a\": {\"a\": 0, \"k\": [512, 512]}, \"p\": {\"a\": 0, \"k\": [512, 512]}, \"s\": {\"a\": 0, \"k\": [50, 50]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"refId\": \"{4d838004-a221-48cb-966f-399347c5acb8}\", \"w\": 512, \"h\": 512}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { this.json_viewer_contents = {...lottie.layers[1], ks:{}}; }, {} ); Null Layer This layer doesn't have any special properties. It's often used by animators as a parent to multiple other layers (see parenting ). Composition Diagram for Null Layer Null Layer Visual Layer Layer Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ddd 0-1 integer Threedimensional Whether the layer is threedimensional hd boolean Hidden Whether the layer is hidden ty integer = 3 Type Layer type ind integer Index Index that can be used for parenting and referenced in expressions parent integer Parent Index Must be the ind property of another layer sr number Time Stretch Time Stretch ip number In Point Frame when the layer becomes visible op number Out Point Frame when the layer becomes invisible st number Start Time Start Time ks Transform Transform Layer transform ao 0-1 integer Auto Orient If 1, the layer will rotate itself to match its animated position path tt Matte Mode Matte Mode Defines the track matte mode for the layer tp integer Matte Parent Index of the layer used as matte, if omitted assume the layer above the current one td 0-1 integer Matte Target If set to 1, it means a layer is using this layer as a track matte hasMask boolean Has Masks Whether the layer has masks applied masksProperties array of Mask Masks Optional array of masks for the layer. ef array of Effect Effects List of layer effects mb boolean Motion Blur Whether motion blur is enabled for the layer sy array of Layer Style Layer style Styling effects for this layer bm Blend Mode Blend Mode Blend Mode cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer tg string Layer XML tag name tag name used by the SVG renderer cp boolean Collapse Transform This is deprecated in favour of ct ct 0-1 integer Collapse Transform Marks that transforms should be applied before masks Text Layer For text data, please refer to the section about text for details. Composition Diagram for Text Layer Text Layer Visual Layer Layer Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ddd 0-1 integer Threedimensional Whether the layer is threedimensional hd boolean Hidden Whether the layer is hidden ty integer = 5 Type Layer type ind integer Index Index that can be used for parenting and referenced in expressions parent integer Parent Index Must be the ind property of another layer sr number Time Stretch Time Stretch ip number In Point Frame when the layer becomes visible op number Out Point Frame when the layer becomes invisible st number Start Time Start Time ks Transform Transform Layer transform ao 0-1 integer Auto Orient If 1, the layer will rotate itself to match its animated position path tt Matte Mode Matte Mode Defines the track matte mode for the layer tp integer Matte Parent Index of the layer used as matte, if omitted assume the layer above the current one td 0-1 integer Matte Target If set to 1, it means a layer is using this layer as a track matte hasMask boolean Has Masks Whether the layer has masks applied masksProperties array of Mask Masks Optional array of masks for the layer. ef array of Effect Effects List of layer effects mb boolean Motion Blur Whether motion blur is enabled for the layer sy array of Layer Style Layer style Styling effects for this layer bm Blend Mode Blend Mode Blend Mode cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer tg string Layer XML tag name tag name used by the SVG renderer cp boolean Collapse Transform This is deprecated in favour of ct ct 0-1 integer Collapse Transform Marks that transforms should be applied before masks t Text Data Data Data Image Layer This layer renders a static image . Composition Diagram for Image Layer Image Layer Visual Layer Layer Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ddd 0-1 integer Threedimensional Whether the layer is threedimensional hd boolean Hidden Whether the layer is hidden ty integer = 2 Type Layer type ind integer Index Index that can be used for parenting and referenced in expressions parent integer Parent Index Must be the ind property of another layer sr number Time Stretch Time Stretch ip number In Point Frame when the layer becomes visible op number Out Point Frame when the layer becomes invisible st number Start Time Start Time ks Transform Transform Layer transform ao 0-1 integer Auto Orient If 1, the layer will rotate itself to match its animated position path tt Matte Mode Matte Mode Defines the track matte mode for the layer tp integer Matte Parent Index of the layer used as matte, if omitted assume the layer above the current one td 0-1 integer Matte Target If set to 1, it means a layer is using this layer as a track matte hasMask boolean Has Masks Whether the layer has masks applied masksProperties array of Mask Masks Optional array of masks for the layer. ef array of Effect Effects List of layer effects mb boolean Motion Blur Whether motion blur is enabled for the layer sy array of Layer Style Layer style Styling effects for this layer bm Blend Mode Blend Mode Blend Mode cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer tg string Layer XML tag name tag name used by the SVG renderer cp boolean Collapse Transform This is deprecated in favour of ct ct 0-1 integer Collapse Transform Marks that transforms should be applied before masks refId string Reference Id ID of the image as specified in the assets Solid Layer This layer represents a rectangle with a single color. Anything you can do with solid layers, you can do better with a shape layer and a rectangle shape since none of this layer's own properties can be animated. Note that the color is represented as a string, unlike most other places. Composition Diagram for Solid Layer Solid Layer Visual Layer Layer Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ddd 0-1 integer Threedimensional Whether the layer is threedimensional hd boolean Hidden Whether the layer is hidden ty integer = 1 Type Layer type ind integer Index Index that can be used for parenting and referenced in expressions parent integer Parent Index Must be the ind property of another layer sr number Time Stretch Time Stretch ip number In Point Frame when the layer becomes visible op number Out Point Frame when the layer becomes invisible st number Start Time Start Time ks Transform Transform Layer transform ao 0-1 integer Auto Orient If 1, the layer will rotate itself to match its animated position path tt Matte Mode Matte Mode Defines the track matte mode for the layer tp integer Matte Parent Index of the layer used as matte, if omitted assume the layer above the current one td 0-1 integer Matte Target If set to 1, it means a layer is using this layer as a track matte hasMask boolean Has Masks Whether the layer has masks applied masksProperties array of Mask Masks Optional array of masks for the layer. ef array of Effect Effects List of layer effects mb boolean Motion Blur Whether motion blur is enabled for the layer sy array of Layer Style Layer style Styling effects for this layer bm Blend Mode Blend Mode Blend Mode cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer tg string Layer XML tag name tag name used by the SVG renderer cp boolean Collapse Transform This is deprecated in favour of ct ct 0-1 integer Collapse Transform Marks that transforms should be applied before masks sw integer Width Solid rectangle width sh integer Height Solid rectangle height sc Hex Color Color Solid fill color Color Width 512 Height 512 var lottie_player_32 = new PlaygroundPlayer( 32, 'playground_32_4', 'lottie_target_32', {\"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"layers\": [{\"ty\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {}, \"sc\": \"#ff0000\", \"sh\": 512, \"sw\": 512}]}, function (lottie, data) { lottie.layers[0].sc = data[\"Color\"]; lottie.layers[0].sw = Number(data[\"Width\"]); lottie.layers[0].sh = Number(data[\"Height\"]); this.json_viewer_contents = lottie.layers[0]; }, {} ); Audio Layer This layer plays a sound . Composition Diagram for Audio Layer Audio Layer Layer Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ddd 0-1 integer Threedimensional Whether the layer is threedimensional hd boolean Hidden Whether the layer is hidden ty integer = 6 Type Layer type ind integer Index Index that can be used for parenting and referenced in expressions parent integer Parent Index Must be the ind property of another layer sr number Time Stretch Time Stretch ip number In Point Frame when the layer becomes visible op number Out Point Frame when the layer becomes invisible st number Start Time Start Time au Audio Settings Audio Settings Audio Settings refId string Sound Id ID of the sound as specified in the assets Audio Settings Attribute Type Title Description lv Vector Level Level 3D Layers Layers can have 3D transforms as well: var lottie_player_33 = new LottiePlayer( 'lottie_target_33', '../static/examples/3d_layers_animation.json', true, {\"renderer\": \"html\"} ); 3D layers need to have the ddd set to 1 (and so does the top-level object). Their transform will habe a and p specified as 3D components. Rotation will be split into 3 properties: rx , ry , rz , and you have and additional orientation property or . X 0 Y 0 Z Position 0 X 256 Y 256 Z Rotation 0 X 0 Y 30 Z Orientation 0 X 0 Y 0 Z Scale 0 X 100 Y 100 Z 100 var lottie_player_34 = new PlaygroundPlayer( 34, 'playground_34_16', 'lottie_target_34', {\"v\": \"5.9.2\", \"fr\": 60, \"ip\": 0, \"op\": 120, \"w\": 512, \"h\": 512, \"nm\": \"3d layers\", \"ddd\": 1, \"layers\": [{\"ddd\": 1, \"ind\": 2, \"ty\": 4, \"nm\": \"Blue Circle\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [256, 256, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"el\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ind\": 2, \"ty\": 4, \"nm\": \"Yellow Square\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 30}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [256, 256, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"o\": {\"a\": 0, \"k\": 100}}]}]}, function (lottie, data) { lottie.layers[1].ks.a.k = [ data[\"ax\"], data[\"ay\"], data[\"az\"] ]; lottie.layers[1].ks.p.k = [ data[\"px\"], data[\"py\"], data[\"pz\"] ]; lottie.layers[1].ks.or.k = [ data[\"orx\"], data[\"ory\"], data[\"orz\"] ]; lottie.layers[1].ks.s.k = [ data[\"sx\"], data[\"sy\"], data[\"sz\"] ]; lottie.layers[1].ks.rx.k = data[\"rx\"]; lottie.layers[1].ks.ry.k = data[\"ry\"]; lottie.layers[1].ks.rz.k = data[\"rz\"]; this.json_viewer_contents = lottie.layers[1].ks; }, {\"renderer\": \"html\"} ); Camera Layer Camera for 3D layers. Composition Diagram for Camera Layer Camera Layer Layer Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ddd 0-1 integer Threedimensional Whether the layer is threedimensional hd boolean Hidden Whether the layer is hidden ty integer = 13 Type Layer type ind integer Index Index that can be used for parenting and referenced in expressions parent integer Parent Index Must be the ind property of another layer sr number Time Stretch Time Stretch ip number In Point Frame when the layer becomes visible op number Out Point Frame when the layer becomes invisible st number Start Time Start Time ks Transform Transform Layer transform pe Scalar Perspective Distance from the Z=0 plane. Small values yield a higher perspective effect. Perspective Position 256 X 0 Y 0 Z Rotation -10 X 0 Y 0 Z Orientation 0 X 0 Y 0 Z 0 var lottie_player_35 = new PlaygroundPlayer( 35, 'playground_35_11', 'lottie_target_35', {\"v\": \"5.9.2\", \"fr\": 60, \"ip\": 0, \"op\": 120, \"w\": 512, \"h\": 512, \"nm\": \"3d layers\", \"ddd\": 1, \"layers\": [{\"ddd\": 1, \"ty\": 13, \"nm\": \"Camera\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, -10]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"pe\": {\"a\": 0, \"k\": 256}}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Page\", \"ks\": {\"o\": {\"a\": 0, \"k\": 50}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 1, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Front\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, 200]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.5, 0.5, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall FR\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [141, 0, 141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 0.5, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall FL\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": -45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [-141, 0, 141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 0.5, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Left\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": -90}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [-200, 0, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 0.5, 0.5]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Right\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 90}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [200, 0, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 0.5, 0.5]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall BR\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": -45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [141, 0, -141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 0.5, 0]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall BL\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [-141, 0, -141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 0.5, 0]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Back\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, -200]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.5, 0.5, 0]}, \"o\": {\"a\": 0, \"k\": 100}}]}]}, function (lottie, data) { var index = 0; lottie.layers[index].ks.p.k = [ data[\"px\"], data[\"py\"], data[\"pz\"] ]; lottie.layers[index].ks.or.k = [ data[\"orx\"], data[\"ory\"], data[\"orz\"] ]; lottie.layers[index].ks.rx.k = data[\"rx\"]; lottie.layers[index].ks.ry.k = data[\"ry\"]; lottie.layers[index].ks.rz.k = data[\"rz\"]; lottie.layers[index].pe.k = data[\"Perspective\"]; this.json_viewer_contents = lottie.layers[0]; }, {\"renderer\": \"html\"} ); 3D Parenting As with 2D layers, you can parent 3D layers. X 0 Y 0 Z Rotation -10 X 0 Y 0 Z Orientation 0 X 0 Y 0 Z 0 var lottie_player_36 = new PlaygroundPlayer( 36, 'playground_36_10', 'lottie_target_36', {\"v\": \"5.9.2\", \"fr\": 60, \"ip\": 0, \"op\": 120, \"w\": 512, \"h\": 512, \"nm\": \"3d layers\", \"ddd\": 1, \"layers\": [{\"ddd\": 1, \"ty\": 13, \"nm\": \"Camera\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, -10]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"pe\": {\"a\": 0, \"k\": 256}}, {\"ddd\": 1, \"ty\": 4, \"ind\": 1, \"nm\": \"Parent\", \"ks\": {\"o\": {\"a\": 0, \"k\": 50}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 1, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Front\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, 200]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.5, 0.5, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall FR\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [141, 0, 141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 0.5, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall FL\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": -45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [-141, 0, 141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 0.5, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Left\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": -90}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [-200, 0, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 0.5, 0.5]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Right\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 90}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [200, 0, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 0.5, 0.5]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall BR\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": -45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [141, 0, -141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 0.5, 0]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall BL\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [-141, 0, -141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 0.5, 0]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Back\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, -200]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.5, 0.5, 0]}, \"o\": {\"a\": 0, \"k\": 100}}]}]}, function (lottie, data) { var index = 1; lottie.layers[index].ks.p.k = [ data[\"px\"], data[\"py\"], data[\"pz\"] ]; lottie.layers[index].ks.or.k = [ data[\"orx\"], data[\"ory\"], data[\"orz\"] ]; lottie.layers[index].ks.rx.k = data[\"rx\"]; lottie.layers[index].ks.ry.k = data[\"ry\"]; lottie.layers[index].ks.rz.k = data[\"rz\"]; this.json_viewer_contents = lottie.layers[1]; }, {\"renderer\": \"html\"} ); Data Layer This layer links to a data source . Composition Diagram for Data Layer Data Layer Layer Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ddd 0-1 integer Threedimensional Whether the layer is threedimensional hd boolean Hidden Whether the layer is hidden ty integer = 15 Type Layer type ind integer Index Index that can be used for parenting and referenced in expressions parent integer Parent Index Must be the ind property of another layer sr number Time Stretch Time Stretch ip number In Point Frame when the layer becomes visible op number Out Point Frame when the layer becomes invisible st number Start Time Start Time refId string Data source Id ID of the data source in assets","title":"Layers"},{"location":"layers/#layers","text":"","title":"Layers"},{"location":"layers/#layer","text":"Common properties for all layers Composition Diagram for Layer Layer Visual Object Data Layer Audio Layer Camera Layer Visual Layer Precomposition Layer Null Layer Image Layer Solid Layer Text Layer Shape Layer Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ddd 0-1 integer Threedimensional Whether the layer is threedimensional hd boolean Hidden Whether the layer is hidden ty integer Type Layer Type ind integer Index Index that can be used for parenting and referenced in expressions parent integer Parent Index Must be the ind property of another layer sr number Time Stretch Time Stretch ip number In Point Frame when the layer becomes visible op number Out Point Frame when the layer becomes invisible st number Start Time Start Time The ty property defines the specific layer type based on the following values: ty Type 0 Precomposition Layer 1 Solid Layer 2 Image Layer 3 Null Layer 4 Shape Layer 5 Text Layer 6 Audio Layer 15 Data Layer 13 Camera Layer","title":"Layer"},{"location":"layers/#visual-layer","text":"Layer used to affect visual elements Composition Diagram for Visual Layer Visual Layer Layer Visual Object Precomposition Layer Null Layer Image Layer Solid Layer Text Layer Shape Layer Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ddd 0-1 integer Threedimensional Whether the layer is threedimensional hd boolean Hidden Whether the layer is hidden ty integer Type Layer Type ind integer Index Index that can be used for parenting and referenced in expressions parent integer Parent Index Must be the ind property of another layer sr number Time Stretch Time Stretch ip number In Point Frame when the layer becomes visible op number Out Point Frame when the layer becomes invisible st number Start Time Start Time ks Transform Transform Layer transform ao 0-1 integer Auto Orient If 1, the layer will rotate itself to match its animated position path tt Matte Mode Matte Mode Defines the track matte mode for the layer tp integer Matte Parent Index of the layer used as matte, if omitted assume the layer above the current one td 0-1 integer Matte Target If set to 1, it means a layer is using this layer as a track matte hasMask boolean Has Masks Whether the layer has masks applied masksProperties array of Mask Masks Optional array of masks for the layer. ef array of Effect Effects List of layer effects mb boolean Motion Blur Whether motion blur is enabled for the layer sy array of Layer Style Layer style Styling effects for this layer bm Blend Mode Blend Mode Blend Mode cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer tg string Layer XML tag name tag name used by the SVG renderer cp boolean Collapse Transform This is deprecated in favour of ct ct 0-1 integer Collapse Transform Marks that transforms should be applied before masks Note that layers that don't have a visual component (Audio layers for example), won't have a transform and similar. The layer is only visible between its ip and op . If they match the corresponding attributes in Animation , the layer will be visible the whole time, otherwise it will become visible at the frame ip and disappear at op .","title":"Visual Layer"},{"location":"layers/#parenting","text":"Within a list of layers, the ind attribute (if present) must be unique. Layers having a parent attribute matching another layer will inherit their parent's transform (except for opacity). Basically you need multiply the transform matrix by the parent's transform matrix to get a child layer's final transform. The flat layer structure and flexible parenting allows more flexibility but it's different from the more traditional approach of nesting child layers inside the parent layer (like a folder structure). One of the advantages of flexible parenting is you can have children of the same layer be intermixed with unrelated layers. In the following example, the star and the ellipse are in separate layers, but both have the same parent, which moves left and right. Between the two there's an additional layer with the rectangle. var lottie_player_26 = new LottiePlayer( 'lottie_target_26', '../static/examples/parenting.json', true, {} );","title":"Parenting"},{"location":"layers/#auto-orient","text":"When true, if the transform position is animated, it rotates the layer along the path the position follows. In the following example there are two arrows animated along the same path, with no rotation when the position moves towards the right. The transparent one keeps its rotation the same ( ao is 0), while the solid one follows the path ( ao is 1). var lottie_player_27 = new LottiePlayer( 'lottie_target_27', '../static/examples/auto_orient.json', true, {} );","title":"Auto Orient"},{"location":"layers/#mattes","text":"A matte allows using a layer as a mask for another layer. The way it works is the layer defining the mask has a tt attribute with the appropriate value . By defaults it affects the layer on top (the layer before it in the layer list, which has the td attribute), otherwise check the tp attribute. In this example there's a layer with a rectangle and a star being masked by an ellipse: Example Enable Matte Matte Mode Normal Alpha Inverted Alpha Luma Inverted Luma var lottie_player_28 = new PlaygroundPlayer( 28, 'playground_28_3', 'lottie_target_28', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{b3d1b083-9de7-4537-a691-fc9aa42f9742}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 1, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Ellipse (Mask)\", \"ks\": {\"a\": {\"a\": 0, \"k\": [153, 294]}, \"p\": {\"a\": 0, \"k\": [346, 211]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{261eddeb-af92-4be1-932c-790b00c23933}\", \"p\": {\"a\": 0, \"k\": [137.0955223880597, 293.60820895522386]}, \"s\": {\"a\": 0, \"k\": [303.42089552238804, 315.55074626865667]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{aa9c282c-253d-4d8d-ab05-4819c592fa85}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 1, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{2b2b0002-ff0c-4978-a33b-db4e0498848d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}], \"td\": 1}, {\"ddd\": 0, \"ty\": 4, \"ind\": 2, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Shapes (Masked)\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{528994b7-40ff-4d12-81f8-603f274da12e}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{ce8756d7-289f-4f84-a135-d225d57c42e0}\", \"p\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"or\": {\"a\": 0, \"k\": 216.4160919189453}, \"ir\": {\"a\": 0, \"k\": 87.03440856933594}, \"r\": {\"a\": 0, \"k\": 261.54803466796875}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{efd05a25-a43b-451d-83d2-53a477087223}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{523ca39c-9e57-4547-bf0e-ba7496003579}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"p\": {\"a\": 0, \"k\": [338.7223880597015, 209.76716417910447]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"Rectangle\", \"mn\": \"{d2d7a5d5-6d91-42e8-b40a-af52a112fe38}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{9ef8604e-7891-4909-a655-445131b4d842}\", \"p\": {\"a\": 0, \"k\": [209.17611940298502, 226.8]}, \"s\": {\"a\": 0, \"k\": [363.3313432835821, 369.3492537313433]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{444584d2-cb59-4cba-83a1-82cc605837fd}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{f75aed67-9b0e-41a9-b859-a14b5b0a320d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.7686274509803922, 0.8509803921568627, 0.9607843137254902]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"p\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}], \"tt\": 1, \"tp\": 1}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { if ( data[\"Enable Matte\"] ) { lottie.layers[1].tt = Number(data[\"Matte Mode\"]); lottie.layers[1].tp = 1; lottie.layers[0].td = 1; } else { lottie.layers[1].tt = undefined; lottie.layers[1].tp = undefined; lottie.layers[0].td = undefined; } this.json_viewer_contents = {...lottie.layers[1], shapes: [], ks: {}}; }, {} );","title":"Mattes"},{"location":"layers/#masks","text":"A layer can have an array of masks that clip the contents of the layer to a shape. This is similar to mattes , but there are a few differences. With mattes, you use a layer to define the clipping area, while with masks you use an animated bezier curve . Example Mode None Add Subtract Intersect Lighten Darken Difference Opacity 100 Invert Expand 0 var lottie_player_29 = new PlaygroundPlayer( 29, 'playground_29_5', 'lottie_target_29', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{b3d1b083-9de7-4537-a691-fc9aa42f9742}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 2, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Shapes\", \"ks\": {}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{528994b7-40ff-4d12-81f8-603f274da12e}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{ce8756d7-289f-4f84-a135-d225d57c42e0}\", \"p\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"or\": {\"a\": 0, \"k\": 216.4160919189453}, \"ir\": {\"a\": 0, \"k\": 87.03440856933594}, \"r\": {\"a\": 0, \"k\": 261.54803466796875}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{efd05a25-a43b-451d-83d2-53a477087223}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{523ca39c-9e57-4547-bf0e-ba7496003579}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [427.2716417910448, 194.29253731343283]}, \"p\": {\"a\": 0, \"k\": [338.7223880597015, 209.76716417910447]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"Rectangle\", \"mn\": \"{d2d7a5d5-6d91-42e8-b40a-af52a112fe38}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{9ef8604e-7891-4909-a655-445131b4d842}\", \"p\": {\"a\": 0, \"k\": [209.17611940298502, 226.8]}, \"s\": {\"a\": 0, \"k\": [363.3313432835821, 369.3492537313433]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{444584d2-cb59-4cba-83a1-82cc605837fd}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{f75aed67-9b0e-41a9-b859-a14b5b0a320d}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.7686274509803922, 0.8509803921568627, 0.9607843137254902]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"p\": {\"a\": 0, \"k\": [256.1910447761194, 273.8149253731343]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}], \"hasMask\": true, \"masksProperties\": [{\"mode\": \"a\", \"o\": {\"a\": 0, \"k\": 100}, \"inv\": false, \"x\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [[247.109, 125.719], [66.109, 306.719], [424.109, 389.719]], \"i\": [[0, 0], [0, 0], [0, 0]], \"o\": [[0, 0], [0, 0], [0, 0]]}}}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let mask = lottie.layers[0].masksProperties[0]; mask.o.k = Number(data[\"Opacity\"]); mask.inv = data[\"Invert\"]; mask.x.k = Number(data[\"Expand\"]); mask.mode = data[\"Mode\"]; this.json_viewer_contents = lottie.layers[0].masksProperties[0]; }, {} );","title":"Masks"},{"location":"layers/#lists-of-layers-and-shapes","text":"Such lists appear Precomposition, Animation, ShapeLayer, and Groop. In such lists, items coming first will be rendered on top So if you have for example: [Ellipse, Rectangle] The ellipse will show on top of the rectangle: var lottie_player_30 = new LottiePlayer( 'lottie_target_30', '../static/examples/layer_order.json', true, {} ); This means the render order goes from the last element to the first.","title":"Lists of layers and shapes"},{"location":"layers/#shape-layer","text":"Renders vector data. The only special property for this layer is shapes , an array of shapes . Composition Diagram for Shape Layer Shape Layer Visual Layer Layer Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ddd 0-1 integer Threedimensional Whether the layer is threedimensional hd boolean Hidden Whether the layer is hidden ty integer = 4 Type Layer type ind integer Index Index that can be used for parenting and referenced in expressions parent integer Parent Index Must be the ind property of another layer sr number Time Stretch Time Stretch ip number In Point Frame when the layer becomes visible op number Out Point Frame when the layer becomes invisible st number Start Time Start Time ks Transform Transform Layer transform ao 0-1 integer Auto Orient If 1, the layer will rotate itself to match its animated position path tt Matte Mode Matte Mode Defines the track matte mode for the layer tp integer Matte Parent Index of the layer used as matte, if omitted assume the layer above the current one td 0-1 integer Matte Target If set to 1, it means a layer is using this layer as a track matte hasMask boolean Has Masks Whether the layer has masks applied masksProperties array of Mask Masks Optional array of masks for the layer. ef array of Effect Effects List of layer effects mb boolean Motion Blur Whether motion blur is enabled for the layer sy array of Layer Style Layer style Styling effects for this layer bm Blend Mode Blend Mode Blend Mode cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer tg string Layer XML tag name tag name used by the SVG renderer cp boolean Collapse Transform This is deprecated in favour of ct ct 0-1 integer Collapse Transform Marks that transforms should be applied before masks shapes array of Graphic Element Shapes Shapes","title":"Shape Layer"},{"location":"layers/#precomposition-layer","text":"This layer renders a precomposition . You can find more details in the Precompositions page. Composition Diagram for Precomposition Layer Precomposition Layer Visual Layer Layer Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ddd 0-1 integer Threedimensional Whether the layer is threedimensional hd boolean Hidden Whether the layer is hidden ty integer = 0 Type Layer type ind integer Index Index that can be used for parenting and referenced in expressions parent integer Parent Index Must be the ind property of another layer sr number Time Stretch Time Stretch ip number In Point Frame when the layer becomes visible op number Out Point Frame when the layer becomes invisible st number Start Time Start Time ks Transform Transform Layer transform ao 0-1 integer Auto Orient If 1, the layer will rotate itself to match its animated position path tt Matte Mode Matte Mode Defines the track matte mode for the layer tp integer Matte Parent Index of the layer used as matte, if omitted assume the layer above the current one td 0-1 integer Matte Target If set to 1, it means a layer is using this layer as a track matte hasMask boolean Has Masks Whether the layer has masks applied masksProperties array of Mask Masks Optional array of masks for the layer. ef array of Effect Effects List of layer effects mb boolean Motion Blur Whether motion blur is enabled for the layer sy array of Layer Style Layer style Styling effects for this layer bm Blend Mode Blend Mode Blend Mode cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer tg string Layer XML tag name tag name used by the SVG renderer cp boolean Collapse Transform This is deprecated in favour of ct ct 0-1 integer Collapse Transform Marks that transforms should be applied before masks refId string Reference Id ID of the precomp as specified in the assets w integer Width Width of the clipping rect h integer Height Height of the clipping rect tm Scalar Time Remap Timeline remap function (frame index -> time in seconds)","title":"Precomposition Layer"},{"location":"layers/#time-remapping","text":"The tm property maps the time in seconds of the precomposition to show. Basically you get the value of tm at the current frame, then assume that's a time in seconds since the start of the animation, and render the corresponding frame of the precomposition. Follows an example of this, here there are two layers showing the same precomposition, the one at the top right keeps the original time while the bottom one remaps time as follows: frame 0 (0s) maps to 0s (frame 0) in the precomp frame 30 (0.5s) maps to 3s (frame 180) in the precomp frame 60 (1s) maps to 1.5s (frame 90) in the precomp frame 180 (3s) maps to 3s (frame 180) in the precomp Basically it makes the precomp play in the first half second, then rewind to half way for the next half second, and plays back to the end for the remaining 2 seconds. var lottie_player_31 = new PlaygroundPlayer( 31, 'playground_31_1', 'lottie_target_31', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{7820523d-dd32-453b-b311-50323a49e4df}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"nm\": \"Composition\", \"mn\": \"{4d838004-a221-48cb-966f-399347c5acb8}\", \"id\": \"{4d838004-a221-48cb-966f-399347c5acb8}\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer 1\", \"mn\": \"{8afc4794-97eb-4533-814b-f92676e324f5}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar 1\", \"mn\": \"{600eb536-73f0-415d-8743-01dd2f26e2b7}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar 1\", \"mn\": \"{0d81b309-da59-4646-812d-ed9212679e27}\", \"p\": {\"a\": 0, \"k\": [166.49999999999997, 144.89999999999998]}, \"or\": {\"a\": 0, \"k\": 103.60950469970703}, \"ir\": {\"a\": 0, \"k\": 51.804752349853516}, \"r\": {\"a\": 0, \"k\": 147.41429138183594}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"hd\": true, \"nm\": \"Stroke\", \"mn\": \"{5271148f-841e-4e99-9f23-e0b201b46def}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5019607843137255, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{c72fab9f-6a71-4e30-966c-1b863389d19a}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [166.49999999999997, 144.89999999999998]}, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [106.19999999999997, 126.89999999999998], \"h\": 0, \"o\": {\"x\": [0.3333333333333333], \"y\": [0]}, \"i\": {\"x\": [0.6666666666666666], \"y\": [1]}, \"e\": [413.99999999999994, 413.09999999999997]}, {\"t\": 180, \"s\": [413.99999999999994, 413.09999999999997]}]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}]}], \"layers\": [{\"ty\": 0, \"ddd\": 0, \"nm\": \"Composition\", \"mn\": \"{e3aa5446-47d2-454e-8d20-ed3c5f15612e}\", \"ip\": 0, \"op\": 180, \"ind\": 2, \"st\": 0, \"sr\": 1, \"ks\": {\"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [50, 50]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"refId\": \"{4d838004-a221-48cb-966f-399347c5acb8}\", \"w\": 512, \"h\": 512}, {\"ty\": 0, \"ddd\": 0, \"nm\": \"Remapped\", \"mn\": \"{0f7b917c-b0e8-450f-bb63-812dff786620}\", \"ip\": 0, \"op\": 180, \"ind\": 1, \"st\": 0, \"sr\": 1, \"tm\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 30, \"s\": [3], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 60, \"s\": [1.5], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}, {\"t\": 180, \"s\": [3], \"o\": {\"x\": 0, \"y\": 0}, \"i\": {\"x\": 1, \"y\": 1}}]}, \"ks\": {\"a\": {\"a\": 0, \"k\": [512, 512]}, \"p\": {\"a\": 0, \"k\": [512, 512]}, \"s\": {\"a\": 0, \"k\": [50, 50]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"refId\": \"{4d838004-a221-48cb-966f-399347c5acb8}\", \"w\": 512, \"h\": 512}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { this.json_viewer_contents = {...lottie.layers[1], ks:{}}; }, {} );","title":"Time remapping"},{"location":"layers/#null-layer","text":"This layer doesn't have any special properties. It's often used by animators as a parent to multiple other layers (see parenting ). Composition Diagram for Null Layer Null Layer Visual Layer Layer Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ddd 0-1 integer Threedimensional Whether the layer is threedimensional hd boolean Hidden Whether the layer is hidden ty integer = 3 Type Layer type ind integer Index Index that can be used for parenting and referenced in expressions parent integer Parent Index Must be the ind property of another layer sr number Time Stretch Time Stretch ip number In Point Frame when the layer becomes visible op number Out Point Frame when the layer becomes invisible st number Start Time Start Time ks Transform Transform Layer transform ao 0-1 integer Auto Orient If 1, the layer will rotate itself to match its animated position path tt Matte Mode Matte Mode Defines the track matte mode for the layer tp integer Matte Parent Index of the layer used as matte, if omitted assume the layer above the current one td 0-1 integer Matte Target If set to 1, it means a layer is using this layer as a track matte hasMask boolean Has Masks Whether the layer has masks applied masksProperties array of Mask Masks Optional array of masks for the layer. ef array of Effect Effects List of layer effects mb boolean Motion Blur Whether motion blur is enabled for the layer sy array of Layer Style Layer style Styling effects for this layer bm Blend Mode Blend Mode Blend Mode cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer tg string Layer XML tag name tag name used by the SVG renderer cp boolean Collapse Transform This is deprecated in favour of ct ct 0-1 integer Collapse Transform Marks that transforms should be applied before masks","title":"Null Layer"},{"location":"layers/#text-layer","text":"For text data, please refer to the section about text for details. Composition Diagram for Text Layer Text Layer Visual Layer Layer Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ddd 0-1 integer Threedimensional Whether the layer is threedimensional hd boolean Hidden Whether the layer is hidden ty integer = 5 Type Layer type ind integer Index Index that can be used for parenting and referenced in expressions parent integer Parent Index Must be the ind property of another layer sr number Time Stretch Time Stretch ip number In Point Frame when the layer becomes visible op number Out Point Frame when the layer becomes invisible st number Start Time Start Time ks Transform Transform Layer transform ao 0-1 integer Auto Orient If 1, the layer will rotate itself to match its animated position path tt Matte Mode Matte Mode Defines the track matte mode for the layer tp integer Matte Parent Index of the layer used as matte, if omitted assume the layer above the current one td 0-1 integer Matte Target If set to 1, it means a layer is using this layer as a track matte hasMask boolean Has Masks Whether the layer has masks applied masksProperties array of Mask Masks Optional array of masks for the layer. ef array of Effect Effects List of layer effects mb boolean Motion Blur Whether motion blur is enabled for the layer sy array of Layer Style Layer style Styling effects for this layer bm Blend Mode Blend Mode Blend Mode cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer tg string Layer XML tag name tag name used by the SVG renderer cp boolean Collapse Transform This is deprecated in favour of ct ct 0-1 integer Collapse Transform Marks that transforms should be applied before masks t Text Data Data Data","title":"Text Layer"},{"location":"layers/#image-layer","text":"This layer renders a static image . Composition Diagram for Image Layer Image Layer Visual Layer Layer Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ddd 0-1 integer Threedimensional Whether the layer is threedimensional hd boolean Hidden Whether the layer is hidden ty integer = 2 Type Layer type ind integer Index Index that can be used for parenting and referenced in expressions parent integer Parent Index Must be the ind property of another layer sr number Time Stretch Time Stretch ip number In Point Frame when the layer becomes visible op number Out Point Frame when the layer becomes invisible st number Start Time Start Time ks Transform Transform Layer transform ao 0-1 integer Auto Orient If 1, the layer will rotate itself to match its animated position path tt Matte Mode Matte Mode Defines the track matte mode for the layer tp integer Matte Parent Index of the layer used as matte, if omitted assume the layer above the current one td 0-1 integer Matte Target If set to 1, it means a layer is using this layer as a track matte hasMask boolean Has Masks Whether the layer has masks applied masksProperties array of Mask Masks Optional array of masks for the layer. ef array of Effect Effects List of layer effects mb boolean Motion Blur Whether motion blur is enabled for the layer sy array of Layer Style Layer style Styling effects for this layer bm Blend Mode Blend Mode Blend Mode cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer tg string Layer XML tag name tag name used by the SVG renderer cp boolean Collapse Transform This is deprecated in favour of ct ct 0-1 integer Collapse Transform Marks that transforms should be applied before masks refId string Reference Id ID of the image as specified in the assets","title":"Image Layer"},{"location":"layers/#solid-layer","text":"This layer represents a rectangle with a single color. Anything you can do with solid layers, you can do better with a shape layer and a rectangle shape since none of this layer's own properties can be animated. Note that the color is represented as a string, unlike most other places. Composition Diagram for Solid Layer Solid Layer Visual Layer Layer Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ddd 0-1 integer Threedimensional Whether the layer is threedimensional hd boolean Hidden Whether the layer is hidden ty integer = 1 Type Layer type ind integer Index Index that can be used for parenting and referenced in expressions parent integer Parent Index Must be the ind property of another layer sr number Time Stretch Time Stretch ip number In Point Frame when the layer becomes visible op number Out Point Frame when the layer becomes invisible st number Start Time Start Time ks Transform Transform Layer transform ao 0-1 integer Auto Orient If 1, the layer will rotate itself to match its animated position path tt Matte Mode Matte Mode Defines the track matte mode for the layer tp integer Matte Parent Index of the layer used as matte, if omitted assume the layer above the current one td 0-1 integer Matte Target If set to 1, it means a layer is using this layer as a track matte hasMask boolean Has Masks Whether the layer has masks applied masksProperties array of Mask Masks Optional array of masks for the layer. ef array of Effect Effects List of layer effects mb boolean Motion Blur Whether motion blur is enabled for the layer sy array of Layer Style Layer style Styling effects for this layer bm Blend Mode Blend Mode Blend Mode cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer tg string Layer XML tag name tag name used by the SVG renderer cp boolean Collapse Transform This is deprecated in favour of ct ct 0-1 integer Collapse Transform Marks that transforms should be applied before masks sw integer Width Solid rectangle width sh integer Height Solid rectangle height sc Hex Color Color Solid fill color Color Width 512 Height 512 var lottie_player_32 = new PlaygroundPlayer( 32, 'playground_32_4', 'lottie_target_32', {\"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"layers\": [{\"ty\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {}, \"sc\": \"#ff0000\", \"sh\": 512, \"sw\": 512}]}, function (lottie, data) { lottie.layers[0].sc = data[\"Color\"]; lottie.layers[0].sw = Number(data[\"Width\"]); lottie.layers[0].sh = Number(data[\"Height\"]); this.json_viewer_contents = lottie.layers[0]; }, {} );","title":"Solid Layer"},{"location":"layers/#audio-layer","text":"This layer plays a sound . Composition Diagram for Audio Layer Audio Layer Layer Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ddd 0-1 integer Threedimensional Whether the layer is threedimensional hd boolean Hidden Whether the layer is hidden ty integer = 6 Type Layer type ind integer Index Index that can be used for parenting and referenced in expressions parent integer Parent Index Must be the ind property of another layer sr number Time Stretch Time Stretch ip number In Point Frame when the layer becomes visible op number Out Point Frame when the layer becomes invisible st number Start Time Start Time au Audio Settings Audio Settings Audio Settings refId string Sound Id ID of the sound as specified in the assets","title":"Audio Layer"},{"location":"layers/#audio-settings","text":"Attribute Type Title Description lv Vector Level Level","title":"Audio Settings"},{"location":"layers/#3d-layers","text":"Layers can have 3D transforms as well: var lottie_player_33 = new LottiePlayer( 'lottie_target_33', '../static/examples/3d_layers_animation.json', true, {\"renderer\": \"html\"} ); 3D layers need to have the ddd set to 1 (and so does the top-level object). Their transform will habe a and p specified as 3D components. Rotation will be split into 3 properties: rx , ry , rz , and you have and additional orientation property or . X 0 Y 0 Z Position 0 X 256 Y 256 Z Rotation 0 X 0 Y 30 Z Orientation 0 X 0 Y 0 Z Scale 0 X 100 Y 100 Z 100 var lottie_player_34 = new PlaygroundPlayer( 34, 'playground_34_16', 'lottie_target_34', {\"v\": \"5.9.2\", \"fr\": 60, \"ip\": 0, \"op\": 120, \"w\": 512, \"h\": 512, \"nm\": \"3d layers\", \"ddd\": 1, \"layers\": [{\"ddd\": 1, \"ind\": 2, \"ty\": 4, \"nm\": \"Blue Circle\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [256, 256, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"el\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ind\": 2, \"ty\": 4, \"nm\": \"Yellow Square\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 30}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [256, 256, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 1, 0.3]}, \"o\": {\"a\": 0, \"k\": 100}}]}]}, function (lottie, data) { lottie.layers[1].ks.a.k = [ data[\"ax\"], data[\"ay\"], data[\"az\"] ]; lottie.layers[1].ks.p.k = [ data[\"px\"], data[\"py\"], data[\"pz\"] ]; lottie.layers[1].ks.or.k = [ data[\"orx\"], data[\"ory\"], data[\"orz\"] ]; lottie.layers[1].ks.s.k = [ data[\"sx\"], data[\"sy\"], data[\"sz\"] ]; lottie.layers[1].ks.rx.k = data[\"rx\"]; lottie.layers[1].ks.ry.k = data[\"ry\"]; lottie.layers[1].ks.rz.k = data[\"rz\"]; this.json_viewer_contents = lottie.layers[1].ks; }, {\"renderer\": \"html\"} );","title":"3D Layers"},{"location":"layers/#camera-layer","text":"Camera for 3D layers. Composition Diagram for Camera Layer Camera Layer Layer Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ddd 0-1 integer Threedimensional Whether the layer is threedimensional hd boolean Hidden Whether the layer is hidden ty integer = 13 Type Layer type ind integer Index Index that can be used for parenting and referenced in expressions parent integer Parent Index Must be the ind property of another layer sr number Time Stretch Time Stretch ip number In Point Frame when the layer becomes visible op number Out Point Frame when the layer becomes invisible st number Start Time Start Time ks Transform Transform Layer transform pe Scalar Perspective Distance from the Z=0 plane. Small values yield a higher perspective effect. Perspective Position 256 X 0 Y 0 Z Rotation -10 X 0 Y 0 Z Orientation 0 X 0 Y 0 Z 0 var lottie_player_35 = new PlaygroundPlayer( 35, 'playground_35_11', 'lottie_target_35', {\"v\": \"5.9.2\", \"fr\": 60, \"ip\": 0, \"op\": 120, \"w\": 512, \"h\": 512, \"nm\": \"3d layers\", \"ddd\": 1, \"layers\": [{\"ddd\": 1, \"ty\": 13, \"nm\": \"Camera\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, -10]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"pe\": {\"a\": 0, \"k\": 256}}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Page\", \"ks\": {\"o\": {\"a\": 0, \"k\": 50}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 1, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Front\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, 200]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.5, 0.5, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall FR\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [141, 0, 141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 0.5, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall FL\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": -45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [-141, 0, 141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 0.5, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Left\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": -90}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [-200, 0, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 0.5, 0.5]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Right\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 90}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [200, 0, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 0.5, 0.5]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall BR\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": -45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [141, 0, -141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 0.5, 0]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall BL\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [-141, 0, -141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 0.5, 0]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Back\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, -200]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.5, 0.5, 0]}, \"o\": {\"a\": 0, \"k\": 100}}]}]}, function (lottie, data) { var index = 0; lottie.layers[index].ks.p.k = [ data[\"px\"], data[\"py\"], data[\"pz\"] ]; lottie.layers[index].ks.or.k = [ data[\"orx\"], data[\"ory\"], data[\"orz\"] ]; lottie.layers[index].ks.rx.k = data[\"rx\"]; lottie.layers[index].ks.ry.k = data[\"ry\"]; lottie.layers[index].ks.rz.k = data[\"rz\"]; lottie.layers[index].pe.k = data[\"Perspective\"]; this.json_viewer_contents = lottie.layers[0]; }, {\"renderer\": \"html\"} );","title":"Camera Layer"},{"location":"layers/#3d-parenting","text":"As with 2D layers, you can parent 3D layers. X 0 Y 0 Z Rotation -10 X 0 Y 0 Z Orientation 0 X 0 Y 0 Z 0 var lottie_player_36 = new PlaygroundPlayer( 36, 'playground_36_10', 'lottie_target_36', {\"v\": \"5.9.2\", \"fr\": 60, \"ip\": 0, \"op\": 120, \"w\": 512, \"h\": 512, \"nm\": \"3d layers\", \"ddd\": 1, \"layers\": [{\"ddd\": 1, \"ty\": 13, \"nm\": \"Camera\", \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, -10]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"pe\": {\"a\": 0, \"k\": 256}}, {\"ddd\": 1, \"ty\": 4, \"ind\": 1, \"nm\": \"Parent\", \"ks\": {\"o\": {\"a\": 0, \"k\": 50}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 1, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Front\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, 200]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.5, 0.5, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall FR\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [141, 0, 141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 0.5, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall FL\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": -45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [-141, 0, 141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 0.5, 1]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Left\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": -90}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [-200, 0, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 0.5, 0.5]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Right\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 90}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [200, 0, 0]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 0.5, 0.5]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall BR\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": -45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [141, 0, -141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [1, 0.5, 0]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall BL\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 45}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [-141, 0, -141]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0, 0.5, 0]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ddd\": 1, \"ty\": 4, \"nm\": \"Wall Back\", \"parent\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100}, \"rx\": {\"a\": 0, \"k\": 0}, \"ry\": {\"a\": 0, \"k\": 0}, \"rz\": {\"a\": 0, \"k\": 0}, \"or\": {\"a\": 0, \"k\": [0, 0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0, -200]}, \"a\": {\"a\": 0, \"k\": [0, 0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100, 100]}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"shapes\": [{\"ty\": \"rc\", \"s\": {\"a\": 0, \"k\": [200, 200]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"fl\", \"c\": {\"a\": 0, \"k\": [0.5, 0.5, 0]}, \"o\": {\"a\": 0, \"k\": 100}}]}]}, function (lottie, data) { var index = 1; lottie.layers[index].ks.p.k = [ data[\"px\"], data[\"py\"], data[\"pz\"] ]; lottie.layers[index].ks.or.k = [ data[\"orx\"], data[\"ory\"], data[\"orz\"] ]; lottie.layers[index].ks.rx.k = data[\"rx\"]; lottie.layers[index].ks.ry.k = data[\"ry\"]; lottie.layers[index].ks.rz.k = data[\"rz\"]; this.json_viewer_contents = lottie.layers[1]; }, {\"renderer\": \"html\"} );","title":"3D Parenting"},{"location":"layers/#data-layer","text":"This layer links to a data source . Composition Diagram for Data Layer Data Layer Layer Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions ddd 0-1 integer Threedimensional Whether the layer is threedimensional hd boolean Hidden Whether the layer is hidden ty integer = 15 Type Layer type ind integer Index Index that can be used for parenting and referenced in expressions parent integer Parent Index Must be the ind property of another layer sr number Time Stretch Time Stretch ip number In Point Frame when the layer becomes visible op number Out Point Frame when the layer becomes invisible st number Start Time Start Time refId string Data source Id ID of the data source in assets","title":"Data Layer"},{"location":"properties/","text":"Propeties Animated Property Properties in Lottie can be animated. Their structure depends on whether it's animated or not: Composition Diagram for Property Property Gradient stops Position Property Vector Property Scalar Property Bezier Property Color Property Attribute Type Title Description ix integer Property Index Property Index x string Expression Expression sid string Slot ID One of the ID in the file's slots a 0-1 integer Animated Whether the property is animated k any or array of Keyframes Value or Keyframes When it's not animated, k will contain the value directly. When animated, k will be an array of keyframes. If a is 0 , then k just has the value of the property. If a is 1 , k will be an array of keyframes. Keyframes Composition Diagram for Base Keyframe Base Keyframe Vector Keyframe Position Keyframe Color Keyframe Shape Keyframe Gradient Keyframe Attribute Type Title Description t number Time Frame number h 0-1 integer Hold Hold i Keyframe Easing In Tangent Easing tangent going into the next keyframe o Keyframe Easing Out Tangent Easing tangent leaving the current keyframe If h is present and it's 1, you don't need i and o , as the property will keep the same value until the next keyframe. Keyframe Easing Attribute Type Title Description x Vector or number X Time component: 0 means start time of the keyframe, 1 means time of the next keyframe. y Vector or number Y Value interpolation component: 0 means start value of the keyframe, 1 means value at the next keyframe. They are objects with x and y attributes, which are numbers within 0 and 1. For multi-dimensional animated properties, these are arrays, with one element per dimension so you can have different easing curves per dimension. They represent a cubic bezier, starting at [0,0] and ending at [1,1] where the value determines the easing function. The x axis represents time, a value of 0 is the time of the current keyframe, a value of 1 is the time of the next keyframe. The y axis represents the value interpolation factor, a value of 0 represents the value at the current keyframe, a value of 1 represents the value at the next keyframe. When you use easing you have two easing handles for the keyframe: o is the \"out\" handle, and is the first one in the bezier, determines the curve as it exits the current keyframe. i is the \"in\" handle, and it's the second one in the bezier, determines the curve as it enters the next keyframe. For linear interpolation you'd have { \"o\": {\"x\": [0, 0], \"y\": [0, 0]}, \"i\": {\"x\": [1, 1], \"y\": [1, 1]} } For easing in and out, you move the x towards the center, this makes the animation more fluid: { \"o\": {\"x\": [0.333, 0.333], \"y\": [0, 0]}, \"i\": {\"x\": [0.667, 0.667], \"y\": [1, 1]} } Old Lottie Keyframes Old lotties have an additional attribute for keyframes, e which works similarly to s but represents the value at the end of the keyframe. They also have a final keyframe with only the t attribute and you need to determine its value based on the s value of the previous keyframe. Easing example In the following example, the ball moves left and right, on the background you can see a representation of its easing function. KeyframePreviewEditor.stand_alone(document.getElementById(\"editor_37\"), (lottie) => { var raw_json = JSON.stringify(lottie, undefined, 4); var pretty_json = hljs.highlight(\"json\", raw_json).value; document.getElementById(\"json_viewer_37\").innerHTML = pretty_json; }, ); Property types Vector Animatable Vector . Composition Diagram for Vector Property Vector Property Property Attribute Type Title Description ix integer Property Index Property Index x string Expression Expression sid string Slot ID One of the ID in the file's slots a 0-1 integer Animated Whether the property is animated l integer Length Number of components in the value arrays. If present values will be truncated or expanded to match this length when accessed from expressions. k Vector or array Value Static Value or Array of keyframes Vector Keyframe Composition Diagram for Vector Keyframe Vector Keyframe Base Keyframe Position Keyframe Attribute Type Title Description t number Time Frame number h 0-1 integer Hold Hold i Keyframe Easing In Tangent Easing tangent going into the next keyframe o Keyframe Easing Out Tangent Easing tangent leaving the current keyframe s Vector Value Value at this keyframe. e Vector End value Value at the end of the keyframe, note that this is deprecated and you should use s from the next keyframe to get this value Scalar Animatable scalar (single number value). Note that when animated it uses Vector Keyframes , so instead of scalars keyframes have arrays with a single values. Composition Diagram for Scalar Property Scalar Property Property Attribute Type Title Description ix integer Property Index Property Index x string Expression Expression sid string Slot ID One of the ID in the file's slots a 0-1 integer Animated Whether the property is animated k number or array Value Static Value or Array of keyframes Position Animatable 2D Vector with optional spatial tangents. Composition Diagram for Position Property Position Property Property Attribute Type Title Description ix integer Property Index Property Index x string Expression Expression sid string Slot ID One of the ID in the file's slots a 0-1 integer Animated Whether the property is animated l integer Length Number of components in the value arrays. If present values will be truncated or expanded to match this length when accessed from expressions. k Vector or array Value Static Value or Array of keyframes Position Keyframe Composition Diagram for Position Keyframe Position Keyframe Vector Keyframe Base Keyframe Attribute Type Title Description t number Time Frame number h 0-1 integer Hold Hold i Keyframe Easing In Tangent Easing tangent going into the next keyframe o Keyframe Easing Out Tangent Easing tangent leaving the current keyframe s Vector Value Value at this keyframe. e Vector End value Value at the end of the keyframe, note that this is deprecated and you should use s from the next keyframe to get this value ti Vector Value In Tangent Tangent for values (eg: moving position around a curved path) to Vector Value Out Tangent Tangent for values (eg: moving position around a curved path) Split Position An animatable position where position values may be defined and animated separately. Attribute Type Title Description s boolean = True Split Whether the position has split values x Scalar X Position X Position y Scalar Y Position Y Position Bezier Shape Animatable Bezier . Composition Diagram for Bezier Property Bezier Property Property Attribute Type Title Description ix integer Property Index Property Index x string Expression Expression sid string Slot ID One of the ID in the file's slots a 0-1 integer Animated Whether the property is animated k Bezier or array Value Static Value or Array of keyframes Bezier Shape Keyframe Composition Diagram for Shape Keyframe Shape Keyframe Base Keyframe Attribute Type Title Description t number Time Frame number h 0-1 integer Hold Hold i Keyframe Easing In Tangent Easing tangent going into the next keyframe o Keyframe Easing Out Tangent Easing tangent leaving the current keyframe s array of Bezier Value Value at this keyframe. e array of Bezier End value Value at the end of the keyframe, note that this is deprecated and you should use s from the next keyframe to get this value Color Animatable Color . Composition Diagram for Color Property Color Property Property Attribute Type Title Description ix integer Property Index Property Index x string Expression Expression sid string Slot ID One of the ID in the file's slots a 0-1 integer Animated Whether the property is animated k Color or array Value Static Value or Array of keyframes Color Keyframe Composition Diagram for Color Keyframe Color Keyframe Base Keyframe Attribute Type Title Description t number Time Frame number h 0-1 integer Hold Hold i Keyframe Easing In Tangent Easing tangent going into the next keyframe o Keyframe Easing Out Tangent Easing tangent leaving the current keyframe s Color Value Value at this keyframe. e Color End value Value at the end of the keyframe, note that this is deprecated and you should use s from the next keyframe to get this value Gradient Animatable Gradient . Attribute Type Title Description p number Color stop count Color stop count k Gradient stops Gradient stops Gradient stops k.a 0-1 integer Animated Whether the property is animated k.k Gradient or array Value or Keyframes When it's not animated, k will contain the value directly. When animated, k will be an array of keyframes. Color count is not animatable. Gradient Keyframe Composition Diagram for Gradient Keyframe Gradient Keyframe Base Keyframe Attribute Type Title Description t number Time Frame number h 0-1 integer Hold Hold i Keyframe Easing In Tangent Easing tangent going into the next keyframe o Keyframe Easing Out Tangent Easing tangent leaving the current keyframe s Gradient Value Value at this keyframe. e Gradient End value Value at the end of the keyframe, note that this is deprecated and you should use s from the next keyframe to get this value","title":"Propeties"},{"location":"properties/#propeties","text":"","title":"Propeties"},{"location":"properties/#property","text":"Properties in Lottie can be animated. Their structure depends on whether it's animated or not: Composition Diagram for Property Property Gradient stops Position Property Vector Property Scalar Property Bezier Property Color Property Attribute Type Title Description ix integer Property Index Property Index x string Expression Expression sid string Slot ID One of the ID in the file's slots a 0-1 integer Animated Whether the property is animated k any or array of Keyframes Value or Keyframes When it's not animated, k will contain the value directly. When animated, k will be an array of keyframes. If a is 0 , then k just has the value of the property. If a is 1 , k will be an array of keyframes.","title":"Animated Property"},{"location":"properties/#base-keyframe","text":"Composition Diagram for Base Keyframe Base Keyframe Vector Keyframe Position Keyframe Color Keyframe Shape Keyframe Gradient Keyframe Attribute Type Title Description t number Time Frame number h 0-1 integer Hold Hold i Keyframe Easing In Tangent Easing tangent going into the next keyframe o Keyframe Easing Out Tangent Easing tangent leaving the current keyframe If h is present and it's 1, you don't need i and o , as the property will keep the same value until the next keyframe.","title":"Keyframes"},{"location":"properties/#easing-handle","text":"Attribute Type Title Description x Vector or number X Time component: 0 means start time of the keyframe, 1 means time of the next keyframe. y Vector or number Y Value interpolation component: 0 means start value of the keyframe, 1 means value at the next keyframe. They are objects with x and y attributes, which are numbers within 0 and 1. For multi-dimensional animated properties, these are arrays, with one element per dimension so you can have different easing curves per dimension. They represent a cubic bezier, starting at [0,0] and ending at [1,1] where the value determines the easing function. The x axis represents time, a value of 0 is the time of the current keyframe, a value of 1 is the time of the next keyframe. The y axis represents the value interpolation factor, a value of 0 represents the value at the current keyframe, a value of 1 represents the value at the next keyframe. When you use easing you have two easing handles for the keyframe: o is the \"out\" handle, and is the first one in the bezier, determines the curve as it exits the current keyframe. i is the \"in\" handle, and it's the second one in the bezier, determines the curve as it enters the next keyframe. For linear interpolation you'd have { \"o\": {\"x\": [0, 0], \"y\": [0, 0]}, \"i\": {\"x\": [1, 1], \"y\": [1, 1]} } For easing in and out, you move the x towards the center, this makes the animation more fluid: { \"o\": {\"x\": [0.333, 0.333], \"y\": [0, 0]}, \"i\": {\"x\": [0.667, 0.667], \"y\": [1, 1]} }","title":"Keyframe Easing"},{"location":"properties/#old-lottie-keyframes","text":"Old lotties have an additional attribute for keyframes, e which works similarly to s but represents the value at the end of the keyframe. They also have a final keyframe with only the t attribute and you need to determine its value based on the s value of the previous keyframe.","title":"Old Lottie Keyframes"},{"location":"properties/#easing-example","text":"In the following example, the ball moves left and right, on the background you can see a representation of its easing function. KeyframePreviewEditor.stand_alone(document.getElementById(\"editor_37\"), (lottie) => { var raw_json = JSON.stringify(lottie, undefined, 4); var pretty_json = hljs.highlight(\"json\", raw_json).value; document.getElementById(\"json_viewer_37\").innerHTML = pretty_json; }, );","title":"Easing example"},{"location":"properties/#property-types","text":"","title":"Property types"},{"location":"properties/#vector-property","text":"Animatable Vector . Composition Diagram for Vector Property Vector Property Property Attribute Type Title Description ix integer Property Index Property Index x string Expression Expression sid string Slot ID One of the ID in the file's slots a 0-1 integer Animated Whether the property is animated l integer Length Number of components in the value arrays. If present values will be truncated or expanded to match this length when accessed from expressions. k Vector or array Value Static Value or Array of keyframes","title":"Vector"},{"location":"properties/#vector-keyframe","text":"Composition Diagram for Vector Keyframe Vector Keyframe Base Keyframe Position Keyframe Attribute Type Title Description t number Time Frame number h 0-1 integer Hold Hold i Keyframe Easing In Tangent Easing tangent going into the next keyframe o Keyframe Easing Out Tangent Easing tangent leaving the current keyframe s Vector Value Value at this keyframe. e Vector End value Value at the end of the keyframe, note that this is deprecated and you should use s from the next keyframe to get this value","title":"Vector Keyframe"},{"location":"properties/#scalar-property","text":"Animatable scalar (single number value). Note that when animated it uses Vector Keyframes , so instead of scalars keyframes have arrays with a single values. Composition Diagram for Scalar Property Scalar Property Property Attribute Type Title Description ix integer Property Index Property Index x string Expression Expression sid string Slot ID One of the ID in the file's slots a 0-1 integer Animated Whether the property is animated k number or array Value Static Value or Array of keyframes","title":"Scalar"},{"location":"properties/#position-property","text":"Animatable 2D Vector with optional spatial tangents. Composition Diagram for Position Property Position Property Property Attribute Type Title Description ix integer Property Index Property Index x string Expression Expression sid string Slot ID One of the ID in the file's slots a 0-1 integer Animated Whether the property is animated l integer Length Number of components in the value arrays. If present values will be truncated or expanded to match this length when accessed from expressions. k Vector or array Value Static Value or Array of keyframes","title":"Position"},{"location":"properties/#position-keyframe","text":"Composition Diagram for Position Keyframe Position Keyframe Vector Keyframe Base Keyframe Attribute Type Title Description t number Time Frame number h 0-1 integer Hold Hold i Keyframe Easing In Tangent Easing tangent going into the next keyframe o Keyframe Easing Out Tangent Easing tangent leaving the current keyframe s Vector Value Value at this keyframe. e Vector End value Value at the end of the keyframe, note that this is deprecated and you should use s from the next keyframe to get this value ti Vector Value In Tangent Tangent for values (eg: moving position around a curved path) to Vector Value Out Tangent Tangent for values (eg: moving position around a curved path)","title":"Position Keyframe"},{"location":"properties/#splittable-position-property","text":"An animatable position where position values may be defined and animated separately. Attribute Type Title Description s boolean = True Split Whether the position has split values x Scalar X Position X Position y Scalar Y Position Y Position","title":"Split Position"},{"location":"properties/#bezier-property","text":"Animatable Bezier . Composition Diagram for Bezier Property Bezier Property Property Attribute Type Title Description ix integer Property Index Property Index x string Expression Expression sid string Slot ID One of the ID in the file's slots a 0-1 integer Animated Whether the property is animated k Bezier or array Value Static Value or Array of keyframes","title":"Bezier Shape"},{"location":"properties/#bezier-keyframe","text":"Composition Diagram for Shape Keyframe Shape Keyframe Base Keyframe Attribute Type Title Description t number Time Frame number h 0-1 integer Hold Hold i Keyframe Easing In Tangent Easing tangent going into the next keyframe o Keyframe Easing Out Tangent Easing tangent leaving the current keyframe s array of Bezier Value Value at this keyframe. e array of Bezier End value Value at the end of the keyframe, note that this is deprecated and you should use s from the next keyframe to get this value","title":"Bezier Shape Keyframe"},{"location":"properties/#color-property","text":"Animatable Color . Composition Diagram for Color Property Color Property Property Attribute Type Title Description ix integer Property Index Property Index x string Expression Expression sid string Slot ID One of the ID in the file's slots a 0-1 integer Animated Whether the property is animated k Color or array Value Static Value or Array of keyframes","title":"Color"},{"location":"properties/#color-keyframe","text":"Composition Diagram for Color Keyframe Color Keyframe Base Keyframe Attribute Type Title Description t number Time Frame number h 0-1 integer Hold Hold i Keyframe Easing In Tangent Easing tangent going into the next keyframe o Keyframe Easing Out Tangent Easing tangent leaving the current keyframe s Color Value Value at this keyframe. e Color End value Value at the end of the keyframe, note that this is deprecated and you should use s from the next keyframe to get this value","title":"Color Keyframe"},{"location":"properties/#gradient-property","text":"Animatable Gradient . Attribute Type Title Description p number Color stop count Color stop count k Gradient stops Gradient stops Gradient stops k.a 0-1 integer Animated Whether the property is animated k.k Gradient or array Value or Keyframes When it's not animated, k will contain the value directly. When animated, k will be an array of keyframes. Color count is not animatable.","title":"Gradient"},{"location":"properties/#gradient-keyframe","text":"Composition Diagram for Gradient Keyframe Gradient Keyframe Base Keyframe Attribute Type Title Description t number Time Frame number h 0-1 integer Hold Hold i Keyframe Easing In Tangent Easing tangent going into the next keyframe o Keyframe Easing Out Tangent Easing tangent leaving the current keyframe s Gradient Value Value at this keyframe. e Gradient End value Value at the end of the keyframe, note that this is deprecated and you should use s from the next keyframe to get this value","title":"Gradient Keyframe"},{"location":"rendering/","text":"Tips for rendering .json-parent:not([hidden]) { display: flex; } .json-parent > pre { width: 50%; } .json-parent > pre > code { height: 100%; } let converter_map = {}; function convert_shape(shape) { let lottie_bez = { \"c\": true, \"v\": [ [ 256, 96 ], [ 408.1690426072246, 206.5572809000084 ], [ 350.04564036679574, 385.44271909999156 ], [ 161.95435963320432, 385.44271909999156 ], [ 103.83095739277542, 206.55728090000844 ] ], \"i\": [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ], \"o\": [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ] }; if ( shape.sy == 1 ) lottie_bez = { \"c\": true, \"v\": [ [ 250.84172204836955, 33.33731381001252 ], [ 319.3523543268615, 164.41507157596521 ], [ 466.1708030880071, 182.28763209535816 ], [ 362.679397092767, 287.9503700935611 ], [ 391.05097770288023, 433.10593743368196 ], [ 258.5791389758152, 367.3313430949937 ], [ 129.2952913462771, 439.16985684806957 ], [ 150.91459845599647, 292.8561839523209 ], [ 42.641205814466105, 192.09925981287776 ], [ 188.47451114855988, 167.44703128315905 ] ], \"i\": [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ], \"o\": [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ] }; return Bezier.from_lottie(lottie_bez); // return converter_map[shape.ty](shape); } Introduction This page will give tips and example code on how to render certain objects within lottie. Lottie has several implementations and some things might vary from player to player, this guide tries to follow the behaviour of lottie web which is the reference implementation. For shapes, it ensures the stroke order is the same as in lottie web, which is crucial for Trim Path to work correctly. All shapes have the d attribute that if has the value 3 the path should be reversed. Code The code examples take some shortcuts for readablility: all animated properties are shown as static, of course you'd need to get the correct values to render shapes at a given frame. When adding points to a bezier, there are calls to bezier.add_vertex() . Assume the in/out tangents are [0, 0] if not specified. When they are specified they show as set_out_tangent immediately following the corresponding add_vertex . Bezier tangents are assumed to be relative to their vertex since that's how lottie works but it might be useful to keep them as absolute points when rendering. All the examples show the original on the left and the bezier on the right. Explanation for bezier operations is outside the scope of this guide, the code below use a simple bezier library for some operations, you can check its sources for some context on what the various functions do. Rectangle See Rectangle . Note that unlike other shapes, on lottie web when the d attribute is missing, the rectangle defaults as being reversed. Python C++ TypeScript def rectangle(shape: Bezier, p: Vector2D, s: Vector2D, r: float): left: float = p.x - s.x / 2 right: float = p.x + s.x / 2 top: float = p.y - s.y / 2 bottom: float = p.y + s.y / 2 shape.closed = True if r <= 0: # The rectangle is rendered from the top-right going clockwise shape.add_vertex(Vector2D(right, top)) shape.add_vertex(Vector2D(right, bottom)) shape.add_vertex(Vector2D(left, bottom)) shape.add_vertex(Vector2D(left, top)) else: # Rounded corners must be taken into account rounded: float = min(s.x/2, s.y/2, r) tangent: float = rounded * ELLIPSE_CONSTANT shape.add_vertex(Vector2D(right, top + rounded)) shape.set_in_tangent(Vector2D(0, -tangent)) shape.add_vertex(Vector2D(right, bottom - rounded)) shape.set_out_tangent(Vector2D(0, tangent)) shape.add_vertex(Vector2D(right - rounded, bottom)) shape.set_in_tangent(Vector2D(tangent, 0)) shape.add_vertex(Vector2D(left + rounded, bottom)) shape.set_out_tangent(Vector2D(-tangent, 0)) shape.add_vertex(Vector2D(left, bottom - rounded)) shape.set_in_tangent(Vector2D(0, tangent)) shape.add_vertex(Vector2D(left, top + rounded)) shape.set_out_tangent(Vector2D(0, -tangent)) shape.add_vertex(Vector2D(left + rounded, top)) shape.set_in_tangent(Vector2D(-tangent, 0)) shape.add_vertex(Vector2D(right - rounded, top)) shape.set_out_tangent(Vector2D(tangent, 0)) void rectangle(Bezier shape, Vector2D p, Vector2D s, float r) { float left = p.x - s.x / 2; float right = p.x + s.x / 2; float top = p.y - s.y / 2; float bottom = p.y + s.y / 2; shape.closed = true; if ( r <= 0 ) { // The rectangle is rendered from the top-right going clockwise shape.add_vertex(Vector2D(right, top)); shape.add_vertex(Vector2D(right, bottom)); shape.add_vertex(Vector2D(left, bottom)); shape.add_vertex(Vector2D(left, top)); } // Rounded corners must be taken into account else { float rounded = std::min(s.x / 2, s.y / 2, r); float tangent = rounded * ELLIPSE_CONSTANT; shape.add_vertex(Vector2D(right, top + rounded)); shape.set_in_tangent(Vector2D(0, -tangent)); shape.add_vertex(Vector2D(right, bottom - rounded)); shape.set_out_tangent(Vector2D(0, tangent)); shape.add_vertex(Vector2D(right - rounded, bottom)); shape.set_in_tangent(Vector2D(tangent, 0)); shape.add_vertex(Vector2D(left + rounded, bottom)); shape.set_out_tangent(Vector2D(-tangent, 0)); shape.add_vertex(Vector2D(left, bottom - rounded)); shape.set_in_tangent(Vector2D(0, tangent)); shape.add_vertex(Vector2D(left, top + rounded)); shape.set_out_tangent(Vector2D(0, -tangent)); shape.add_vertex(Vector2D(left + rounded, top)); shape.set_in_tangent(Vector2D(-tangent, 0)); shape.add_vertex(Vector2D(right - rounded, top)); shape.set_out_tangent(Vector2D(tangent, 0)); } } function rectangle(shape: Bezier, p: Vector2D, s: Vector2D, r: number) { let left: number = p.x - s.x / 2; let right: number = p.x + s.x / 2; let top: number = p.y - s.y / 2; let bottom: number = p.y + s.y / 2; shape.closed = true; if ( r <= 0 ) { // The rectangle is rendered from the top-right going clockwise shape.addVertex(new Vector2D(right, top)); shape.addVertex(new Vector2D(right, bottom)); shape.addVertex(new Vector2D(left, bottom)); shape.addVertex(new Vector2D(left, top)); } else { // Rounded corners must be taken into account let rounded: number = Math.min(s.x / 2, s.y / 2, r); let tangent: number = rounded * ELLIPSE_CONSTANT; shape.addVertex(new Vector2D(right, top + rounded)); shape.setInTangent(new Vector2D(0, -tangent)); shape.addVertex(new Vector2D(right, bottom - rounded)); shape.setOutTangent(new Vector2D(0, tangent)); shape.addVertex(new Vector2D(right - rounded, bottom)); shape.setInTangent(new Vector2D(tangent, 0)); shape.addVertex(new Vector2D(left + rounded, bottom)); shape.setOutTangent(new Vector2D(-tangent, 0)); shape.addVertex(new Vector2D(left, bottom - rounded)); shape.setInTangent(new Vector2D(0, tangent)); shape.addVertex(new Vector2D(left, top + rounded)); shape.setOutTangent(new Vector2D(0, -tangent)); shape.addVertex(new Vector2D(left + rounded, top)); shape.setInTangent(new Vector2D(-tangent, 0)); shape.addVertex(new Vector2D(right - rounded, top)); shape.setOutTangent(new Vector2D(tangent, 0)); } } Ellipse See Ellipse . The stroke direction should start at the top. If you think of the ellipse as a clock, start at 12 go clockwise. The magic number 0.5519 is what lottie uses for this, based on this article . Python C++ TypeScript def ellipse(shape: Bezier, p: Vector2D, s: Vector2D): # An ellipse is drawn from the top quandrant point going clockwise: radius = s / 2 tangent = radius * ELLIPSE_CONSTANT x = p.x y = p.y shape.closed = True shape.add_vertex(Vector2D(x, y - radius.y)) shape.set_in_tangent(Vector2D(-tangent.x, 0)) shape.set_out_tangent(Vector2D(tangent.x, 0)) shape.add_vertex(Vector2D(x + radius.x, y)) shape.set_in_tangent(Vector2D(0, -tangent.y)) shape.set_out_tangent(Vector2D(0, tangent.y)) shape.add_vertex(Vector2D(x, y + radius.y)) shape.set_in_tangent(Vector2D(tangent.x, 0)) shape.set_out_tangent(Vector2D(-tangent.x, 0)) shape.add_vertex(Vector2D(x - radius.x, y)) shape.set_in_tangent(Vector2D(0, tangent.y)) shape.set_out_tangent(Vector2D(0, -tangent.y)) void ellipse(Bezier shape, Vector2D p, Vector2D s) { // An ellipse is drawn from the top quandrant point going clockwise: radius = s / 2; tangent = radius * ELLIPSE_CONSTANT; x = p.x; y = p.y; shape.closed = true; shape.add_vertex(Vector2D(x, y - radius.y)); shape.set_in_tangent(Vector2D(-tangent.x, 0)); shape.set_out_tangent(Vector2D(tangent.x, 0)); shape.add_vertex(Vector2D(x + radius.x, y)); shape.set_in_tangent(Vector2D(0, -tangent.y)); shape.set_out_tangent(Vector2D(0, tangent.y)); shape.add_vertex(Vector2D(x, y + radius.y)); shape.set_in_tangent(Vector2D(tangent.x, 0)); shape.set_out_tangent(Vector2D(-tangent.x, 0)); shape.add_vertex(Vector2D(x - radius.x, y)); shape.set_in_tangent(Vector2D(0, tangent.y)); shape.set_out_tangent(Vector2D(0, -tangent.y)); } function ellipse(shape: Bezier, p: Vector2D, s: Vector2D) { // An ellipse is drawn from the top quandrant point going clockwise: radius = s / 2; tangent = radius * ELLIPSE_CONSTANT; x = p.x; y = p.y; shape.closed = true; shape.addVertex(new Vector2D(x, y - radius.y)); shape.setInTangent(new Vector2D(-tangent.x, 0)); shape.setOutTangent(new Vector2D(tangent.x, 0)); shape.addVertex(new Vector2D(x + radius.x, y)); shape.setInTangent(new Vector2D(0, -tangent.y)); shape.setOutTangent(new Vector2D(0, tangent.y)); shape.addVertex(new Vector2D(x, y + radius.y)); shape.setInTangent(new Vector2D(tangent.x, 0)); shape.setOutTangent(new Vector2D(-tangent.x, 0)); shape.addVertex(new Vector2D(x - radius.x, y)); shape.setInTangent(new Vector2D(0, tangent.y)); shape.setOutTangent(new Vector2D(0, -tangent.y)); } PolyStar Pseudocode for rendering a PolyStar . Python C++ TypeScript def polystar(shape: Bezier, p: Vector2D, pt: float, r: float, or_: float, os: float, sy: int, ir: float, is_: float): points: int = int(round(pt)) alpha: float = -r * math.pi / 180 - math.pi / 2 theta: float = -math.pi / points tan_len_out: float = (2 * math.pi * or_) / (4 * points) * (os / 100) tan_len_in: float = (2 * math.pi * ir) / (4 * points) * (is_ / 100) shape.closed = True for i in range(points): beta: float = alpha + i * theta * 2 v_out: Vector2D = Vector2D(or_ * math.cos(beta), or_ * math.sin(beta)) shape.add_vertex(p + v_out) if os != 0 and or_ != 0: # We need to add bezier tangents tan_out: Vector2D = v_out * tan_len_out / or_ shape.set_in_tangent(Vector2D(-tan_out.y, tan_out.x)) shape.set_out_tangent(Vector2D(tan_out.y, -tan_out.x)) if sy == 1: # We need to add a vertex towards the inner radius to make a star v_in: Vector2D = Vector2D(ir * math.cos(beta + theta), ir * math.sin(beta + theta)) shape.add_vertex(p + v_in) if is_ != 0 and ir != 0: # We need to add bezier tangents tan_in = v_in * tan_len_in / ir shape.set_in_tangent(Vector2D(-tan_in.y, tan_in.x)) shape.set_out_tangent(Vector2D(tan_in.y, -tan_in.x)) void polystar(Bezier shape, Vector2D p, float pt, float r, float or_, float os, int sy, float ir, float is) { int points = std::round(pt); float alpha = -r * std::numbers::pi / 180 - std::numbers::pi / 2; float theta = -std::numbers::pi / points; float tan_len_out = 2 * std::numbers::pi * or_ / 4 * points * os / 100; float tan_len_in = 2 * std::numbers::pi * ir / 4 * points * is / 100; shape.closed = true; for ( int i = 0; i < points; i++ ) { float beta = alpha + i * theta * 2; Vector2D v_out(or_ * std::cos(beta), or_ * std::sin(beta)); shape.add_vertex(p + v_out); if ( os != 0 && or_ != 0 ) { // We need to add bezier tangents Vector2D tan_out = v_out * tan_len_out / or_; shape.set_in_tangent(Vector2D(-tan_out.y, tan_out.x)); shape.set_out_tangent(Vector2D(tan_out.y, -tan_out.x)); } if ( sy == 1 ) { // We need to add a vertex towards the inner radius to make a star Vector2D v_in(ir * std::cos(beta + theta), ir * std::sin(beta + theta)); shape.add_vertex(p + v_in); if ( is != 0 && ir != 0 ) { // We need to add bezier tangents tan_in = v_in * tan_len_in / ir; shape.set_in_tangent(Vector2D(-tan_in.y, tan_in.x)); shape.set_out_tangent(Vector2D(tan_in.y, -tan_in.x)); } } } } function polystar(shape: Bezier, p: Vector2D, pt: number, r: number, or: number, os: number, sy: number, ir: number, is: number) { let points: number = new Number(round(pt)); let alpha: number = -r * Math.PI / 180 - Math.PI / 2; let theta: number = -Math.PI / points; let tanLenOut: number = 2 * Math.PI * or / 4 * points * os / 100; let tanLenIn: number = 2 * Math.PI * ir / 4 * points * is / 100; shape.closed = true; for ( let i: number = 0; i < points; i++ ) { let beta: number = alpha + i * theta * 2; let vOut: Vector2D = new Vector2D(or * Math.cos(beta), or * Math.sin(beta)); shape.addVertex(p + vOut); if ( os != 0 && or != 0 ) { // We need to add bezier tangents let tanOut: Vector2D = vOut * tanLenOut / or; shape.setInTangent(new Vector2D(-tanOut.y, tanOut.x)); shape.setOutTangent(new Vector2D(tanOut.y, -tanOut.x)); } if ( sy == 1 ) { // We need to add a vertex towards the inner radius to make a star let vIn: Vector2D = new Vector2D(ir * Math.cos(beta + theta), ir * Math.sin(beta + theta)); shape.addVertex(p + vIn); if ( is != 0 && ir != 0 ) { // We need to add bezier tangents tanIn = vIn * tanLenIn / ir; shape.setInTangent(new Vector2D(-tanIn.y, tanIn.x)); shape.setOutTangent(new Vector2D(tanIn.y, -tanIn.x)); } } } } Pucker Bloat See Pucker / Bloat . Amount 50 function pucker_bloat( // Beziers as collected from the other shapes collected_shapes, // \"a\" property from the Pucker/Bloat modifier amount ) { // Normalize to [0, 1] amount /= 100; // Find the mean of the bezier vertices let center = new Point(0, 0); let number_of_vertices = 0; for ( let input_bezier of collected_shapes ) { for ( let point of input_bezier.points ) { center.x += point.pos.x; center.y += point.pos.y; number_of_vertices += 1; } } center.x /= number_of_vertices; center.y /= number_of_vertices; let result = []; for ( let input_bezier of collected_shapes ) { let output_bezier = new Bezier(); for ( let point of input_bezier.points ) { // Here we convert tangents to global coordinates let vertex = lerp(point.pos, center, amount); let in_tangent = lerp(point.in_tangent.add(point.pos), center, -amount).sub(vertex); let out_tangent = lerp(point.out_tangent.add(point.pos), center, -amount).sub(vertex); output_bezier.add_vertex(vertex) .set_in_tangent(in_tangent) .set_out_tangent(out_tangent); } output_bezier.closed = input_bezier.closed; result.push(output_bezier); } return result; } var lottie_player_46_bezier = new LottiePlayer('lottie_target_46_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_46 = new PlaygroundPlayer( 46, 'playground_46_2', 'lottie_target_46', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 160}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 2, \"os\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"pb\", \"nm\": \"Inflate and Deflate\", \"mn\": \"{b4af429a-546e-4728-a869-711a404c55ae}\", \"a\": {\"a\": 0, \"k\": 50}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"hd\": true, \"nm\": \"Fill\", \"mn\": \"{a1bcc159-6916-4718-841d-a99140c0e74b}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let bezier_lottie = lottie_player_46_bezier.lottie; lottie.layers[0].shapes[0].it[1].a.k = data[\"Amount\"]; let star = lottie.layers[0].shapes[0].it[0]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; let modifier = lottie.layers[0].shapes[0].it[1]; let bez_result = pucker_bloat([convert_shape(star)], modifier.a.k); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_46_bezier.reload(); this.set_json('playground_46_2_bezier', out_shapes[0].ks.k); }, {} ); function pucker_bloat( // Beziers as collected from the other shapes collected_shapes, // \"a\" property from the Pucker/Bloat modifier amount ) { // Normalize to [0, 1] amount /= 100; // Find the mean of the bezier vertices let center = new Point(0, 0); let number_of_vertices = 0; for ( let input_bezier of collected_shapes ) { for ( let point of input_bezier.points ) { center.x += point.pos.x; center.y += point.pos.y; number_of_vertices += 1; } } center.x /= number_of_vertices; center.y /= number_of_vertices; let result = []; for ( let input_bezier of collected_shapes ) { let output_bezier = new Bezier(); for ( let point of input_bezier.points ) { // Here we convert tangents to global coordinates let vertex = lerp(point.pos, center, amount); let in_tangent = lerp(point.in_tangent.add(point.pos), center, -amount).sub(vertex); let out_tangent = lerp(point.out_tangent.add(point.pos), center, -amount).sub(vertex); output_bezier.add_vertex(vertex) .set_in_tangent(in_tangent) .set_out_tangent(out_tangent); } output_bezier.closed = input_bezier.closed; result.push(output_bezier); } return result; } // Example invocation pucker_bloat([convert_shape(star)], modifier.a.k); Rounded Corners See Rounded Corners . It approximates rounding using circular arcs. The magic number 0.5519 is what lottie uses for this, based on this article . Radius 50 // Helper function to perform rounding on a single vertex function get_vertex_tangent( // Bezier to round bezier, // Vertex in the bezier we are rounding current_vertex, // Index of the next point along the curve closest_index, // Rounding radius round_distance ) { const tangent_length = 0.5519; // closest_index module bezier.length closest_index = closest_index % bezier.points.length; if ( closest_index < 0 ) closest_index += bezier.points.length; let closest_vertex = bezier.points[closest_index].pos; let distance = current_vertex.distance(closest_vertex); let new_pos_perc = distance != 0 ? Math.min(distance/2, round_distance) / distance : 0; let vertex = closest_vertex.sub(current_vertex).mul(new_pos_perc).add(current_vertex); let tangent = vertex.sub(current_vertex).neg().mul(tangent_length); return [vertex, tangent]; } // Rounding for a single continuos curve function round_bezier_corners( // Bezier to round original, // Rounding radius round_distance ) { let result = new Bezier() result.closed = original.closed; for ( let i = 0; i < original.points.length; i++ ) { let point = original.points[i]; // Start and end of a non-closed path don't get rounded if ( !original.closed && (i == 0 || i == original.points.length - 1) ) { result.add_vertex(point.pos) .set_in_tangent(point.in_tangent) .set_out_tangent(point.out_tangent); } else { let [vert1, out_t] = get_vertex_tangent(original, point.pos, i - 1, round_distance); result.add_vertex(vert1) .set_out_tangent(out_t); let [vert2, in_t] = get_vertex_tangent(original, point.pos, i + 1, round_distance); result.add_vertex(vert2) .set_in_tangent(in_t); } } return result; } // Rounding on multiple bezier function round_corners( // Beziers as collected from the other shapes collected_shapes, // \"r\" property from lottie r ) { let result = [] for ( let input_bezier of collected_shapes ) result.push(round_bezier_corners(input_bezier, r)); return result; } var lottie_player_47_bezier = new LottiePlayer('lottie_target_47_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_47 = new PlaygroundPlayer( 47, 'playground_47_2', 'lottie_target_47', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 222.72242736816406}, \"ir\": {\"a\": 0, \"k\": 111.36121368408203}, \"r\": {\"a\": 0, \"k\": 358.67291259765625}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"rd\", \"nm\": \"Rounded Corners\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"r\": {\"a\": 0, \"k\": 50}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"hd\": true, \"nm\": \"Fill\", \"mn\": \"{a1bcc159-6916-4718-841d-a99140c0e74b}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let bezier_lottie = lottie_player_47_bezier.lottie; lottie.layers[0].shapes[0].it[1].r.k = data[\"Radius\"]; let star = lottie.layers[0].shapes[0].it[0]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; let modifier = lottie.layers[0].shapes[0].it[1]; let bez_result = round_corners([convert_shape(star)], modifier.r.k); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_47_bezier.reload(); this.set_json('playground_47_2_bezier', out_shapes[0].ks.k); }, {} ); // Helper function to perform rounding on a single vertex function get_vertex_tangent( // Bezier to round bezier, // Vertex in the bezier we are rounding current_vertex, // Index of the next point along the curve closest_index, // Rounding radius round_distance ) { const tangent_length = 0.5519; // closest_index module bezier.length closest_index = closest_index % bezier.points.length; if ( closest_index < 0 ) closest_index += bezier.points.length; let closest_vertex = bezier.points[closest_index].pos; let distance = current_vertex.distance(closest_vertex); let new_pos_perc = distance != 0 ? Math.min(distance/2, round_distance) / distance : 0; let vertex = closest_vertex.sub(current_vertex).mul(new_pos_perc).add(current_vertex); let tangent = vertex.sub(current_vertex).neg().mul(tangent_length); return [vertex, tangent]; } // Rounding for a single continuos curve function round_bezier_corners( // Bezier to round original, // Rounding radius round_distance ) { let result = new Bezier() result.closed = original.closed; for ( let i = 0; i < original.points.length; i++ ) { let point = original.points[i]; // Start and end of a non-closed path don't get rounded if ( !original.closed && (i == 0 || i == original.points.length - 1) ) { result.add_vertex(point.pos) .set_in_tangent(point.in_tangent) .set_out_tangent(point.out_tangent); } else { let [vert1, out_t] = get_vertex_tangent(original, point.pos, i - 1, round_distance); result.add_vertex(vert1) .set_out_tangent(out_t); let [vert2, in_t] = get_vertex_tangent(original, point.pos, i + 1, round_distance); result.add_vertex(vert2) .set_in_tangent(in_t); } } return result; } // Rounding on multiple bezier function round_corners( // Beziers as collected from the other shapes collected_shapes, // \"r\" property from lottie r ) { let result = [] for ( let input_bezier of collected_shapes ) result.push(round_bezier_corners(input_bezier, r)); return result; } // Example invocation round_corners([convert_shape(star)], modifier.r.k); Zig Zag See Zig Zag . Amplitude 10 Frequency 10 Point Type Point Smooth Star Roundness 0 Rotation 0 Points 5 Stroke Width 3 function angle_mean(a, b) { if ( Math.abs(a-b) > Math.PI ) return (a + b) / 2 + Math.PI; return (a + b) / 2; } function zig_zag_corner(output_bezier, segment_before, segment_after, amplitude, direction, tangent_length) { let point; let angle; let tan_angle; // We use 0.01 and 0.99 instead of 0 and 1 because they yield better results if ( !segment_before ) { point = segment_after.points[0]; angle = segment_after.normal_angle(0.01); tan_angle = segment_after.tangent_angle(0.01); } else if ( !segment_after ) { point = segment_before.points[3]; angle = segment_before.normal_angle(0.99); tan_angle = segment_before.tangent_angle(0.99); } else { point = segment_after.points[0]; angle = angle_mean(segment_after.normal_angle(0.01), segment_before.normal_angle(0.99)); tan_angle = angle_mean(segment_after.tangent_angle(0.01), segment_before.tangent_angle(0.99)); } let vertex = output_bezier.add_vertex(point.add_polar(angle, direction * amplitude)); if ( tangent_length !== 0 ) { vertex.set_in_tangent(Point.polar(tan_angle, -tangent_length)); vertex.set_out_tangent(Point.polar(tan_angle, tangent_length)); } } function zig_zag_segment(output_bezier, segment, amplitude, frequency, direction, tangent_length) { for ( let i = 0; i < frequency; i++ ) { let f = (i + 1) / (frequency + 1); let t = segment.t_at_length_percent(f); let angle = segment.normal_angle(t); let point = segment.point(t); let vertex = output_bezier.add_vertex(point.add_polar(angle, direction * amplitude)); if ( tangent_length !== 0 ) { let tan_angle = segment.tangent_angle(t); vertex.set_in_tangent(Point.polar(tan_angle, -tangent_length)); vertex.set_out_tangent(Point.polar(tan_angle, tangent_length)); } direction = -direction; } return direction; } function zig_zag_bezier(input_bezier, amplitude, frequency, smooth) { let output_bezier = new Bezier(); output_bezier.closed = input_bezier.closed; let count = input_bezier.segment_count(); if ( count == 0 ) return output_bezier; let direction = -1; let segment = input_bezier.closed ? input_bezier.segment(count - 1) : null; let next_segment = input_bezier.segment(0); next_segment.calculate_length_data(); let tangent_length = smooth ? next_segment.length / (frequency + 1) / 2 : 0; zig_zag_corner(output_bezier, segment, next_segment, amplitude, -1, tangent_length); for ( let i = 0; i < count; i++ ) { segment = next_segment; direction = zig_zag_segment(output_bezier, segment, amplitude, frequency, -direction, tangent_length); if ( i == count - 1 && !input_bezier.closed ) next_segment = null; else next_segment = input_bezier.segment((i + 1) % count); zig_zag_corner(output_bezier, segment, next_segment, amplitude, direction, tangent_length); } return output_bezier; } function zig_zag( // Beziers as collected from the other shapes collected_shapes, amplitude, frequency, point_type ) { // Ensure we have an integer number of segments frequency = Math.max(0, Math.round(frequency)); let result = []; for ( let input_bezier of collected_shapes ) result.push(zig_zag_bezier(input_bezier, amplitude, frequency, point_type === 2)); return result; } var lottie_player_48_bezier = new LottiePlayer('lottie_target_48_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_48 = new PlaygroundPlayer( 48, 'playground_48_8', 'lottie_target_48', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 222.72242736816406}, \"ir\": {\"a\": 0, \"k\": 111.36121368408203}, \"r\": {\"a\": 0, \"k\": 358.67291259765625}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"zz\", \"nm\": \"Zig Zag\", \"mn\": \"{b4af429a-546e-4728-a869-711a404c55ae}\", \"r\": {\"a\": 0, \"k\": 0}, \"s\": {\"a\": 0, \"k\": 10}, \"pt\": {\"a\": 0, \"k\": 2}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 3}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let bezier_lottie = lottie_player_48_bezier.lottie; lottie.layers[0].shapes[0].it[1].s.k = data[\"Amplitude\"]; lottie.layers[0].shapes[0].it[1].r.k = data[\"Frequency\"]; lottie.layers[0].shapes[0].it[1].pt.k = Number(data[\"Point Type\"]); lottie.layers[0].shapes[0].it[0].pt.k = data[\"Points\"]; lottie.layers[0].shapes[0].it[0].r.k = data[\"Rotation\"]; lottie.layers[0].shapes[0].it[0].is.k = data[\"Roundness\"]; lottie.layers[0].shapes[0].it[0].os.k = data[\"Roundness\"]; lottie.layers[0].shapes[0].it[2].w.k = data[\"Stroke Width\"]; let star = lottie.layers[0].shapes[0].it[0]; bezier_lottie.layers[0].shapes[0].it[1].w.k = data[\"Stroke Width\"]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; let modifier = lottie.layers[0].shapes[0].it[1]; let bez_result = zig_zag([convert_shape(star)], modifier.s.k, modifier.r.k, modifier.pt.k); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_48_bezier.reload(); this.set_json('playground_48_8_bezier', out_shapes[0].ks.k); }, {} ); function angle_mean(a, b) { if ( Math.abs(a-b) > Math.PI ) return (a + b) / 2 + Math.PI; return (a + b) / 2; } function zig_zag_corner(output_bezier, segment_before, segment_after, amplitude, direction, tangent_length) { let point; let angle; let tan_angle; // We use 0.01 and 0.99 instead of 0 and 1 because they yield better results if ( !segment_before ) { point = segment_after.points[0]; angle = segment_after.normal_angle(0.01); tan_angle = segment_after.tangent_angle(0.01); } else if ( !segment_after ) { point = segment_before.points[3]; angle = segment_before.normal_angle(0.99); tan_angle = segment_before.tangent_angle(0.99); } else { point = segment_after.points[0]; angle = angle_mean(segment_after.normal_angle(0.01), segment_before.normal_angle(0.99)); tan_angle = angle_mean(segment_after.tangent_angle(0.01), segment_before.tangent_angle(0.99)); } let vertex = output_bezier.add_vertex(point.add_polar(angle, direction * amplitude)); if ( tangent_length !== 0 ) { vertex.set_in_tangent(Point.polar(tan_angle, -tangent_length)); vertex.set_out_tangent(Point.polar(tan_angle, tangent_length)); } } function zig_zag_segment(output_bezier, segment, amplitude, frequency, direction, tangent_length) { for ( let i = 0; i < frequency; i++ ) { let f = (i + 1) / (frequency + 1); let t = segment.t_at_length_percent(f); let angle = segment.normal_angle(t); let point = segment.point(t); let vertex = output_bezier.add_vertex(point.add_polar(angle, direction * amplitude)); if ( tangent_length !== 0 ) { let tan_angle = segment.tangent_angle(t); vertex.set_in_tangent(Point.polar(tan_angle, -tangent_length)); vertex.set_out_tangent(Point.polar(tan_angle, tangent_length)); } direction = -direction; } return direction; } function zig_zag_bezier(input_bezier, amplitude, frequency, smooth) { let output_bezier = new Bezier(); output_bezier.closed = input_bezier.closed; let count = input_bezier.segment_count(); if ( count == 0 ) return output_bezier; let direction = -1; let segment = input_bezier.closed ? input_bezier.segment(count - 1) : null; let next_segment = input_bezier.segment(0); next_segment.calculate_length_data(); let tangent_length = smooth ? next_segment.length / (frequency + 1) / 2 : 0; zig_zag_corner(output_bezier, segment, next_segment, amplitude, -1, tangent_length); for ( let i = 0; i < count; i++ ) { segment = next_segment; direction = zig_zag_segment(output_bezier, segment, amplitude, frequency, -direction, tangent_length); if ( i == count - 1 && !input_bezier.closed ) next_segment = null; else next_segment = input_bezier.segment((i + 1) % count); zig_zag_corner(output_bezier, segment, next_segment, amplitude, direction, tangent_length); } return output_bezier; } function zig_zag( // Beziers as collected from the other shapes collected_shapes, amplitude, frequency, point_type ) { // Ensure we have an integer number of segments frequency = Math.max(0, Math.round(frequency)); let result = []; for ( let input_bezier of collected_shapes ) result.push(zig_zag_bezier(input_bezier, amplitude, frequency, point_type === 2)); return result; } // Example invocation zig_zag([convert_shape(star)], modifier.s.k, modifier.r.k, modifier.pt.k); Offset Path See Offset Path . Amount 10 Miter Limit 100 Line Join Miter Round Bevel Star Roundness 0 /* Simple offset of a linear segment */ function linear_offset(p1, p2, amount) { let angle = Math.atan2(p2.x - p1.x, p2.y - p1.y); return [ p1.add_polar(angle, amount), p2.add_polar(angle, amount) ]; } /* Offset a bezier segment only works well if the segment is flat enough */ function offset_segment(segment, amount) { let [p0, p1a] = linear_offset(segment.points[0], segment.points[1], amount); let [p1b, p2b] = linear_offset(segment.points[1], segment.points[2], amount); let [p2a, p3] = linear_offset(segment.points[2], segment.points[3], amount); let p1 = line_intersection(p0, p1a, p1b, p2b) ?? p1a; let p2 = line_intersection(p2a, p3, p1b, p2b) ?? p2a; return new BezierSegment(p0, p1, p2, p3); } /* Join two segments */ function join_lines(output_bezier, seg1, seg2, line_join, miter_limit) { let p0 = seg1.points[3]; let p1 = seg2.points[0]; // Bevel if ( line_join == 3 ) return p0; // Connected, they don't need a joint if ( p0.is_equal(p1) ) return p0; let last_point = output_bezier.points[output_bezier.points.length - 1]; // Round if ( line_join == 2 ) { const ellipse_constant = 0.5519; let angle_out = seg1.tangent_angle(1); let angle_in = seg2.tangent_angle(0) + Math.PI; let center = line_intersection( p0, p0.add_polar(angle_out + Math.PI / 2, 100), p1, p1.add_polar(angle_out + Math.PI / 2, 100) ); let radius = center ? center.distance(p0) : p0.distance(p1) / 2; last_point.set_out_tangent(Point.polar(angle_out, 2 * radius * ellipse_constant)); output_bezier.add_vertex(p1) .set_in_tangent(Point.polar(angle_in, 2 * radius * ellipse_constant)); return p1; } // Miter let t0 = p0.is_equal(seg1.points[2]) ? seg1.points[0] : seg1.points[2]; let t1 = p1.is_equal(seg2.points[1]) ? seg2.points[3] : seg2.points[1]; let intersection = line_intersection(t0, p0, p1, t1); if ( intersection && intersection.distance(p0) < miter_limit ) { output_bezier.add_vertex(intersection); return intersection; } return p0; } function get_intersection(a, b) { let intersect = a.intersections(b); if ( intersect.length && fuzzy_compare(intersect[0], 1) ) intersect.shift(); if ( intersect.length ) return intersect[0]; return null; } function prune_segment_intersection(a, b) { let out_a = [...a]; let out_b = [...b]; let intersect = get_intersection(a[a.length-1], b[0]); if ( intersect ) { out_a[a.length-1] = a[a.length-1].split(intersect[0])[0]; out_b[0] = b[0].split(intersect[1])[1]; } if ( a.length > 1 && b.length > 1 ) { intersect = get_intersection(a[0], b[b.length - 1]); if ( intersect ) { return [ [a[0].split(intersect[0])[0]], [b[b.length-1].split(intersect[1])[1]], ]; } } return [out_a, out_b]; } function prune_intersections(segments) { for ( let i = 1; i < segments.length; i++ ) { [segments[i-1], segments[i]] = prune_segment_intersection(segments[i - 1], segments[i]); } if ( segments.length > 1 ) [segments[segments.length - 1], segments[0]] = prune_segment_intersection(segments[segments.length - 1], segments[0]); return segments; } function offset_segment_split(segment, amount) { /* We split each bezier segment into smaller pieces based on inflection points, this ensures the control point polygon is convex. (A cubic bezier can have none, one, or two inflection points) */ let flex = segment.inflection_points(); if ( flex.length == 0 ) { return [offset_segment(segment, amount)]; } else if ( flex.length == 1 || flex[1] == 1 ) { let [left, right] = segment.split(flex[0]); return [ offset_segment(left, amount), offset_segment(right, amount) ]; } else { let [left, mid_right] = segment.split(flex[0]); let t = (flex[1] - flex[0]) / (1 - flex[0]); let [mid, right] = mid_right.split(t); return [ offset_segment(left, amount), offset_segment(mid, amount), offset_segment(right, amount) ]; } } function offset_path( // Beziers as collected from the other shapes collected_shapes, amount, line_join, miter_limit, ) { let result = []; for ( let input_bezier of collected_shapes ) { let output_bezier = new Bezier(); output_bezier.closed = input_bezier.closed; let count = input_bezier.segment_count(); let multi_segments = []; for ( let i = 0; i < count; i++ ) multi_segments.push(offset_segment_split(input_bezier.segment(i), amount)); // Open paths are stroked rather than being simply offset if ( !input_bezier.closed ) { for ( let i = count - 1; i >= 0; i-- ) multi_segments.push(offset_segment_split(input_bezier.inverted_segment(i), amount)); } multi_segments = prune_intersections(multi_segments); // Add bezier segments to the output and apply line joints let last_point = null; let last_seg = null; for ( let multi_segment of multi_segments ) { if ( last_seg ) last_point = join_lines(output_bezier, last_seg, multi_segment[0], line_join, miter_limit); last_seg = multi_segment[multi_segment.length - 1]; for ( let segment of multi_segment ) { if ( segment.points[0].is_equal(last_point) ) { output_bezier.points[output_bezier.points.length - 1] .set_out_tangent(segment.points[1].sub(segment.points[0])); } else { output_bezier.add_vertex(segment.points[0]) .set_out_tangent(segment.points[1].sub(segment.points[0])); } output_bezier.add_vertex(segment.points[3]) .set_in_tangent(segment.points[2].sub(segment.points[3])); last_point = segment.points[3]; } } if ( multi_segments.length ) join_lines(output_bezier, last_seg, multi_segments[0][0], line_join, miter_limit); result.push(output_bezier); } return result; } var lottie_player_49_bezier = new LottiePlayer('lottie_target_49_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_49 = new PlaygroundPlayer( 49, 'playground_49_5', 'lottie_target_49', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 222.72242736816406}, \"ir\": {\"a\": 0, \"k\": 111.36121368408203}, \"r\": {\"a\": 0, \"k\": 358.67291259765625}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"op\", \"nm\": \"Offset Path\", \"mn\": \"{b4af429a-546e-4728-a869-711a404c55ae}\", \"a\": {\"a\": 0, \"k\": 10}, \"lj\": 2, \"ml\": {\"a\": 0, \"k\": 100}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 3}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let bezier_lottie = lottie_player_49_bezier.lottie; lottie.layers[0].shapes[0].it[0].is.k = data[\"Star Roundness\"]; lottie.layers[0].shapes[0].it[0].os.k = data[\"Star Roundness\"]; lottie.layers[0].shapes[0].it[1].a.k = data[\"Amount\"]; lottie.layers[0].shapes[0].it[1].lj = Number(data[\"Line Join\"]); lottie.layers[0].shapes[0].it[1].ml.k = data[\"Miter Limit\"]; let star = lottie.layers[0].shapes[0].it[0]; bezier_lottie.layers[0].shapes[0].it[1].w.k = 3; this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; let modifier = lottie.layers[0].shapes[0].it[1]; let bez_result = offset_path([convert_shape(star)], modifier.a.k, modifier.lj, modifier.ml.k); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_49_bezier.reload(); this.set_json('playground_49_5_bezier', out_shapes[0].ks.k); }, {} ); /* Simple offset of a linear segment */ function linear_offset(p1, p2, amount) { let angle = Math.atan2(p2.x - p1.x, p2.y - p1.y); return [ p1.add_polar(angle, amount), p2.add_polar(angle, amount) ]; } /* Offset a bezier segment only works well if the segment is flat enough */ function offset_segment(segment, amount) { let [p0, p1a] = linear_offset(segment.points[0], segment.points[1], amount); let [p1b, p2b] = linear_offset(segment.points[1], segment.points[2], amount); let [p2a, p3] = linear_offset(segment.points[2], segment.points[3], amount); let p1 = line_intersection(p0, p1a, p1b, p2b) ?? p1a; let p2 = line_intersection(p2a, p3, p1b, p2b) ?? p2a; return new BezierSegment(p0, p1, p2, p3); } /* Join two segments */ function join_lines(output_bezier, seg1, seg2, line_join, miter_limit) { let p0 = seg1.points[3]; let p1 = seg2.points[0]; // Bevel if ( line_join == 3 ) return p0; // Connected, they don't need a joint if ( p0.is_equal(p1) ) return p0; let last_point = output_bezier.points[output_bezier.points.length - 1]; // Round if ( line_join == 2 ) { const ellipse_constant = 0.5519; let angle_out = seg1.tangent_angle(1); let angle_in = seg2.tangent_angle(0) + Math.PI; let center = line_intersection( p0, p0.add_polar(angle_out + Math.PI / 2, 100), p1, p1.add_polar(angle_out + Math.PI / 2, 100) ); let radius = center ? center.distance(p0) : p0.distance(p1) / 2; last_point.set_out_tangent(Point.polar(angle_out, 2 * radius * ellipse_constant)); output_bezier.add_vertex(p1) .set_in_tangent(Point.polar(angle_in, 2 * radius * ellipse_constant)); return p1; } // Miter let t0 = p0.is_equal(seg1.points[2]) ? seg1.points[0] : seg1.points[2]; let t1 = p1.is_equal(seg2.points[1]) ? seg2.points[3] : seg2.points[1]; let intersection = line_intersection(t0, p0, p1, t1); if ( intersection && intersection.distance(p0) < miter_limit ) { output_bezier.add_vertex(intersection); return intersection; } return p0; } function get_intersection(a, b) { let intersect = a.intersections(b); if ( intersect.length && fuzzy_compare(intersect[0], 1) ) intersect.shift(); if ( intersect.length ) return intersect[0]; return null; } function prune_segment_intersection(a, b) { let out_a = [...a]; let out_b = [...b]; let intersect = get_intersection(a[a.length-1], b[0]); if ( intersect ) { out_a[a.length-1] = a[a.length-1].split(intersect[0])[0]; out_b[0] = b[0].split(intersect[1])[1]; } if ( a.length > 1 && b.length > 1 ) { intersect = get_intersection(a[0], b[b.length - 1]); if ( intersect ) { return [ [a[0].split(intersect[0])[0]], [b[b.length-1].split(intersect[1])[1]], ]; } } return [out_a, out_b]; } function prune_intersections(segments) { for ( let i = 1; i < segments.length; i++ ) { [segments[i-1], segments[i]] = prune_segment_intersection(segments[i - 1], segments[i]); } if ( segments.length > 1 ) [segments[segments.length - 1], segments[0]] = prune_segment_intersection(segments[segments.length - 1], segments[0]); return segments; } function offset_segment_split(segment, amount) { /* We split each bezier segment into smaller pieces based on inflection points, this ensures the control point polygon is convex. (A cubic bezier can have none, one, or two inflection points) */ let flex = segment.inflection_points(); if ( flex.length == 0 ) { return [offset_segment(segment, amount)]; } else if ( flex.length == 1 || flex[1] == 1 ) { let [left, right] = segment.split(flex[0]); return [ offset_segment(left, amount), offset_segment(right, amount) ]; } else { let [left, mid_right] = segment.split(flex[0]); let t = (flex[1] - flex[0]) / (1 - flex[0]); let [mid, right] = mid_right.split(t); return [ offset_segment(left, amount), offset_segment(mid, amount), offset_segment(right, amount) ]; } } function offset_path( // Beziers as collected from the other shapes collected_shapes, amount, line_join, miter_limit, ) { let result = []; for ( let input_bezier of collected_shapes ) { let output_bezier = new Bezier(); output_bezier.closed = input_bezier.closed; let count = input_bezier.segment_count(); let multi_segments = []; for ( let i = 0; i < count; i++ ) multi_segments.push(offset_segment_split(input_bezier.segment(i), amount)); // Open paths are stroked rather than being simply offset if ( !input_bezier.closed ) { for ( let i = count - 1; i >= 0; i-- ) multi_segments.push(offset_segment_split(input_bezier.inverted_segment(i), amount)); } multi_segments = prune_intersections(multi_segments); // Add bezier segments to the output and apply line joints let last_point = null; let last_seg = null; for ( let multi_segment of multi_segments ) { if ( last_seg ) last_point = join_lines(output_bezier, last_seg, multi_segment[0], line_join, miter_limit); last_seg = multi_segment[multi_segment.length - 1]; for ( let segment of multi_segment ) { if ( segment.points[0].is_equal(last_point) ) { output_bezier.points[output_bezier.points.length - 1] .set_out_tangent(segment.points[1].sub(segment.points[0])); } else { output_bezier.add_vertex(segment.points[0]) .set_out_tangent(segment.points[1].sub(segment.points[0])); } output_bezier.add_vertex(segment.points[3]) .set_in_tangent(segment.points[2].sub(segment.points[3])); last_point = segment.points[3]; } } if ( multi_segments.length ) join_lines(output_bezier, last_seg, multi_segments[0][0], line_join, miter_limit); result.push(output_bezier); } return result; } // Example invocation offset_path([convert_shape(star)], modifier.a.k, modifier.lj, modifier.ml.k); Trim Path Start 0 End 50 Offset 0 Multiple Shapes Parallel Sequential function trim_path_gather_chunks(collected_shapes, multiple) { let chunks = []; // Shapes are handled as a single unit if ( multiple === 2 ) chunks.push({segments: [], length: 0}); for ( let input_bezier of collected_shapes ) { // Shapes are all affected separately if ( multiple === 1 ) chunks.push({segments: [], length: 0}); let chunk = chunks[chunks.length-1]; for ( let i = 0; i < input_bezier.segment_count(); i++ ) { let segment = input_bezier.segment(i); let length = segment.get_length(); chunk.segments.push(segment); chunk.length += length; } // Use null as a marker to start a new bezier if ( multiple == 2 ) chunk.segments.push(null); } return chunks; } function trim_path_chunk(chunk, start, end, output_shapes) { // Note: start and end have been normalized and have the offset applied // The offset itself was normalized into [0, 1] so this is always true: // 0 <= start < end <= 2 // Some offsets require us to handle different \"splits\" // We want each split to be a pair [s, e] such that // 0 <= s < e <= 1 var splits = []; if ( end <= 1 ) { // Simplest case, the segment is in [0, 1] splits.push([start, end]); } else if ( start > 1 ) { // The whole segment is outside [0, 1] splits.push([start-1, end-1]); } else { // The segment goes over the end point, so we need two splits splits.push([start, 1]); splits.push([0, end-1]); } // Each split is a separate bezier, all left to do is finding the // bezier segment to add to the output for ( let [s, e] of splits ) { let start_length = s * chunk.length; let start_t; let end_length = e * chunk.length; let prev_length = 0; let output_bezier = new Bezier(false); output_shapes.push(output_bezier); for ( let i = 0; i < chunk.segments.length; i++ ) { let segment = chunk.segments[i]; // New bezier marker found if ( segment === null ) { output_bezier = new Bezier(false); output_shapes.push(output_bezier); continue; } if ( segment.length >= end_length ) { let end_t = segment.t_at_length(end_length); if ( segment.length >= start_length ) { start_t = segment.t_at_length(start_length); segment = segment.split(start_t)[1]; end_t = (end_t - start_t) / (1 - start_t); } output_bezier.add_segment(segment.split(end_t)[0], false); break; } if ( start_t === undefined ) { if ( segment.length >= start_length ) { start_t = segment.t_at_length(start_length); output_bezier.add_segment(segment.split(start_t)[1], false); } } else { output_bezier.add_segment(segment, true); } start_length -= segment.length; end_length -= segment.length; } } } function trim_path( collected_shapes, start, end, offset, multiple ) { // Normalize Inputs offset = offset / 360 % 1; if ( offset < 0 ) offset += 1; start = Math.min(1, Math.max(0, start / 100)); end = Math.min(1, Math.max(0, end / 100)); if ( end < start ) [start, end] = [end, start]; // Apply offset start += offset; end += offset; // Handle the degenerate cases if ( fuzzy_compare(start, end) ) return [new Bezier(false)]; if ( fuzzy_zero(start) && fuzzy_compare(end, 1) ) return collected_shapes; // Gather up the segments to trim let chunks = trim_path_gather_chunks(collected_shapes, multiple); let output_shapes = []; for ( let chunk of chunks ) trim_path_chunk(chunk, start, end, output_shapes); return output_shapes; } var lottie_player_50_bezier = new LottiePlayer('lottie_target_50_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_50 = new PlaygroundPlayer( 50, 'playground_50_5', 'lottie_target_50', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [128, 128]}, \"or\": {\"a\": 0, \"k\": 100}, \"ir\": {\"a\": 0, \"k\": 50}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{74587b40-1ef1-445d-b9ab-02b8a42a96aa}\", \"p\": {\"a\": 0, \"k\": [384, 128]}, \"s\": {\"a\": 0, \"k\": [200, 200]}}, {\"ty\": \"rc\", \"nm\": \"Rect\", \"mn\": \"{0776f2df-2619-415c-b10d-f648f2edfa0f}\", \"d\": 1, \"p\": {\"a\": 0, \"k\": [128, 384]}, \"s\": {\"a\": 0, \"k\": [200, 200]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"sr\", \"nm\": \"Triangle\", \"mn\": \"{db373594-d0ae-44ff-9295-30ff72616af2}\", \"p\": {\"a\": 0, \"k\": [384, 384]}, \"or\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 3}, \"sy\": 2, \"os\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"tm\", \"nm\": \"Trim Path\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"s\": {\"a\": 0, \"k\": 0}, \"e\": {\"a\": 0, \"k\": 50}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 20}}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { let bezier_lottie = lottie_player_50_bezier.lottie; lottie.layers[0].shapes[4].s.k = data[\"Start\"]; lottie.layers[0].shapes[4].e.k = data[\"End\"]; lottie.layers[0].shapes[4].o.k = data[\"Offset\"]; lottie.layers[0].shapes[4].m = Number(data[\"Multiple Shapes\"]); let siblings = bezier_lottie.layers[0].shapes[0].it; siblings[siblings.length-2].w.k = 20; let shapes = []; for ( let i = 0; i < 4; i++ ) shapes.push(convert_shape(lottie.layers[0].shapes[i])); this.json_viewer_contents = lottie.layers[0].shapes[4]; let modifier = lottie.layers[0].shapes[4]; let bez_result = trim_path(shapes, modifier.s.k, modifier.e.k, modifier.o.k, modifier.m); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_50_bezier.reload(); this.set_json('playground_50_5_bezier', out_shapes[0].ks.k); }, {} ); function trim_path_gather_chunks(collected_shapes, multiple) { let chunks = []; // Shapes are handled as a single unit if ( multiple === 2 ) chunks.push({segments: [], length: 0}); for ( let input_bezier of collected_shapes ) { // Shapes are all affected separately if ( multiple === 1 ) chunks.push({segments: [], length: 0}); let chunk = chunks[chunks.length-1]; for ( let i = 0; i < input_bezier.segment_count(); i++ ) { let segment = input_bezier.segment(i); let length = segment.get_length(); chunk.segments.push(segment); chunk.length += length; } // Use null as a marker to start a new bezier if ( multiple == 2 ) chunk.segments.push(null); } return chunks; } function trim_path_chunk(chunk, start, end, output_shapes) { // Note: start and end have been normalized and have the offset applied // The offset itself was normalized into [0, 1] so this is always true: // 0 <= start < end <= 2 // Some offsets require us to handle different \"splits\" // We want each split to be a pair [s, e] such that // 0 <= s < e <= 1 var splits = []; if ( end <= 1 ) { // Simplest case, the segment is in [0, 1] splits.push([start, end]); } else if ( start > 1 ) { // The whole segment is outside [0, 1] splits.push([start-1, end-1]); } else { // The segment goes over the end point, so we need two splits splits.push([start, 1]); splits.push([0, end-1]); } // Each split is a separate bezier, all left to do is finding the // bezier segment to add to the output for ( let [s, e] of splits ) { let start_length = s * chunk.length; let start_t; let end_length = e * chunk.length; let prev_length = 0; let output_bezier = new Bezier(false); output_shapes.push(output_bezier); for ( let i = 0; i < chunk.segments.length; i++ ) { let segment = chunk.segments[i]; // New bezier marker found if ( segment === null ) { output_bezier = new Bezier(false); output_shapes.push(output_bezier); continue; } if ( segment.length >= end_length ) { let end_t = segment.t_at_length(end_length); if ( segment.length >= start_length ) { start_t = segment.t_at_length(start_length); segment = segment.split(start_t)[1]; end_t = (end_t - start_t) / (1 - start_t); } output_bezier.add_segment(segment.split(end_t)[0], false); break; } if ( start_t === undefined ) { if ( segment.length >= start_length ) { start_t = segment.t_at_length(start_length); output_bezier.add_segment(segment.split(start_t)[1], false); } } else { output_bezier.add_segment(segment, true); } start_length -= segment.length; end_length -= segment.length; } } } function trim_path( collected_shapes, start, end, offset, multiple ) { // Normalize Inputs offset = offset / 360 % 1; if ( offset < 0 ) offset += 1; start = Math.min(1, Math.max(0, start / 100)); end = Math.min(1, Math.max(0, end / 100)); if ( end < start ) [start, end] = [end, start]; // Apply offset start += offset; end += offset; // Handle the degenerate cases if ( fuzzy_compare(start, end) ) return [new Bezier(false)]; if ( fuzzy_zero(start) && fuzzy_compare(end, 1) ) return collected_shapes; // Gather up the segments to trim let chunks = trim_path_gather_chunks(collected_shapes, multiple); let output_shapes = []; for ( let chunk of chunks ) trim_path_chunk(chunk, start, end, output_shapes); return output_shapes; } // Example invocation trim_path(shapes, modifier.s.k, modifier.e.k, modifier.o.k, modifier.m); Transform This is how to convert a transform object into a matrix. Assuming the matrix a c 0 0 b d 0 0 0 0 1 0 tx ty 0 1 The names a , b , etc are the ones commonly used for CSS transforms . 4D matrix to allow for 3D transforms, even though currently lottie only supports 2D graphics. Multiplications are right multiplications ( Next = Previous * StepOperation ). If your transform is transposed ( tx , ty are on the last column), perform left multiplication instead. Perform the following operations on a matrix starting from the identity matrix (or the parent object's transform matrix): Translate by -a : 1 0 0 0 0 1 0 0 0 0 1 0 -a[0] -a[1] 0 1 Scale by s/100 : s[0]/100 0 0 0 0 s[1]/100 0 0 0 0 1 0 0 0 0 1 Rotate by -sa (can be skipped if not skewing) cos(-sa) sin(-sa) 0 0 -sin(-sa) cos(-sa) 0 0 0 0 1 0 0 0 0 1 Skew by sk (can be skipped if not skewing) 1 tan(-sk) 0 0 0 1 0 0 0 0 1 0 0 0 0 1 Rotate by sa (can be skipped if not skewing) cos(sa) sin(sa) 0 0 -sin(sa) cos(sa) 0 0 0 0 1 0 0 0 0 1 Rotate by -r cos(-r) sin(-r) 0 0 -sin(-r) cos(-r) 0 0 0 0 1 0 0 0 0 1 If you are handling an auto orient layer, evaluate and apply auto-orient rotation. Translate by p 1 0 0 0 0 1 0 0 0 0 1 0 p[0] p[1] 0 1 3D Transform If you have a 3D transform, the process is similar, with a , p , s , using their 3D matrices, note that for p and a the Z axis is inverted. The rotation step is a bit more complicated, with the 2D rotation being equivalent to a Z rotation. The rotation step above is replaced with the following set of steps: Rotate by -rz cos(-r) sin(-r) 0 0 -sin(-r) cos(-r) 0 0 0 0 1 0 0 0 0 1 Rotate by ry cos(r) 0 sin(r) 0 0 1 0 0 -sin(r) 0 cos(-r) 0 0 0 1 Rotate by rx 1 0 0 0 0 cos(r) -sin(r) 0 0 -sin(r) cos(-r) 0 0 0 0 1 Then repeat the steps for or : Rotate by -or[2] (Z axis) cos(-r) sin(-r) 0 0 -sin(-r) cos(-r) 0 0 0 0 1 0 0 0 0 1 Rotate by or[1] (Y axis) cos(r) 0 sin(r) 0 0 1 0 0 -sin(r) 0 cos(-r) 0 0 0 1 Rotate by or[0] (X axis) 1 0 0 0 0 cos(r) -sin(r) 0 0 -sin(r) cos(-r) 0 0 0 0 1 Auto Orient Auto-orient is only relevant for layers that have ao set to 1 an animated position. You get the derivative of the position property at the current time as a pair ( dx , dy ), and find the angle with atan2(dy, dx) , then rotate by that angle clockwise: cos(-r) sin(-r) 0 0 -sin(-r) cos(-r) 0 0 0 0 1 0 0 0 0 1 Animated Properties Assuming a 1D property, a keyframe looks something like this: { \"t\": start_time, \"s\": [ start_value ], \"o\": { \"x\": [ ox ], \"y\": [ oy ] }, \"i\": { \"x\": [ ix ], \"y\": [ iy ] } } Where: t is the time at the start of the keyframe (in frames), s is the value at that time i and o are the in/out bezier tangents The transition between keyframes is defined by two keyframes, for simplicity we'll refer to the named values above plus end_time and end_value corresponding to t and s on the keyframe after the one listed. The transition is given as a cubic bezier curve whose x axis is time and the y axis is the interpolating factor between start_value and end_value . The four points of this bezier curve are: (0, 0), (ox, oy), (iy, iy), (1, 1). x is given by x = (current_time - start_time) / (end_time - start_time) . If the bezier is defined as a t 3 + b t 2 + c t + d = 0 then you need to find the cubic roots of a t 3 + b t 2 + c t + d - x = 0 to find the t corresponding to that x , (You only need to consider real roots in [0, 1]). Then you can find the y by evaluating the bezier at t . The final value is as follows: lerp(y, start_value, end_value) . KeyframePreviewEditor.stand_alone(document.getElementById(\"editor_51\"), (lottie) => { var raw_json = JSON.stringify(lottie, undefined, 4); var pretty_json = hljs.highlight(\"json\", raw_json).value; document.getElementById(\"json_viewer_51\").innerHTML = pretty_json; }, {foreground: function () { if ( !this.x_input ) return; var t1 = this.points[0].out_tan.logical_coords(); var t2 = this.points[1].in_tan.logical_coords(); var seg = new BezierSegment( new Point(0, 0), new Point(t1.x, t1.y), new Point(t2.x, t2.y), new Point(1, 1) ); let x = Number(this.x_input.value); this.context.lineWidth = 1; this.context.strokeStyle = \"red\"; this.context.beginPath(); this.context.moveTo(...this.logical_to_canvas(x, 0)); this.context.lineTo(...this.logical_to_canvas(x, 1)); let t = seg.t_at_x(x); let y = seg.value(t).y; this.context.moveTo(...this.logical_to_canvas(0, y)); this.context.lineTo(...this.logical_to_canvas(1, y)); this.table_x.innerText = x; this.table_t.innerText = t; this.table_y.innerText = y; this.context.stroke(); }, init: function (editor, container) { var inp = container.appendChild(document.createElement(\"input\")); var style = \"width: \" + editor.bezier_editor.canvas.width + \"px\"; editor.bezier_editor.x_input = inp; inp.setAttribute(\"type\", \"range\"); inp.setAttribute(\"min\", \"0\"); inp.setAttribute(\"max\", \"1\"); inp.setAttribute(\"value\", \"0\"); inp.setAttribute(\"step\", \"0.01\"); inp.setAttribute(\"style\", style); inp.addEventListener(\"input\", () => editor.bezier_editor.draw_frame()); var table = container.appendChild(document.createElement(\"table\")); table.setAttribute(\"style\", style); for ( let v of \"xty\" ) { var tr = table.appendChild(document.createElement(\"tr\")); tr.appendChild(document.createElement(\"th\")).appendChild(document.createTextNode(v)); var td = tr.appendChild(document.createElement(\"td\")); td.setAttribute(\"style\", \"text-align: left; width: 90%;\"); editor.bezier_editor[\"table_\" + v] = td; } editor.bezier_editor.draw_frame(); }, }); Effects .webgl-shader { transform: scaleY(-1); } Fill Effect Opacity Color 1 Red 1 Green 0.9 Blue 0 var lottie_shader_38 = new SinglePassShader(document.getElementById('lottie_target_38_canvas')); lottie_shader_38.set_fragment('#version 100\\n\\nuniform highp vec4 color;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\nvoid main()\\n{\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n highp vec4 pixel = texture2D(texture_sampler, uv);\\n\\n gl_FragColor = color;\\n gl_FragColor.a = 1.0;\\n gl_FragColor *= pixel.a * color.a;\\n}') var lottie_player_38 = new PlaygroundPlayer( 38, 'playground_38_5', 'lottie_target_38', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 21, \"ef\": [{\"ty\": 3, \"v\": {\"k\": [0, 0], \"a\": 0}}, {\"ty\": 7, \"v\": {\"k\": 0, \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [1, 0.9, 0, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}, {\"ty\": 7, \"v\": {\"k\": 0, \"a\": 0}}, {\"ty\": 0, \"v\": {\"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"a\": 0, \"k\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { let shader = lottie_shader_38; lottie.layers[0].ef[0].ef[6].v.k = data[\"Opacity\"]; lottie.layers[0].ef[0].ef[2].v.k[0] = data[\"Red\"]; lottie.layers[0].ef[0].ef[2].v.k[1] = data[\"Green\"]; lottie.layers[0].ef[0].ef[2].v.k[2] = data[\"Blue\"]; shader.set_uniform(\"color\", \"4fv\", [data[\"Red\"], data[\"Green\"], data[\"Blue\"], data[\"Opacity\"]]); this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} ); #version 100 uniform highp vec4 color; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; void main() { highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); highp vec4 pixel = texture2D(texture_sampler, uv); gl_FragColor = color; gl_FragColor.a = 1.0; gl_FragColor *= pixel.a * color.a; } Tritone Effect Red 1 Green 1 Blue Mid 1 Red 0.3 Green 0.8 Blue Dark 0.3 Red 0 Green 0 Blue 0 var lottie_shader_39 = new SinglePassShader(document.getElementById('lottie_target_39_canvas')); lottie_shader_39.set_fragment('#version 100\\n\\nuniform highp vec4 bright;\\nuniform highp vec4 mid;\\nuniform highp vec4 dark;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\nvoid main()\\n{\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n highp vec4 pixel = texture2D(texture_sampler, uv);\\n\\n highp float lightness = sqrt(pixel.r * pixel.r * 0.299 + pixel.g * pixel.g * 0.587 + pixel.b * pixel.b * 0.114);\\n // If you want results more similar to lottie-web use the lightness below\\n // (this shader has a more accurate lightness calculation)\\n // lightness = sqrt((pixel.r * pixel.r + pixel.g * pixel.g + pixel.b * pixel.b) / 3.0);\\n\\n if ( lightness < 0.5 )\\n {\\n lightness *= 2.0;\\n gl_FragColor = dark * (1.0 - lightness) + mid * lightness;\\n }\\n else\\n {\\n lightness = (lightness - 0.5) * 2.0;\\n gl_FragColor = mid * (1.0 - lightness) + bright * lightness;\\n }\\n\\n gl_FragColor *= pixel.a;\\n}') var lottie_player_39 = new PlaygroundPlayer( 39, 'playground_39_10', 'lottie_target_39', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 23, \"ef\": [{\"ty\": 2, \"v\": {\"k\": [1, 1, 1, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0.3, 0.8, 0.3, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { let shader = lottie_shader_39; lottie.layers[0].ef[0].ef[0].v.k[0] = data[\"r1\"]; lottie.layers[0].ef[0].ef[0].v.k[1] = data[\"g1\"]; lottie.layers[0].ef[0].ef[0].v.k[2] = data[\"b1\"]; lottie.layers[0].ef[0].ef[1].v.k[0] = data[\"r2\"]; lottie.layers[0].ef[0].ef[1].v.k[1] = data[\"g2\"]; lottie.layers[0].ef[0].ef[1].v.k[2] = data[\"b2\"]; lottie.layers[0].ef[0].ef[2].v.k[0] = data[\"r3\"]; lottie.layers[0].ef[0].ef[2].v.k[1] = data[\"g3\"]; lottie.layers[0].ef[0].ef[2].v.k[2] = data[\"b3\"]; shader.set_uniform(\"bright\", \"4fv\", [data[\"r1\"], data[\"g1\"], data[\"b1\"], 1]); shader.set_uniform(\"mid\", \"4fv\", [data[\"r2\"], data[\"g2\"], data[\"b2\"], 1]); shader.set_uniform(\"dark\", \"4fv\", [data[\"r3\"], data[\"g3\"], data[\"b3\"], 1]); this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} ); #version 100 uniform highp vec4 bright; uniform highp vec4 mid; uniform highp vec4 dark; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; void main() { highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); highp vec4 pixel = texture2D(texture_sampler, uv); highp float lightness = sqrt(pixel.r * pixel.r * 0.299 + pixel.g * pixel.g * 0.587 + pixel.b * pixel.b * 0.114); // If you want results more similar to lottie-web use the lightness below // (this shader has a more accurate lightness calculation) // lightness = sqrt((pixel.r * pixel.r + pixel.g * pixel.g + pixel.b * pixel.b) / 3.0); if ( lightness < 0.5 ) { lightness *= 2.0; gl_FragColor = dark * (1.0 - lightness) + mid * lightness; } else { lightness = (lightness - 0.5) * 2.0; gl_FragColor = mid * (1.0 - lightness) + bright * lightness; } gl_FragColor *= pixel.a; } Gaussian Blur This is a two-pass shader, the uniform pass is has value 0 on the first pass and value 1 on the second pass. Sigma 25 Direction\" Both Horizontal Vertical Wrap var lottie_shader_40 = new MultiPassShader(document.getElementById('lottie_target_40_canvas')); var program_40_0 = new ShaderProgram(lottie_shader_40.gl); program_40_0.set_fragment('#version 300 es\\n\\n#define PI 3.1415926538\\nprecision highp float;\\n\\nuniform float sigma;\\nuniform int direction;\\nuniform int kernel_size;\\nuniform bool wrap;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\nuniform int pass;\\n\\nout vec4 FragColor;\\n\\n\\nvec4 texture_value(vec2 uv)\\n{\\n if ( wrap )\\n {\\n if ( uv.x < 0. ) uv.x = 1. - uv.x;\\n if ( uv.x > 1. ) uv.x = uv.x - 1.;\\n if ( uv.y < 0. ) uv.y = 1. - uv.y;\\n if ( uv.y > 1. ) uv.y = uv.y - 1.;\\n }\\n else if ( uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1. )\\n {\\n return vec4(0.0);\\n }\\n\\n return texture(texture_sampler, uv);\\n}\\n\\n\\nvec4 blur_pass(float sigma, int kernel_size, vec2 uv, bool horizontal)\\n{\\n float side = float(kernel_size / 2);\\n\\n vec2 direction_vector = horizontal ?\\n vec2(1.0, 0.0) / canvas_size.x :\\n vec2(0.0, 1.0) / canvas_size.y;\\n\\n vec3 delta_gauss;\\n delta_gauss.x = 1.0 / (sqrt(2.0 * PI) * sigma);\\n delta_gauss.y = exp(-0.5 / (sigma * sigma));\\n delta_gauss.z = delta_gauss.y * delta_gauss.y;\\n\\n vec4 avg = vec4(0.0, 0.0, 0.0, 0.0);\\n float sum = 0.0;\\n\\n vec4 pixel = texture_value(uv);\\n avg += pixel * delta_gauss.x;\\n sum += delta_gauss.x;\\n delta_gauss.xy *= delta_gauss.yz;\\n\\n for ( float i = 1.0; i <= side; i++)\\n {\\n for ( float s = -1.0; s <= 1.0; s += 2.0 )\\n {\\n vec2 pos = uv + s * i * direction_vector;\\n pixel = texture_value(pos);\\n avg += pixel * delta_gauss.x;\\n }\\n sum += 2.0 * delta_gauss.x;\\n delta_gauss.xy *= delta_gauss.yz;\\n }\\n\\n avg /= sum;\\n\\n return avg;\\n}\\n\\n\\nvoid main()\\n{\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n\\n int actual_kernel_size = kernel_size == 0 ? int(0.5 + 6.0 * sigma) : kernel_size;\\n\\n const float multiplier = 0.25;\\n\\n if ( sigma == 0.0 )\\n {\\n FragColor = texture(texture_sampler, uv);\\n }\\n else if ( pass == 0 )\\n {\\n if ( direction != 3 )\\n FragColor = blur_pass(sigma * multiplier, actual_kernel_size, uv, true);\\n else\\n FragColor = texture(texture_sampler, uv);\\n }\\n else if ( pass == 1 )\\n {\\n if ( direction != 2 )\\n FragColor = blur_pass(sigma * multiplier, actual_kernel_size, uv, false);\\n else\\n FragColor = texture(texture_sampler, uv);\\n }\\n}') lottie_shader_40.add_pass(program_40_0, {\"pass\": [\"1i\", 0]}) lottie_shader_40.add_pass(program_40_0, {\"pass\": [\"1i\", 1]}) var lottie_player_40 = new PlaygroundPlayer( 40, 'playground_40_4', 'lottie_target_40', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 29, \"en\": 1, \"ef\": [{\"ty\": 0, \"v\": {\"a\": 0, \"k\": 25}}, {\"ty\": 0, \"v\": {\"k\": 0, \"a\": 0}}, {\"ty\": 4, \"v\": {\"k\": 0, \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { let shader = lottie_shader_40; lottie.layers[0].ef[0].ef[0].v.k = data[\"Sigma\"]; lottie.layers[0].ef[0].ef[1].v.k = Number(data[\"Direction\"]); lottie.layers[0].ef[0].ef[2].v.k = Number(data[\"Wrap\"]); for ( let pass of [0, 1] ) { shader.set_uniform(pass, \"sigma\", \"1f\", data[\"Sigma\"]); shader.set_uniform(pass, \"direction\", \"1i\", data[\"Direction\"]); shader.set_uniform(pass, \"wrap\", \"1i\", data[\"Wrap\"]); } this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} ); #version 300 es #define PI 3.1415926538 precision highp float; uniform float sigma; uniform int direction; uniform int kernel_size; uniform bool wrap; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; uniform int pass; out vec4 FragColor; vec4 texture_value(vec2 uv) { if ( wrap ) { if ( uv.x < 0. ) uv.x = 1. - uv.x; if ( uv.x > 1. ) uv.x = uv.x - 1.; if ( uv.y < 0. ) uv.y = 1. - uv.y; if ( uv.y > 1. ) uv.y = uv.y - 1.; } else if ( uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1. ) { return vec4(0.0); } return texture(texture_sampler, uv); } vec4 blur_pass(float sigma, int kernel_size, vec2 uv, bool horizontal) { float side = float(kernel_size / 2); vec2 direction_vector = horizontal ? vec2(1.0, 0.0) / canvas_size.x : vec2(0.0, 1.0) / canvas_size.y; vec3 delta_gauss; delta_gauss.x = 1.0 / (sqrt(2.0 * PI) * sigma); delta_gauss.y = exp(-0.5 / (sigma * sigma)); delta_gauss.z = delta_gauss.y * delta_gauss.y; vec4 avg = vec4(0.0, 0.0, 0.0, 0.0); float sum = 0.0; vec4 pixel = texture_value(uv); avg += pixel * delta_gauss.x; sum += delta_gauss.x; delta_gauss.xy *= delta_gauss.yz; for ( float i = 1.0; i <= side; i++) { for ( float s = -1.0; s <= 1.0; s += 2.0 ) { vec2 pos = uv + s * i * direction_vector; pixel = texture_value(pos); avg += pixel * delta_gauss.x; } sum += 2.0 * delta_gauss.x; delta_gauss.xy *= delta_gauss.yz; } avg /= sum; return avg; } void main() { highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); int actual_kernel_size = kernel_size == 0 ? int(0.5 + 6.0 * sigma) : kernel_size; const float multiplier = 0.25; if ( sigma == 0.0 ) { FragColor = texture(texture_sampler, uv); } else if ( pass == 0 ) { if ( direction != 3 ) FragColor = blur_pass(sigma * multiplier, actual_kernel_size, uv, true); else FragColor = texture(texture_sampler, uv); } else if ( pass == 1 ) { if ( direction != 2 ) FragColor = blur_pass(sigma * multiplier, actual_kernel_size, uv, false); else FragColor = texture(texture_sampler, uv); } } Drop Shadow Effect The effect below is split into multiple shaders: First it generates the shadow Then it has a 2 pass gaussian blur (simplified from the example above) Finally, it composites the original image on top of the blurred shadow Red 0 Green 0 Blue 0 Opacity 128 Angle 135 Distance 10 Blur 7 var lottie_shader_41 = new MultiPassShader(document.getElementById('lottie_target_41_canvas')); lottie_shader_41.add_pass_source('#version 300 es\\n#define PI 3.1415926538\\n\\nuniform highp vec4 color;\\nuniform mediump float angle;\\nuniform mediump float distance;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\nout highp vec4 FragColor;\\n\\nvoid main()\\n{\\n // Base pixel value\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n highp vec4 pixel = texture(texture_sampler, uv);\\n\\n // Pixel value at the given offset\\n mediump float radians = -angle * PI / 180.0 + PI / 2.0;\\n highp vec2 shadow_uv = vec2(\\n (gl_FragCoord.x - distance * cos(radians)) / canvas_size.x,\\n 1.0 - (gl_FragCoord.y - distance * sin(radians)) / canvas_size.y\\n );\\n highp vec4 shadow_pixel = texture(texture_sampler, shadow_uv);\\n\\n // Colorize shadow\\n highp vec4 shadow_color;\\n\\n if ( shadow_uv.x >= 0.0 && shadow_uv.x <= 1.0 && shadow_uv.y >= 0.0 && shadow_uv.y <= 1.0 )\\n {\\n shadow_color = color;\\n shadow_color.a = 1.0;\\n shadow_color *= shadow_pixel.a * color.a / 255.0;\\n }\\n\\n // Apply shadow below the base pixel\\n FragColor = shadow_color; //pixel * pixel.a + shadow_color * (1.0 - pixel.a);\\n}', {\"pass\": [\"1i\", 0]}) var program_41_1 = new ShaderProgram(lottie_shader_41.gl); program_41_1.set_fragment('#version 300 es\\n\\n#define PI 3.1415926538\\nprecision highp float;\\n\\nuniform float sigma;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\nuniform int pass;\\n\\nout vec4 FragColor;\\n\\nvec4 blur_pass(float sigma, int kernel_size, vec2 uv, bool horizontal)\\n{\\n float side = float(kernel_size / 2);\\n\\n vec2 direction_vector = horizontal ?\\n vec2(1.0, 0.0) / canvas_size.x :\\n vec2(0.0, 1.0) / canvas_size.y;\\n\\n vec3 delta_gauss;\\n delta_gauss.x = 1.0 / (sqrt(2.0 * PI) * sigma);\\n delta_gauss.y = exp(-0.5 / (sigma * sigma));\\n delta_gauss.z = delta_gauss.y * delta_gauss.y;\\n\\n vec4 avg = vec4(0.0, 0.0, 0.0, 0.0);\\n float sum = 0.0;\\n\\n vec4 pixel = texture(texture_sampler, uv);\\n avg += pixel * delta_gauss.x;\\n sum += delta_gauss.x;\\n delta_gauss.xy *= delta_gauss.yz;\\n\\n for ( float i = 1.0; i <= side; i++)\\n {\\n for ( float s = -1.0; s <= 1.0; s += 2.0 )\\n {\\n vec2 pos = uv + s * i * direction_vector;\\n pixel = texture(texture_sampler, pos);\\n avg += pixel * delta_gauss.x;\\n }\\n sum += 2.0 * delta_gauss.x;\\n delta_gauss.xy *= delta_gauss.yz;\\n }\\n\\n avg /= sum;\\n\\n return avg;\\n}\\n\\n\\nvoid main()\\n{\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n\\n int kernel_size = int(0.5 + 6.0 * sigma);\\n\\n const float multiplier = 0.25;\\n\\n if ( sigma == 0.0 )\\n FragColor = texture(texture_sampler, uv);\\n else if ( pass == 1 )\\n FragColor = blur_pass(sigma * multiplier, kernel_size, uv, true);\\n else if ( pass == 2 )\\n FragColor = blur_pass(sigma * multiplier, kernel_size, uv, false);\\n}') lottie_shader_41.add_pass(program_41_1, {\"pass\": [\"1i\", 1]}) lottie_shader_41.add_pass(program_41_1, {\"pass\": [\"1i\", 2]}) lottie_shader_41.add_pass_source('#version 300 es\\n\\nprecision highp float;\\n\\nuniform sampler2D original;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\nout vec4 FragColor;\\n\\nvec4 alpha_blend(vec4 top, vec4 bottom)\\n{\\n float comp_alpha = bottom.a * (1.0 - top.a);\\n vec4 result;\\n result.a = top.a + comp_alpha;\\n result.rgb = (top.rgb * top.a + bottom.rgb * comp_alpha) / result.a;\\n return result;\\n}\\n\\nvoid main()\\n{\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n\\n FragColor = alpha_blend(\\n texture(original, uv),\\n texture(texture_sampler, vec2(uv.x, 1.0 - uv.y))\\n );\\n}', {\"pass\": [\"1i\", 3]}) var lottie_player_41 = new PlaygroundPlayer( 41, 'playground_41_8', 'lottie_target_41', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 25, \"ef\": [{\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 128, \"a\": 0}}, {\"ty\": 1, \"v\": {\"k\": 135, \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 10, \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 7, \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { let shader = lottie_shader_41; lottie.layers[0].ef[0].ef[0].v.k[0] = data[\"Red\"]; lottie.layers[0].ef[0].ef[0].v.k[1] = data[\"Green\"]; lottie.layers[0].ef[0].ef[0].v.k[2] = data[\"Blue\"]; lottie.layers[0].ef[0].ef[1].v.k = data[\"Opacity\"]; lottie.layers[0].ef[0].ef[2].v.k = data[\"Angle\"]; lottie.layers[0].ef[0].ef[3].v.k = data[\"Distance\"]; lottie.layers[0].ef[0].ef[4].v.k = data[\"Blur\"]; shader.set_uniform(0, \"color\", \"4fv\", [data[\"Red\"], data[\"Green\"], data[\"Blue\"], data[\"Opacity\"]]); shader.set_uniform(0, \"angle\", \"1f\", data[\"Angle\"]); // 0.77 is just to take into account the canvas is 394 instead of 512 shader.set_uniform(0, \"distance\", \"1f\", data[\"Distance\"] * 0.77); shader.set_uniform(1, \"sigma\", \"1f\", data[\"Blur\"]); shader.set_uniform(2, \"sigma\", \"1f\", data[\"Blur\"]); shader.texture(\"/lottie-docs/examples/blep.png\").set_uniform(shader.passes[3].program, \"original\"); this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} ); #version 300 es #define PI 3.1415926538 uniform highp vec4 color; uniform mediump float angle; uniform mediump float distance; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; out highp vec4 FragColor; void main() { // Base pixel value highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); highp vec4 pixel = texture(texture_sampler, uv); // Pixel value at the given offset mediump float radians = -angle * PI / 180.0 + PI / 2.0; highp vec2 shadow_uv = vec2( (gl_FragCoord.x - distance * cos(radians)) / canvas_size.x, 1.0 - (gl_FragCoord.y - distance * sin(radians)) / canvas_size.y ); highp vec4 shadow_pixel = texture(texture_sampler, shadow_uv); // Colorize shadow highp vec4 shadow_color; if ( shadow_uv.x >= 0.0 && shadow_uv.x <= 1.0 && shadow_uv.y >= 0.0 && shadow_uv.y <= 1.0 ) { shadow_color = color; shadow_color.a = 1.0; shadow_color *= shadow_pixel.a * color.a / 255.0; } // Apply shadow below the base pixel FragColor = shadow_color; //pixel * pixel.a + shadow_color * (1.0 - pixel.a); } #version 300 es #define PI 3.1415926538 precision highp float; uniform float sigma; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; uniform int pass; out vec4 FragColor; vec4 blur_pass(float sigma, int kernel_size, vec2 uv, bool horizontal) { float side = float(kernel_size / 2); vec2 direction_vector = horizontal ? vec2(1.0, 0.0) / canvas_size.x : vec2(0.0, 1.0) / canvas_size.y; vec3 delta_gauss; delta_gauss.x = 1.0 / (sqrt(2.0 * PI) * sigma); delta_gauss.y = exp(-0.5 / (sigma * sigma)); delta_gauss.z = delta_gauss.y * delta_gauss.y; vec4 avg = vec4(0.0, 0.0, 0.0, 0.0); float sum = 0.0; vec4 pixel = texture(texture_sampler, uv); avg += pixel * delta_gauss.x; sum += delta_gauss.x; delta_gauss.xy *= delta_gauss.yz; for ( float i = 1.0; i <= side; i++) { for ( float s = -1.0; s <= 1.0; s += 2.0 ) { vec2 pos = uv + s * i * direction_vector; pixel = texture(texture_sampler, pos); avg += pixel * delta_gauss.x; } sum += 2.0 * delta_gauss.x; delta_gauss.xy *= delta_gauss.yz; } avg /= sum; return avg; } void main() { highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); int kernel_size = int(0.5 + 6.0 * sigma); const float multiplier = 0.25; if ( sigma == 0.0 ) FragColor = texture(texture_sampler, uv); else if ( pass == 1 ) FragColor = blur_pass(sigma * multiplier, kernel_size, uv, true); else if ( pass == 2 ) FragColor = blur_pass(sigma * multiplier, kernel_size, uv, false); } #version 300 es precision highp float; uniform sampler2D original; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; out vec4 FragColor; vec4 alpha_blend(vec4 top, vec4 bottom) { float comp_alpha = bottom.a * (1.0 - top.a); vec4 result; result.a = top.a + comp_alpha; result.rgb = (top.rgb * top.a + bottom.rgb * comp_alpha) / result.a; return result; } void main() { highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); FragColor = alpha_blend( texture(original, uv), texture(texture_sampler, vec2(uv.x, 1.0 - uv.y)) ); } Pro Levels Effect In Black 0 In White 1 Gamma 1 Out Black 0 Out White Red 1 In Black 0 In White 1 Gamma 1 Out Black 0 Out White Green 1 In Black 0 In White 1 Gamma 1 Out Black 0 Out White Blue 1 In Black 0 In White 1 Gamma 1 Out Black 0 Out White 1 var lottie_shader_42 = new SinglePassShader(document.getElementById('lottie_target_42_canvas')); lottie_shader_42.set_fragment('#version 100\\nprecision highp float;\\n\\nuniform highp float composite_in_black;\\nuniform highp float composite_in_white;\\nuniform highp float composite_gamma;\\nuniform highp float composite_out_black;\\nuniform highp float composite_out_white;\\n\\nuniform highp float red_in_black;\\nuniform highp float red_in_white;\\nuniform highp float red_gamma;\\nuniform highp float red_out_black;\\nuniform highp float red_out_white;\\n\\nuniform highp float green_in_black;\\nuniform highp float green_in_white;\\nuniform highp float green_gamma;\\nuniform highp float green_out_black;\\nuniform highp float green_out_white;\\n\\nuniform highp float blue_in_black;\\nuniform highp float blue_in_white;\\nuniform highp float blue_gamma;\\nuniform highp float blue_out_black;\\nuniform highp float blue_out_white;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\n\\nfloat adjust_channel(float value, float in_black, float in_white, float gamma, float out_black, float out_white)\\n{\\n float in_delta = in_white - in_black;\\n float out_delta = out_white - out_black;\\n if ( in_delta == 0.0 )\\n return out_black;\\n\\n // Clamp to input range\\n if ( value <= in_black && value <= in_white )\\n return out_black;\\n\\n if ( value >= in_black && value >= in_white )\\n return out_white;\\n\\n // Apply adjustment\\n return out_black + out_delta * pow((value - in_black) / in_delta, 1.0 / gamma);\\n}\\n\\n\\nvoid main()\\n{\\n // Base pixel value\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n highp vec4 pixel = texture2D(texture_sampler, uv);\\n\\n // First Pass: composite\\n pixel.rgb = vec3(\\n adjust_channel(pixel.r, composite_in_black, composite_in_white, composite_gamma, composite_out_black, composite_out_white),\\n adjust_channel(pixel.g, composite_in_black, composite_in_white, composite_gamma, composite_out_black, composite_out_white),\\n adjust_channel(pixel.b, composite_in_black, composite_in_white, composite_gamma, composite_out_black, composite_out_white)\\n );\\n\\n // Second Pass: individual Channels\\n pixel.rgb = vec3(\\n adjust_channel(pixel.r, red_in_black, red_in_white, red_gamma, red_out_black, red_out_white),\\n adjust_channel(pixel.g, green_in_black, green_in_white, green_gamma, green_out_black, green_out_white),\\n adjust_channel(pixel.b, blue_in_black, blue_in_white, blue_gamma, blue_out_black, blue_out_white)\\n );\\n\\n gl_FragColor.rgb = pixel.rgb * pixel.a;\\n gl_FragColor.a = pixel.a;\\n}') var lottie_player_42 = new PlaygroundPlayer( 42, 'playground_42_21', 'lottie_target_42', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 24, \"ef\": [{\"ty\": 7, \"v\": {\"nm\": \"00 Dropdown\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"01\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"02\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"08\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"09 slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"r_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"r_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"r_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"r_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"r_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"15 slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"16 slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"g_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"g_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"g_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"g_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"g_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"22\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"23\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"b_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"b_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"b_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"b_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"b_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"29\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"a_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"a_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"a_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"a_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"a_outwhite slider\", \"a\": 0, \"k\": 1}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { let shader = lottie_shader_42; lottie.layers[0].ef[0].ef[3].v.k = data[\"Composite In Black\"]; lottie.layers[0].ef[0].ef[4].v.k = data[\"Composite In White\"]; lottie.layers[0].ef[0].ef[5].v.k = data[\"Composite Gamma\"]; lottie.layers[0].ef[0].ef[6].v.k = data[\"Composite Out Black\"]; lottie.layers[0].ef[0].ef[7].v.k = data[\"Composite Out White\"]; lottie.layers[0].ef[0].ef[10].v.k = data[\"Red In Black\"]; lottie.layers[0].ef[0].ef[11].v.k = data[\"Red In White\"]; lottie.layers[0].ef[0].ef[12].v.k = data[\"Red Gamma\"]; lottie.layers[0].ef[0].ef[13].v.k = data[\"Red Out Black\"]; lottie.layers[0].ef[0].ef[14].v.k = data[\"Red Out White\"]; lottie.layers[0].ef[0].ef[17].v.k = data[\"Green In Black\"]; lottie.layers[0].ef[0].ef[18].v.k = data[\"Green In White\"]; lottie.layers[0].ef[0].ef[19].v.k = data[\"Green Gamma\"]; lottie.layers[0].ef[0].ef[20].v.k = data[\"Green Out Black\"]; lottie.layers[0].ef[0].ef[21].v.k = data[\"Green Out White\"]; lottie.layers[0].ef[0].ef[24].v.k = data[\"Blue In Black\"]; lottie.layers[0].ef[0].ef[25].v.k = data[\"Blue In White\"]; lottie.layers[0].ef[0].ef[26].v.k = data[\"Blue Gamma\"]; lottie.layers[0].ef[0].ef[27].v.k = data[\"Blue Out Black\"]; lottie.layers[0].ef[0].ef[28].v.k = data[\"Blue Out White\"]; shader.set_uniform(\"composite_in_black\", \"1f\", data[\"Composite In Black\"]); shader.set_uniform(\"composite_in_white\", \"1f\", data[\"Composite In White\"]); shader.set_uniform(\"composite_gamma\", \"1f\", data[\"Composite Gamma\"]); shader.set_uniform(\"composite_out_black\", \"1f\", data[\"Composite Out Black\"]); shader.set_uniform(\"composite_out_white\", \"1f\", data[\"Composite Out White\"]); shader.set_uniform(\"red_in_black\", \"1f\", data[\"Red In Black\"]); shader.set_uniform(\"red_in_white\", \"1f\", data[\"Red In White\"]); shader.set_uniform(\"red_gamma\", \"1f\", data[\"Red Gamma\"]); shader.set_uniform(\"red_out_black\", \"1f\", data[\"Red Out Black\"]); shader.set_uniform(\"red_out_white\", \"1f\", data[\"Red Out White\"]); shader.set_uniform(\"green_in_black\", \"1f\", data[\"Green In Black\"]); shader.set_uniform(\"green_in_white\", \"1f\", data[\"Green In White\"]); shader.set_uniform(\"green_gamma\", \"1f\", data[\"Green Gamma\"]); shader.set_uniform(\"green_out_black\", \"1f\", data[\"Green Out Black\"]); shader.set_uniform(\"green_out_white\", \"1f\", data[\"Green Out White\"]); shader.set_uniform(\"blue_in_black\", \"1f\", data[\"Blue In Black\"]); shader.set_uniform(\"blue_in_white\", \"1f\", data[\"Blue In White\"]); shader.set_uniform(\"blue_gamma\", \"1f\", data[\"Blue Gamma\"]); shader.set_uniform(\"blue_out_black\", \"1f\", data[\"Blue Out Black\"]); shader.set_uniform(\"blue_out_white\", \"1f\", data[\"Blue Out White\"]); this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} ); #version 100 precision highp float; uniform highp float composite_in_black; uniform highp float composite_in_white; uniform highp float composite_gamma; uniform highp float composite_out_black; uniform highp float composite_out_white; uniform highp float red_in_black; uniform highp float red_in_white; uniform highp float red_gamma; uniform highp float red_out_black; uniform highp float red_out_white; uniform highp float green_in_black; uniform highp float green_in_white; uniform highp float green_gamma; uniform highp float green_out_black; uniform highp float green_out_white; uniform highp float blue_in_black; uniform highp float blue_in_white; uniform highp float blue_gamma; uniform highp float blue_out_black; uniform highp float blue_out_white; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; float adjust_channel(float value, float in_black, float in_white, float gamma, float out_black, float out_white) { float in_delta = in_white - in_black; float out_delta = out_white - out_black; if ( in_delta == 0.0 ) return out_black; // Clamp to input range if ( value <= in_black && value <= in_white ) return out_black; if ( value >= in_black && value >= in_white ) return out_white; // Apply adjustment return out_black + out_delta * pow((value - in_black) / in_delta, 1.0 / gamma); } void main() { // Base pixel value highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); highp vec4 pixel = texture2D(texture_sampler, uv); // First Pass: composite pixel.rgb = vec3( adjust_channel(pixel.r, composite_in_black, composite_in_white, composite_gamma, composite_out_black, composite_out_white), adjust_channel(pixel.g, composite_in_black, composite_in_white, composite_gamma, composite_out_black, composite_out_white), adjust_channel(pixel.b, composite_in_black, composite_in_white, composite_gamma, composite_out_black, composite_out_white) ); // Second Pass: individual Channels pixel.rgb = vec3( adjust_channel(pixel.r, red_in_black, red_in_white, red_gamma, red_out_black, red_out_white), adjust_channel(pixel.g, green_in_black, green_in_white, green_gamma, green_out_black, green_out_white), adjust_channel(pixel.b, blue_in_black, blue_in_white, blue_gamma, blue_out_black, blue_out_white) ); gl_FragColor.rgb = pixel.rgb * pixel.a; gl_FragColor.a = pixel.a; } Matte3 Channel Red Green Blue Alpha Luma Hue Lightness Saturation Full Off Invert Stretch To Fit Show Mask Premultiply Mask var lottie_shader_43 = new SinglePassShader(document.getElementById('lottie_target_43_canvas')); lottie_shader_43.set_fragment('#version 100\\nprecision highp float;\\n\\nuniform int channel;\\nuniform int invert;\\nuniform int premultiply_mask;\\nuniform int show_mask;\\nuniform sampler2D mask_layer;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\nhighp vec3 hsl(vec4 c)\\n{\\n float maxc = max(c.r, max(c.g, c.b));\\n float minc = min(c.r, min(c.g, c.b));\\n float h = 0.0;\\n float s = 0.0;\\n float l = (maxc + minc) / 2.0;\\n\\n if ( maxc != minc)\\n {\\n float d = maxc - minc;\\n s = l > 0.5 ? d / (2.0 - d) : d / (maxc + minc);\\n if ( maxc == c.r )\\n h = (c.g - c.b) / d + (c.g < c.b ? 6.0 : 0.0);\\n else if ( maxc == c.g )\\n h = (c.b - c.r) / d + 2.0;\\n else if ( maxc == c.b )\\n h = (c.r - c.g) / d + 4.0;\\n\\n h /= 6.0;\\n }\\n\\n return vec3(h, s, l);\\n}\\n\\nhighp float opacity(vec4 pixel, int channel, int invert, int premultiply)\\n{\\n if ( premultiply == 1 )\\n pixel *= pixel.a;\\n\\n highp float opacity;\\n\\n if ( channel == 1 )\\n opacity = pixel.r;\\n else if ( channel == 2 )\\n opacity = pixel.g;\\n else if ( channel == 3 )\\n opacity = pixel.b;\\n else if ( channel == 4 )\\n opacity = pixel.a;\\n else if ( channel == 5 )\\n opacity = sqrt(pixel.r * pixel.r * 0.299 + pixel.g * pixel.g * 0.587 + pixel.b * pixel.b * 0.114);\\n else if ( channel == 6 )\\n opacity = hsl(pixel).x;\\n else if ( channel == 7 )\\n opacity = hsl(pixel).z;\\n else if ( channel == 8 )\\n opacity = hsl(pixel).y;\\n else if ( channel == 9 )\\n opacity = 1.0;\\n else if ( channel == 10 )\\n opacity = 0.0;\\n\\n\\n return invert == 1 ? 1.0 - opacity : opacity;\\n}\\n\\nvec4 alpha_blend(vec4 top, vec4 bottom)\\n{\\n float comp_alpha = bottom.a * (1.0 - top.a);\\n vec4 result;\\n result.a = top.a + comp_alpha;\\n result.rgb = (top.rgb * top.a + bottom.rgb * comp_alpha) / result.a;\\n return result;\\n}\\n\\nvoid main()\\n{\\n // Base pixel value\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n highp vec4 pixel = texture2D(texture_sampler, uv);\\n\\n highp vec4 mask = texture2D(mask_layer, uv);\\n\\n\\n gl_FragColor.a = pixel.a * opacity(mask, channel, invert, premultiply_mask);\\n gl_FragColor.rgb = pixel.rgb * gl_FragColor.a;\\n\\n if ( show_mask == 1 )\\n gl_FragColor = alpha_blend(gl_FragColor, mask);\\n}') var lottie_player_43 = new PlaygroundPlayer( 43, 'playground_43_6', 'lottie_target_43', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}, {\"id\": \"thumbs-up\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/thumbs-up.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {}, \"ip\": 0, \"op\": 60, \"st\": 0, \"ind\": 0, \"ef\": [{\"ty\": 28, \"nm\": \"Set Matte\", \"np\": 8, \"mn\": \"ADBE Set Matte3\", \"ix\": 1, \"en\": 1, \"ef\": [{\"ty\": 10, \"nm\": \"Take Matte From Layer\", \"mn\": \"ADBE Set Matte3-0001\", \"ix\": 1, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 1}}, {\"ty\": 7, \"nm\": \"Use For Matte\", \"mn\": \"ADBE Set Matte3-0002\", \"ix\": 2, \"v\": {\"a\": 0, \"k\": 4, \"ix\": 2}}, {\"ty\": 7, \"nm\": \"Invert Matte\", \"mn\": \"ADBE Set Matte3-0003\", \"ix\": 3, \"v\": {\"a\": 0, \"k\": 0, \"ix\": 3}}, {\"ty\": 7, \"nm\": \"If Layer Sizes Differ\", \"mn\": \"ADBE Set Matte3-0004\", \"ix\": 4, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 4}}, {\"ty\": 7, \"nm\": \"Composite Matte with Original\", \"mn\": \"ADBE Set Matte3-0005\", \"ix\": 5, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 5}}, {\"ty\": 7, \"nm\": \"Premultiply Matte Layer\", \"mn\": \"ADBE Set Matte3-0006\", \"ix\": 6, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 6}}]}], \"refId\": \"blep\"}, {\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {}, \"ip\": 0, \"op\": 60, \"st\": 0, \"ind\": 1, \"refId\": \"thumbs-up\"}]}, function (lottie, data) { let shader = lottie_shader_43; lottie.layers[0].ef[0].ef[1].v.k = Number(data[\"Channel\"]); lottie.layers[0].ef[0].ef[2].v.k = Number(data[\"Invert\"]); lottie.layers[0].ef[0].ef[3].v.k = Number(data[\"Stretch To Fit\"]); lottie.layers[0].ef[0].ef[4].v.k = Number(data[\"Show Mask\"]); lottie.layers[0].ef[0].ef[5].v.k = Number(data[\"Premultiply Mask\"]); shader.set_uniform(\"channel\", \"1i\", Number(data[\"Channel\"])); shader.set_uniform(\"invert\", \"1i\", Number(data[\"Invert\"])); shader.set_uniform(\"show_mask\", \"1i\", Number(data[\"Show Mask\"])); shader.set_uniform(\"premultiply_mask\", \"1i\", Number(data[\"Premultiply Mask\"])); shader.texture(\"/lottie-docs/examples/thumbs-up.png\").set_uniform(shader.program, \"mask_layer\"); this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} ); #version 100 precision highp float; uniform int channel; uniform int invert; uniform int premultiply_mask; uniform int show_mask; uniform sampler2D mask_layer; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; highp vec3 hsl(vec4 c) { float maxc = max(c.r, max(c.g, c.b)); float minc = min(c.r, min(c.g, c.b)); float h = 0.0; float s = 0.0; float l = (maxc + minc) / 2.0; if ( maxc != minc) { float d = maxc - minc; s = l > 0.5 ? d / (2.0 - d) : d / (maxc + minc); if ( maxc == c.r ) h = (c.g - c.b) / d + (c.g < c.b ? 6.0 : 0.0); else if ( maxc == c.g ) h = (c.b - c.r) / d + 2.0; else if ( maxc == c.b ) h = (c.r - c.g) / d + 4.0; h /= 6.0; } return vec3(h, s, l); } highp float opacity(vec4 pixel, int channel, int invert, int premultiply) { if ( premultiply == 1 ) pixel *= pixel.a; highp float opacity; if ( channel == 1 ) opacity = pixel.r; else if ( channel == 2 ) opacity = pixel.g; else if ( channel == 3 ) opacity = pixel.b; else if ( channel == 4 ) opacity = pixel.a; else if ( channel == 5 ) opacity = sqrt(pixel.r * pixel.r * 0.299 + pixel.g * pixel.g * 0.587 + pixel.b * pixel.b * 0.114); else if ( channel == 6 ) opacity = hsl(pixel).x; else if ( channel == 7 ) opacity = hsl(pixel).z; else if ( channel == 8 ) opacity = hsl(pixel).y; else if ( channel == 9 ) opacity = 1.0; else if ( channel == 10 ) opacity = 0.0; return invert == 1 ? 1.0 - opacity : opacity; } vec4 alpha_blend(vec4 top, vec4 bottom) { float comp_alpha = bottom.a * (1.0 - top.a); vec4 result; result.a = top.a + comp_alpha; result.rgb = (top.rgb * top.a + bottom.rgb * comp_alpha) / result.a; return result; } void main() { // Base pixel value highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); highp vec4 pixel = texture2D(texture_sampler, uv); highp vec4 mask = texture2D(mask_layer, uv); gl_FragColor.a = pixel.a * opacity(mask, channel, invert, premultiply_mask); gl_FragColor.rgb = pixel.rgb * gl_FragColor.a; if ( show_mask == 1 ) gl_FragColor = alpha_blend(gl_FragColor, mask); } Bulge Center X 286 Center Y 277 Radius X 197 Radius Y 179 Height 1.9 var lottie_shader_44 = new SinglePassShader(document.getElementById('lottie_target_44_canvas')); lottie_shader_44.set_fragment('#version 100\\n\\nprecision highp float;\\n\\nuniform vec2 center;\\nuniform vec2 radius;\\nuniform float height;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\nvec2 normalize_uv(vec2 coord)\\n{\\n return vec2(coord.x / canvas_size.x, coord.y / canvas_size.y);\\n}\\n\\nvec2 exponential_displacement(vec2 uv, float magnitude)\\n{\\n return uv * pow(dot(uv, uv), magnitude) - uv;\\n}\\n\\n\\nvec2 spherical_displacement(vec2 uv, float magnitude)\\n{\\n float radius = (1.0 + magnitude) / (2.0 * sqrt(magnitude));\\n\\n\\n float arc_ratio = asin(length(uv) / radius) / asin(1.0 / radius);\\n return normalize(uv) * arc_ratio - uv;\\n}\\n\\nvec2 displace(vec2 owo)\\n{\\n float t = dot(owo, owo);\\n if (t >= 1.0)\\n return owo;\\n\\n float magnitude = abs(height);\\n // We modify the magniture to more closely match AE\\n magnitude = (2.0/(1.0+exp(-3.0*magnitude))-1.0) * (0.23 * magnitude + 0.14);\\n // If the above is too expensive, you can use this instead:\\n // magnitude = magnitude * 0.275;\\n // Both of the above were derived by interpolating sample points\\n\\n float sign = height > 0.0 ? 1.0 : -1.0;\\n vec2 displacement =\\n exponential_displacement(owo, magnitude) +\\n spherical_displacement(owo, magnitude)\\n ;\\n return owo + displacement * magnitude * sign;\\n\\n}\\n\\nvoid main()\\n{\\n highp vec2 uv = normalize_uv(gl_FragCoord.xy);\\n vec2 norm_center = normalize_uv(center);\\n vec2 norm_radius = normalize_uv(radius);\\n\\n // forward transform\\n uv = (uv - norm_center) / norm_radius;\\n //displace\\n uv = displace(uv);\\n // backward transform\\n uv = uv * norm_radius + norm_center;\\n\\n gl_FragColor = texture2D(texture_sampler, uv);\\n}') var lottie_player_44 = new PlaygroundPlayer( 44, 'playground_44_6', 'lottie_target_44', {\"v\": \"5.9.0\", \"fr\": 60, \"ip\": 0, \"op\": 1800, \"w\": 512, \"h\": 512, \"nm\": \"Comp 1\", \"ddd\": 0, \"assets\": [{\"id\": \"image_0\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ind\": 1, \"ty\": 2, \"nm\": \"blep.png\", \"cl\": \"png\", \"refId\": \"image_0\", \"sr\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100, \"ix\": 11}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 10}, \"p\": {\"a\": 0, \"k\": [256, 256, 0], \"ix\": 2, \"l\": 2}, \"a\": {\"a\": 0, \"k\": [256, 256, 0], \"ix\": 1, \"l\": 2}, \"s\": {\"a\": 0, \"k\": [100, 100, 100], \"ix\": 6, \"l\": 2}}, \"ao\": 0, \"ef\": [{\"ty\": 5, \"nm\": \"Bulge\", \"np\": 9, \"mn\": \"ADBE Bulge\", \"ix\": 1, \"en\": 1, \"ef\": [{\"ty\": 0, \"nm\": \"Horizontal Radius\", \"mn\": \"ADBE Bulge-0001\", \"ix\": 1, \"v\": {\"a\": 0, \"k\": 197, \"ix\": 1}}, {\"ty\": 0, \"nm\": \"Vertical Radius\", \"mn\": \"ADBE Bulge-0002\", \"ix\": 2, \"v\": {\"a\": 0, \"k\": 179, \"ix\": 2}}, {\"ty\": 3, \"nm\": \"Bulge Center\", \"mn\": \"ADBE Bulge-0003\", \"ix\": 3, \"v\": {\"a\": 0, \"k\": [286, 277], \"ix\": 3}}, {\"ty\": 0, \"nm\": \"Bulge Height\", \"mn\": \"ADBE Bulge-0004\", \"ix\": 4, \"v\": {\"a\": 0, \"k\": 1.85, \"ix\": 4}}, {\"ty\": 0, \"nm\": \"Taper Radius\", \"mn\": \"ADBE Bulge-0005\", \"ix\": 5, \"v\": {\"a\": 0, \"k\": 0, \"ix\": 5}}, {\"ty\": 7, \"nm\": \"Antialiasing (Best Qual Only)\", \"mn\": \"ADBE Bulge-0006\", \"ix\": 6, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 6}}, {\"ty\": 7, \"nm\": \"Pinning\", \"mn\": \"ADBE Bulge-0007\", \"ix\": 7, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 7}}]}], \"ip\": 0, \"op\": 1800, \"st\": 0, \"bm\": 0}], \"markers\": []}, function (lottie, data) { let shader = lottie_shader_44; lottie.layers[0].ef[0].ef[0].v.k = data[\"Radius X\"]; lottie.layers[0].ef[0].ef[1].v.k = data[\"Radius Y\"]; lottie.layers[0].ef[0].ef[2].v.k = [data[\"Center X\"], data[\"Center Y\"]]; lottie.layers[0].ef[0].ef[3].v.k = data[\"Height\"]; shader.set_uniform(\"center\", \"2fv\", [data[\"Center X\"] * 0.77, data[\"Center Y\"] * 0.77]); shader.set_uniform(\"radius\", \"2fv\", [data[\"Radius X\"] * 0.77, data[\"Radius Y\"] * 0.77]); shader.set_uniform(\"height\", \"1f\", data[\"Height\"]); this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} ); #version 100 precision highp float; uniform vec2 center; uniform vec2 radius; uniform float height; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; vec2 normalize_uv(vec2 coord) { return vec2(coord.x / canvas_size.x, coord.y / canvas_size.y); } vec2 exponential_displacement(vec2 uv, float magnitude) { return uv * pow(dot(uv, uv), magnitude) - uv; } vec2 spherical_displacement(vec2 uv, float magnitude) { float radius = (1.0 + magnitude) / (2.0 * sqrt(magnitude)); float arc_ratio = asin(length(uv) / radius) / asin(1.0 / radius); return normalize(uv) * arc_ratio - uv; } vec2 displace(vec2 owo) { float t = dot(owo, owo); if (t >= 1.0) return owo; float magnitude = abs(height); // We modify the magniture to more closely match AE magnitude = (2.0/(1.0+exp(-3.0*magnitude))-1.0) * (0.23 * magnitude + 0.14); // If the above is too expensive, you can use this instead: // magnitude = magnitude * 0.275; // Both of the above were derived by interpolating sample points float sign = height > 0.0 ? 1.0 : -1.0; vec2 displacement = exponential_displacement(owo, magnitude) + spherical_displacement(owo, magnitude) ; return owo + displacement * magnitude * sign; } void main() { highp vec2 uv = normalize_uv(gl_FragCoord.xy); vec2 norm_center = normalize_uv(center); vec2 norm_radius = normalize_uv(radius); // forward transform uv = (uv - norm_center) / norm_radius; //displace uv = displace(uv); // backward transform uv = uv * norm_radius + norm_center; gl_FragColor = texture2D(texture_sampler, uv); } Wave Warp This effect is animated by default, so it has a \"time\" slider (in seconds). Shape Sine Square Triangle Sawtooth Circle Semicircle Uncircle Noise Smooth noise Amplitude 10 Wavelength 40 Direction 90 Phase 0 Speed 1 Time 0 var lottie_shader_45 = new SinglePassShader(document.getElementById('lottie_target_45_canvas')); lottie_shader_45.set_fragment('#version 100\\n\\n#define PI 3.1415926538\\n#define TAU 6.283185307\\n\\nprecision highp float;\\n\\nuniform int shape;\\nuniform float amplitude;\\nuniform float wavelength;\\nuniform float angle;\\nuniform float speed;\\nuniform float phase;\\nuniform float time;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\n\\nvec2 normalize_uv(vec2 coord)\\n{\\n return vec2(coord.x / canvas_size.x, coord.y / canvas_size.y);\\n}\\n\\nfloat clamp_angle(float angle)\\n{\\n return mod(angle, TAU);\\n}\\n\\nvec2 project(vec2 a , vec2 b)\\n{\\n return dot(a, b) / dot(b, b) * b;\\n}\\n\\nfloat semicircle(float x)\\n{\\n return sqrt(1.0 - pow(clamp_angle(x) / PI - 1.0, 2.0));\\n}\\n\\n// Adapted from http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\\nhighp float noise(float x)\\n{\\n highp float a = 12.9898;\\n highp float b = 78.233;\\n highp float c = 43758.5453;\\n highp float dt = x * a;\\n highp float sn = mod(dt, PI);\\n return fract(sin(sn) * c) * 2.0 - 1.0;\\n}\\n\\n// Interpolate between two random points\\nfloat smooth_noise(float x)\\n{\\n float x_fract = fract(x);\\n float x_int = x - x_fract;\\n float n1 = noise(x_int);\\n float n2 = noise(x_int + 1.0);\\n return (n1 * (1.0 - x_fract) + n2 * x_fract);\\n}\\n\\nvec2 displace(vec2 uv)\\n{\\n float rad = angle / 180.0 * PI;\\n vec2 normal = vec2(cos(rad), sin(rad));\\n rad -= PI /2.0;\\n vec2 direction = vec2(cos(rad), sin(rad));\\n float x = length(project(uv, direction));\\n\\n x = x / wavelength * PI - time * speed * TAU + phase / 180.0 * PI;\\n\\n\\n float y;\\n\\n if ( shape == 1 ) // sine\\n y = sin(x);\\n else if ( shape == 2 ) // square\\n y = clamp_angle(x) < PI ? 1.0 : -1.0;\\n else if ( shape == 3 ) // triangle\\n y = 1.0 - abs(clamp_angle(x) - PI) / PI * 2.0;\\n else if ( shape == 4 ) // sawtooth\\n y = 1.0 - clamp_angle(x) / PI;\\n else if ( shape == 5 ) // circle\\n y = sign(clamp_angle(x) - PI) * semicircle(2.0 * x);\\n else if ( shape == 6 ) // semi circle\\n y = 2.0 * semicircle(x) - 1.0;\\n else if ( shape == 7 ) // uncircle\\n y = sign(clamp_angle(-x) - PI) * (semicircle(2.0 * x) - 1.0);\\n else if ( shape == 8 ) // noise\\n y = noise(x);\\n else if ( shape == 9 ) // smooth noise\\n y = smooth_noise(x * 4.0) ;\\n\\n return uv + y * normal * amplitude;\\n\\n}\\n\\nvoid main()\\n{\\n vec2 uv = displace(gl_FragCoord.xy);\\n gl_FragColor = texture2D(texture_sampler, normalize_uv(uv));\\n}') var lottie_player_45 = new PlaygroundPlayer( 45, 'playground_45_8', 'lottie_target_45', {\"v\": \"5.9.0\", \"fr\": 60, \"ip\": 0, \"op\": 1800, \"w\": 512, \"h\": 512, \"nm\": \"Comp 1\", \"ddd\": 0, \"assets\": [{\"id\": \"image_0\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ind\": 1, \"ty\": 2, \"nm\": \"blep.png\", \"cl\": \"png\", \"refId\": \"image_0\", \"sr\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100, \"ix\": 11}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 10}, \"p\": {\"a\": 0, \"k\": [256, 256, 0], \"ix\": 2, \"l\": 2}, \"a\": {\"a\": 0, \"k\": [256, 256, 0], \"ix\": 1, \"l\": 2}, \"s\": {\"a\": 0, \"k\": [100, 100, 100], \"ix\": 6, \"l\": 2}}, \"ao\": 0, \"ef\": [{\"ty\": 5, \"nm\": \"Wave Warp\", \"np\": 10, \"mn\": \"ADBE Wave Warp\", \"ix\": 1, \"en\": 1, \"ef\": [{\"ty\": 7, \"nm\": \"Wave Type\", \"mn\": \"ADBE Wave Warp-0001\", \"ix\": 1, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 1}}, {\"ty\": 0, \"nm\": \"Wave Height\", \"mn\": \"ADBE Wave Warp-0002\", \"ix\": 2, \"v\": {\"a\": 0, \"k\": 10, \"ix\": 2}}, {\"ty\": 0, \"nm\": \"Wave Width\", \"mn\": \"ADBE Wave Warp-0003\", \"ix\": 3, \"v\": {\"a\": 0, \"k\": 64, \"ix\": 3}}, {\"ty\": 0, \"nm\": \"Direction\", \"mn\": \"ADBE Wave Warp-0004\", \"ix\": 4, \"v\": {\"a\": 0, \"k\": 90, \"ix\": 4}}, {\"ty\": 7, \"nm\": \"Wave Speed\", \"mn\": \"ADBE Wave Warp-0005\", \"ix\": 5, \"v\": {\"a\": 0, \"k\": 2, \"ix\": 5}}, {\"ty\": 7, \"nm\": \"Pinning\", \"mn\": \"ADBE Wave Warp-0006\", \"ix\": 6, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 6}}, {\"ty\": 0, \"nm\": \"Phase\", \"mn\": \"ADBE Wave Warp-0007\", \"ix\": 7, \"v\": {\"a\": 0, \"k\": 0, \"ix\": 7}}, {\"ty\": 7, \"nm\": \"Antialiasing (Best Quality)\", \"mn\": \"ADBE Wave Warp-0008\", \"ix\": 8, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 8}}]}], \"ip\": 0, \"op\": 1800, \"st\": 0, \"bm\": 0}], \"markers\": []}, function (lottie, data) { let shader = lottie_shader_45; lottie.layers[0].ef[0].ef[0].v.k = Number(data[\"Shape\"]); lottie.layers[0].ef[0].ef[1].v.k = data[\"Amplitude\"]; lottie.layers[0].ef[0].ef[2].v.k = data[\"Wavelength\"]; lottie.layers[0].ef[0].ef[3].v.k = data[\"Direction\"]; lottie.layers[0].ef[0].ef[5].v.k = data[\"Speed\"]; // 5 \"pinning\" not implemented lottie.layers[0].ef[0].ef[6].v.k = data[\"Phase\"]; // & \"antialiasing\" unused shader.set_uniform(\"shape\", \"1i\", Number(data[\"Shape\"])); shader.set_uniform(\"amplitude\", \"1f\", data[\"Amplitude\"]); shader.set_uniform(\"wavelength\", \"1f\", data[\"Wavelength\"]); shader.set_uniform(\"angle\", \"1f\", data[\"Direction\"]); shader.set_uniform(\"phase\", \"1f\", data[\"Phase\"]); shader.set_uniform(\"speed\", \"1f\", data[\"Speed\"]); shader.set_uniform(\"time\", \"1f\", data[\"Time\"]); this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} ); #version 100 #define PI 3.1415926538 #define TAU 6.283185307 precision highp float; uniform int shape; uniform float amplitude; uniform float wavelength; uniform float angle; uniform float speed; uniform float phase; uniform float time; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; vec2 normalize_uv(vec2 coord) { return vec2(coord.x / canvas_size.x, coord.y / canvas_size.y); } float clamp_angle(float angle) { return mod(angle, TAU); } vec2 project(vec2 a , vec2 b) { return dot(a, b) / dot(b, b) * b; } float semicircle(float x) { return sqrt(1.0 - pow(clamp_angle(x) / PI - 1.0, 2.0)); } // Adapted from http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/ highp float noise(float x) { highp float a = 12.9898; highp float b = 78.233; highp float c = 43758.5453; highp float dt = x * a; highp float sn = mod(dt, PI); return fract(sin(sn) * c) * 2.0 - 1.0; } // Interpolate between two random points float smooth_noise(float x) { float x_fract = fract(x); float x_int = x - x_fract; float n1 = noise(x_int); float n2 = noise(x_int + 1.0); return (n1 * (1.0 - x_fract) + n2 * x_fract); } vec2 displace(vec2 uv) { float rad = angle / 180.0 * PI; vec2 normal = vec2(cos(rad), sin(rad)); rad -= PI /2.0; vec2 direction = vec2(cos(rad), sin(rad)); float x = length(project(uv, direction)); x = x / wavelength * PI - time * speed * TAU + phase / 180.0 * PI; float y; if ( shape == 1 ) // sine y = sin(x); else if ( shape == 2 ) // square y = clamp_angle(x) < PI ? 1.0 : -1.0; else if ( shape == 3 ) // triangle y = 1.0 - abs(clamp_angle(x) - PI) / PI * 2.0; else if ( shape == 4 ) // sawtooth y = 1.0 - clamp_angle(x) / PI; else if ( shape == 5 ) // circle y = sign(clamp_angle(x) - PI) * semicircle(2.0 * x); else if ( shape == 6 ) // semi circle y = 2.0 * semicircle(x) - 1.0; else if ( shape == 7 ) // uncircle y = sign(clamp_angle(-x) - PI) * (semicircle(2.0 * x) - 1.0); else if ( shape == 8 ) // noise y = noise(x); else if ( shape == 9 ) // smooth noise y = smooth_noise(x * 4.0) ; return uv + y * normal * amplitude; } void main() { vec2 uv = displace(gl_FragCoord.xy); gl_FragColor = texture2D(texture_sampler, normalize_uv(uv)); }","title":"Tips for rendering"},{"location":"rendering/#tips-for-rendering","text":".json-parent:not([hidden]) { display: flex; } .json-parent > pre { width: 50%; } .json-parent > pre > code { height: 100%; } let converter_map = {}; function convert_shape(shape) { let lottie_bez = { \"c\": true, \"v\": [ [ 256, 96 ], [ 408.1690426072246, 206.5572809000084 ], [ 350.04564036679574, 385.44271909999156 ], [ 161.95435963320432, 385.44271909999156 ], [ 103.83095739277542, 206.55728090000844 ] ], \"i\": [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ], \"o\": [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ] }; if ( shape.sy == 1 ) lottie_bez = { \"c\": true, \"v\": [ [ 250.84172204836955, 33.33731381001252 ], [ 319.3523543268615, 164.41507157596521 ], [ 466.1708030880071, 182.28763209535816 ], [ 362.679397092767, 287.9503700935611 ], [ 391.05097770288023, 433.10593743368196 ], [ 258.5791389758152, 367.3313430949937 ], [ 129.2952913462771, 439.16985684806957 ], [ 150.91459845599647, 292.8561839523209 ], [ 42.641205814466105, 192.09925981287776 ], [ 188.47451114855988, 167.44703128315905 ] ], \"i\": [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ], \"o\": [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ] }; return Bezier.from_lottie(lottie_bez); // return converter_map[shape.ty](shape); }","title":"Tips for rendering"},{"location":"rendering/#introduction","text":"This page will give tips and example code on how to render certain objects within lottie. Lottie has several implementations and some things might vary from player to player, this guide tries to follow the behaviour of lottie web which is the reference implementation. For shapes, it ensures the stroke order is the same as in lottie web, which is crucial for Trim Path to work correctly. All shapes have the d attribute that if has the value 3 the path should be reversed.","title":"Introduction"},{"location":"rendering/#code","text":"The code examples take some shortcuts for readablility: all animated properties are shown as static, of course you'd need to get the correct values to render shapes at a given frame. When adding points to a bezier, there are calls to bezier.add_vertex() . Assume the in/out tangents are [0, 0] if not specified. When they are specified they show as set_out_tangent immediately following the corresponding add_vertex . Bezier tangents are assumed to be relative to their vertex since that's how lottie works but it might be useful to keep them as absolute points when rendering. All the examples show the original on the left and the bezier on the right. Explanation for bezier operations is outside the scope of this guide, the code below use a simple bezier library for some operations, you can check its sources for some context on what the various functions do.","title":"Code"},{"location":"rendering/#rectangle","text":"See Rectangle . Note that unlike other shapes, on lottie web when the d attribute is missing, the rectangle defaults as being reversed. Python C++ TypeScript def rectangle(shape: Bezier, p: Vector2D, s: Vector2D, r: float): left: float = p.x - s.x / 2 right: float = p.x + s.x / 2 top: float = p.y - s.y / 2 bottom: float = p.y + s.y / 2 shape.closed = True if r <= 0: # The rectangle is rendered from the top-right going clockwise shape.add_vertex(Vector2D(right, top)) shape.add_vertex(Vector2D(right, bottom)) shape.add_vertex(Vector2D(left, bottom)) shape.add_vertex(Vector2D(left, top)) else: # Rounded corners must be taken into account rounded: float = min(s.x/2, s.y/2, r) tangent: float = rounded * ELLIPSE_CONSTANT shape.add_vertex(Vector2D(right, top + rounded)) shape.set_in_tangent(Vector2D(0, -tangent)) shape.add_vertex(Vector2D(right, bottom - rounded)) shape.set_out_tangent(Vector2D(0, tangent)) shape.add_vertex(Vector2D(right - rounded, bottom)) shape.set_in_tangent(Vector2D(tangent, 0)) shape.add_vertex(Vector2D(left + rounded, bottom)) shape.set_out_tangent(Vector2D(-tangent, 0)) shape.add_vertex(Vector2D(left, bottom - rounded)) shape.set_in_tangent(Vector2D(0, tangent)) shape.add_vertex(Vector2D(left, top + rounded)) shape.set_out_tangent(Vector2D(0, -tangent)) shape.add_vertex(Vector2D(left + rounded, top)) shape.set_in_tangent(Vector2D(-tangent, 0)) shape.add_vertex(Vector2D(right - rounded, top)) shape.set_out_tangent(Vector2D(tangent, 0)) void rectangle(Bezier shape, Vector2D p, Vector2D s, float r) { float left = p.x - s.x / 2; float right = p.x + s.x / 2; float top = p.y - s.y / 2; float bottom = p.y + s.y / 2; shape.closed = true; if ( r <= 0 ) { // The rectangle is rendered from the top-right going clockwise shape.add_vertex(Vector2D(right, top)); shape.add_vertex(Vector2D(right, bottom)); shape.add_vertex(Vector2D(left, bottom)); shape.add_vertex(Vector2D(left, top)); } // Rounded corners must be taken into account else { float rounded = std::min(s.x / 2, s.y / 2, r); float tangent = rounded * ELLIPSE_CONSTANT; shape.add_vertex(Vector2D(right, top + rounded)); shape.set_in_tangent(Vector2D(0, -tangent)); shape.add_vertex(Vector2D(right, bottom - rounded)); shape.set_out_tangent(Vector2D(0, tangent)); shape.add_vertex(Vector2D(right - rounded, bottom)); shape.set_in_tangent(Vector2D(tangent, 0)); shape.add_vertex(Vector2D(left + rounded, bottom)); shape.set_out_tangent(Vector2D(-tangent, 0)); shape.add_vertex(Vector2D(left, bottom - rounded)); shape.set_in_tangent(Vector2D(0, tangent)); shape.add_vertex(Vector2D(left, top + rounded)); shape.set_out_tangent(Vector2D(0, -tangent)); shape.add_vertex(Vector2D(left + rounded, top)); shape.set_in_tangent(Vector2D(-tangent, 0)); shape.add_vertex(Vector2D(right - rounded, top)); shape.set_out_tangent(Vector2D(tangent, 0)); } } function rectangle(shape: Bezier, p: Vector2D, s: Vector2D, r: number) { let left: number = p.x - s.x / 2; let right: number = p.x + s.x / 2; let top: number = p.y - s.y / 2; let bottom: number = p.y + s.y / 2; shape.closed = true; if ( r <= 0 ) { // The rectangle is rendered from the top-right going clockwise shape.addVertex(new Vector2D(right, top)); shape.addVertex(new Vector2D(right, bottom)); shape.addVertex(new Vector2D(left, bottom)); shape.addVertex(new Vector2D(left, top)); } else { // Rounded corners must be taken into account let rounded: number = Math.min(s.x / 2, s.y / 2, r); let tangent: number = rounded * ELLIPSE_CONSTANT; shape.addVertex(new Vector2D(right, top + rounded)); shape.setInTangent(new Vector2D(0, -tangent)); shape.addVertex(new Vector2D(right, bottom - rounded)); shape.setOutTangent(new Vector2D(0, tangent)); shape.addVertex(new Vector2D(right - rounded, bottom)); shape.setInTangent(new Vector2D(tangent, 0)); shape.addVertex(new Vector2D(left + rounded, bottom)); shape.setOutTangent(new Vector2D(-tangent, 0)); shape.addVertex(new Vector2D(left, bottom - rounded)); shape.setInTangent(new Vector2D(0, tangent)); shape.addVertex(new Vector2D(left, top + rounded)); shape.setOutTangent(new Vector2D(0, -tangent)); shape.addVertex(new Vector2D(left + rounded, top)); shape.setInTangent(new Vector2D(-tangent, 0)); shape.addVertex(new Vector2D(right - rounded, top)); shape.setOutTangent(new Vector2D(tangent, 0)); } }","title":"Rectangle"},{"location":"rendering/#ellipse","text":"See Ellipse . The stroke direction should start at the top. If you think of the ellipse as a clock, start at 12 go clockwise. The magic number 0.5519 is what lottie uses for this, based on this article . Python C++ TypeScript def ellipse(shape: Bezier, p: Vector2D, s: Vector2D): # An ellipse is drawn from the top quandrant point going clockwise: radius = s / 2 tangent = radius * ELLIPSE_CONSTANT x = p.x y = p.y shape.closed = True shape.add_vertex(Vector2D(x, y - radius.y)) shape.set_in_tangent(Vector2D(-tangent.x, 0)) shape.set_out_tangent(Vector2D(tangent.x, 0)) shape.add_vertex(Vector2D(x + radius.x, y)) shape.set_in_tangent(Vector2D(0, -tangent.y)) shape.set_out_tangent(Vector2D(0, tangent.y)) shape.add_vertex(Vector2D(x, y + radius.y)) shape.set_in_tangent(Vector2D(tangent.x, 0)) shape.set_out_tangent(Vector2D(-tangent.x, 0)) shape.add_vertex(Vector2D(x - radius.x, y)) shape.set_in_tangent(Vector2D(0, tangent.y)) shape.set_out_tangent(Vector2D(0, -tangent.y)) void ellipse(Bezier shape, Vector2D p, Vector2D s) { // An ellipse is drawn from the top quandrant point going clockwise: radius = s / 2; tangent = radius * ELLIPSE_CONSTANT; x = p.x; y = p.y; shape.closed = true; shape.add_vertex(Vector2D(x, y - radius.y)); shape.set_in_tangent(Vector2D(-tangent.x, 0)); shape.set_out_tangent(Vector2D(tangent.x, 0)); shape.add_vertex(Vector2D(x + radius.x, y)); shape.set_in_tangent(Vector2D(0, -tangent.y)); shape.set_out_tangent(Vector2D(0, tangent.y)); shape.add_vertex(Vector2D(x, y + radius.y)); shape.set_in_tangent(Vector2D(tangent.x, 0)); shape.set_out_tangent(Vector2D(-tangent.x, 0)); shape.add_vertex(Vector2D(x - radius.x, y)); shape.set_in_tangent(Vector2D(0, tangent.y)); shape.set_out_tangent(Vector2D(0, -tangent.y)); } function ellipse(shape: Bezier, p: Vector2D, s: Vector2D) { // An ellipse is drawn from the top quandrant point going clockwise: radius = s / 2; tangent = radius * ELLIPSE_CONSTANT; x = p.x; y = p.y; shape.closed = true; shape.addVertex(new Vector2D(x, y - radius.y)); shape.setInTangent(new Vector2D(-tangent.x, 0)); shape.setOutTangent(new Vector2D(tangent.x, 0)); shape.addVertex(new Vector2D(x + radius.x, y)); shape.setInTangent(new Vector2D(0, -tangent.y)); shape.setOutTangent(new Vector2D(0, tangent.y)); shape.addVertex(new Vector2D(x, y + radius.y)); shape.setInTangent(new Vector2D(tangent.x, 0)); shape.setOutTangent(new Vector2D(-tangent.x, 0)); shape.addVertex(new Vector2D(x - radius.x, y)); shape.setInTangent(new Vector2D(0, tangent.y)); shape.setOutTangent(new Vector2D(0, -tangent.y)); }","title":"Ellipse"},{"location":"rendering/#polystar","text":"Pseudocode for rendering a PolyStar . Python C++ TypeScript def polystar(shape: Bezier, p: Vector2D, pt: float, r: float, or_: float, os: float, sy: int, ir: float, is_: float): points: int = int(round(pt)) alpha: float = -r * math.pi / 180 - math.pi / 2 theta: float = -math.pi / points tan_len_out: float = (2 * math.pi * or_) / (4 * points) * (os / 100) tan_len_in: float = (2 * math.pi * ir) / (4 * points) * (is_ / 100) shape.closed = True for i in range(points): beta: float = alpha + i * theta * 2 v_out: Vector2D = Vector2D(or_ * math.cos(beta), or_ * math.sin(beta)) shape.add_vertex(p + v_out) if os != 0 and or_ != 0: # We need to add bezier tangents tan_out: Vector2D = v_out * tan_len_out / or_ shape.set_in_tangent(Vector2D(-tan_out.y, tan_out.x)) shape.set_out_tangent(Vector2D(tan_out.y, -tan_out.x)) if sy == 1: # We need to add a vertex towards the inner radius to make a star v_in: Vector2D = Vector2D(ir * math.cos(beta + theta), ir * math.sin(beta + theta)) shape.add_vertex(p + v_in) if is_ != 0 and ir != 0: # We need to add bezier tangents tan_in = v_in * tan_len_in / ir shape.set_in_tangent(Vector2D(-tan_in.y, tan_in.x)) shape.set_out_tangent(Vector2D(tan_in.y, -tan_in.x)) void polystar(Bezier shape, Vector2D p, float pt, float r, float or_, float os, int sy, float ir, float is) { int points = std::round(pt); float alpha = -r * std::numbers::pi / 180 - std::numbers::pi / 2; float theta = -std::numbers::pi / points; float tan_len_out = 2 * std::numbers::pi * or_ / 4 * points * os / 100; float tan_len_in = 2 * std::numbers::pi * ir / 4 * points * is / 100; shape.closed = true; for ( int i = 0; i < points; i++ ) { float beta = alpha + i * theta * 2; Vector2D v_out(or_ * std::cos(beta), or_ * std::sin(beta)); shape.add_vertex(p + v_out); if ( os != 0 && or_ != 0 ) { // We need to add bezier tangents Vector2D tan_out = v_out * tan_len_out / or_; shape.set_in_tangent(Vector2D(-tan_out.y, tan_out.x)); shape.set_out_tangent(Vector2D(tan_out.y, -tan_out.x)); } if ( sy == 1 ) { // We need to add a vertex towards the inner radius to make a star Vector2D v_in(ir * std::cos(beta + theta), ir * std::sin(beta + theta)); shape.add_vertex(p + v_in); if ( is != 0 && ir != 0 ) { // We need to add bezier tangents tan_in = v_in * tan_len_in / ir; shape.set_in_tangent(Vector2D(-tan_in.y, tan_in.x)); shape.set_out_tangent(Vector2D(tan_in.y, -tan_in.x)); } } } } function polystar(shape: Bezier, p: Vector2D, pt: number, r: number, or: number, os: number, sy: number, ir: number, is: number) { let points: number = new Number(round(pt)); let alpha: number = -r * Math.PI / 180 - Math.PI / 2; let theta: number = -Math.PI / points; let tanLenOut: number = 2 * Math.PI * or / 4 * points * os / 100; let tanLenIn: number = 2 * Math.PI * ir / 4 * points * is / 100; shape.closed = true; for ( let i: number = 0; i < points; i++ ) { let beta: number = alpha + i * theta * 2; let vOut: Vector2D = new Vector2D(or * Math.cos(beta), or * Math.sin(beta)); shape.addVertex(p + vOut); if ( os != 0 && or != 0 ) { // We need to add bezier tangents let tanOut: Vector2D = vOut * tanLenOut / or; shape.setInTangent(new Vector2D(-tanOut.y, tanOut.x)); shape.setOutTangent(new Vector2D(tanOut.y, -tanOut.x)); } if ( sy == 1 ) { // We need to add a vertex towards the inner radius to make a star let vIn: Vector2D = new Vector2D(ir * Math.cos(beta + theta), ir * Math.sin(beta + theta)); shape.addVertex(p + vIn); if ( is != 0 && ir != 0 ) { // We need to add bezier tangents tanIn = vIn * tanLenIn / ir; shape.setInTangent(new Vector2D(-tanIn.y, tanIn.x)); shape.setOutTangent(new Vector2D(tanIn.y, -tanIn.x)); } } } }","title":"PolyStar"},{"location":"rendering/#pucker-bloat","text":"See Pucker / Bloat . Amount 50 function pucker_bloat( // Beziers as collected from the other shapes collected_shapes, // \"a\" property from the Pucker/Bloat modifier amount ) { // Normalize to [0, 1] amount /= 100; // Find the mean of the bezier vertices let center = new Point(0, 0); let number_of_vertices = 0; for ( let input_bezier of collected_shapes ) { for ( let point of input_bezier.points ) { center.x += point.pos.x; center.y += point.pos.y; number_of_vertices += 1; } } center.x /= number_of_vertices; center.y /= number_of_vertices; let result = []; for ( let input_bezier of collected_shapes ) { let output_bezier = new Bezier(); for ( let point of input_bezier.points ) { // Here we convert tangents to global coordinates let vertex = lerp(point.pos, center, amount); let in_tangent = lerp(point.in_tangent.add(point.pos), center, -amount).sub(vertex); let out_tangent = lerp(point.out_tangent.add(point.pos), center, -amount).sub(vertex); output_bezier.add_vertex(vertex) .set_in_tangent(in_tangent) .set_out_tangent(out_tangent); } output_bezier.closed = input_bezier.closed; result.push(output_bezier); } return result; } var lottie_player_46_bezier = new LottiePlayer('lottie_target_46_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_46 = new PlaygroundPlayer( 46, 'playground_46_2', 'lottie_target_46', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 160}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 2, \"os\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"pb\", \"nm\": \"Inflate and Deflate\", \"mn\": \"{b4af429a-546e-4728-a869-711a404c55ae}\", \"a\": {\"a\": 0, \"k\": 50}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"hd\": true, \"nm\": \"Fill\", \"mn\": \"{a1bcc159-6916-4718-841d-a99140c0e74b}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let bezier_lottie = lottie_player_46_bezier.lottie; lottie.layers[0].shapes[0].it[1].a.k = data[\"Amount\"]; let star = lottie.layers[0].shapes[0].it[0]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; let modifier = lottie.layers[0].shapes[0].it[1]; let bez_result = pucker_bloat([convert_shape(star)], modifier.a.k); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_46_bezier.reload(); this.set_json('playground_46_2_bezier', out_shapes[0].ks.k); }, {} ); function pucker_bloat( // Beziers as collected from the other shapes collected_shapes, // \"a\" property from the Pucker/Bloat modifier amount ) { // Normalize to [0, 1] amount /= 100; // Find the mean of the bezier vertices let center = new Point(0, 0); let number_of_vertices = 0; for ( let input_bezier of collected_shapes ) { for ( let point of input_bezier.points ) { center.x += point.pos.x; center.y += point.pos.y; number_of_vertices += 1; } } center.x /= number_of_vertices; center.y /= number_of_vertices; let result = []; for ( let input_bezier of collected_shapes ) { let output_bezier = new Bezier(); for ( let point of input_bezier.points ) { // Here we convert tangents to global coordinates let vertex = lerp(point.pos, center, amount); let in_tangent = lerp(point.in_tangent.add(point.pos), center, -amount).sub(vertex); let out_tangent = lerp(point.out_tangent.add(point.pos), center, -amount).sub(vertex); output_bezier.add_vertex(vertex) .set_in_tangent(in_tangent) .set_out_tangent(out_tangent); } output_bezier.closed = input_bezier.closed; result.push(output_bezier); } return result; } // Example invocation pucker_bloat([convert_shape(star)], modifier.a.k);","title":"Pucker Bloat"},{"location":"rendering/#rounded-corners","text":"See Rounded Corners . It approximates rounding using circular arcs. The magic number 0.5519 is what lottie uses for this, based on this article . Radius 50 // Helper function to perform rounding on a single vertex function get_vertex_tangent( // Bezier to round bezier, // Vertex in the bezier we are rounding current_vertex, // Index of the next point along the curve closest_index, // Rounding radius round_distance ) { const tangent_length = 0.5519; // closest_index module bezier.length closest_index = closest_index % bezier.points.length; if ( closest_index < 0 ) closest_index += bezier.points.length; let closest_vertex = bezier.points[closest_index].pos; let distance = current_vertex.distance(closest_vertex); let new_pos_perc = distance != 0 ? Math.min(distance/2, round_distance) / distance : 0; let vertex = closest_vertex.sub(current_vertex).mul(new_pos_perc).add(current_vertex); let tangent = vertex.sub(current_vertex).neg().mul(tangent_length); return [vertex, tangent]; } // Rounding for a single continuos curve function round_bezier_corners( // Bezier to round original, // Rounding radius round_distance ) { let result = new Bezier() result.closed = original.closed; for ( let i = 0; i < original.points.length; i++ ) { let point = original.points[i]; // Start and end of a non-closed path don't get rounded if ( !original.closed && (i == 0 || i == original.points.length - 1) ) { result.add_vertex(point.pos) .set_in_tangent(point.in_tangent) .set_out_tangent(point.out_tangent); } else { let [vert1, out_t] = get_vertex_tangent(original, point.pos, i - 1, round_distance); result.add_vertex(vert1) .set_out_tangent(out_t); let [vert2, in_t] = get_vertex_tangent(original, point.pos, i + 1, round_distance); result.add_vertex(vert2) .set_in_tangent(in_t); } } return result; } // Rounding on multiple bezier function round_corners( // Beziers as collected from the other shapes collected_shapes, // \"r\" property from lottie r ) { let result = [] for ( let input_bezier of collected_shapes ) result.push(round_bezier_corners(input_bezier, r)); return result; } var lottie_player_47_bezier = new LottiePlayer('lottie_target_47_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_47 = new PlaygroundPlayer( 47, 'playground_47_2', 'lottie_target_47', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 222.72242736816406}, \"ir\": {\"a\": 0, \"k\": 111.36121368408203}, \"r\": {\"a\": 0, \"k\": 358.67291259765625}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"rd\", \"nm\": \"Rounded Corners\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"r\": {\"a\": 0, \"k\": 50}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"hd\": true, \"nm\": \"Fill\", \"mn\": \"{a1bcc159-6916-4718-841d-a99140c0e74b}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let bezier_lottie = lottie_player_47_bezier.lottie; lottie.layers[0].shapes[0].it[1].r.k = data[\"Radius\"]; let star = lottie.layers[0].shapes[0].it[0]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; let modifier = lottie.layers[0].shapes[0].it[1]; let bez_result = round_corners([convert_shape(star)], modifier.r.k); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_47_bezier.reload(); this.set_json('playground_47_2_bezier', out_shapes[0].ks.k); }, {} ); // Helper function to perform rounding on a single vertex function get_vertex_tangent( // Bezier to round bezier, // Vertex in the bezier we are rounding current_vertex, // Index of the next point along the curve closest_index, // Rounding radius round_distance ) { const tangent_length = 0.5519; // closest_index module bezier.length closest_index = closest_index % bezier.points.length; if ( closest_index < 0 ) closest_index += bezier.points.length; let closest_vertex = bezier.points[closest_index].pos; let distance = current_vertex.distance(closest_vertex); let new_pos_perc = distance != 0 ? Math.min(distance/2, round_distance) / distance : 0; let vertex = closest_vertex.sub(current_vertex).mul(new_pos_perc).add(current_vertex); let tangent = vertex.sub(current_vertex).neg().mul(tangent_length); return [vertex, tangent]; } // Rounding for a single continuos curve function round_bezier_corners( // Bezier to round original, // Rounding radius round_distance ) { let result = new Bezier() result.closed = original.closed; for ( let i = 0; i < original.points.length; i++ ) { let point = original.points[i]; // Start and end of a non-closed path don't get rounded if ( !original.closed && (i == 0 || i == original.points.length - 1) ) { result.add_vertex(point.pos) .set_in_tangent(point.in_tangent) .set_out_tangent(point.out_tangent); } else { let [vert1, out_t] = get_vertex_tangent(original, point.pos, i - 1, round_distance); result.add_vertex(vert1) .set_out_tangent(out_t); let [vert2, in_t] = get_vertex_tangent(original, point.pos, i + 1, round_distance); result.add_vertex(vert2) .set_in_tangent(in_t); } } return result; } // Rounding on multiple bezier function round_corners( // Beziers as collected from the other shapes collected_shapes, // \"r\" property from lottie r ) { let result = [] for ( let input_bezier of collected_shapes ) result.push(round_bezier_corners(input_bezier, r)); return result; } // Example invocation round_corners([convert_shape(star)], modifier.r.k);","title":"Rounded Corners"},{"location":"rendering/#zig-zag","text":"See Zig Zag . Amplitude 10 Frequency 10 Point Type Point Smooth Star Roundness 0 Rotation 0 Points 5 Stroke Width 3 function angle_mean(a, b) { if ( Math.abs(a-b) > Math.PI ) return (a + b) / 2 + Math.PI; return (a + b) / 2; } function zig_zag_corner(output_bezier, segment_before, segment_after, amplitude, direction, tangent_length) { let point; let angle; let tan_angle; // We use 0.01 and 0.99 instead of 0 and 1 because they yield better results if ( !segment_before ) { point = segment_after.points[0]; angle = segment_after.normal_angle(0.01); tan_angle = segment_after.tangent_angle(0.01); } else if ( !segment_after ) { point = segment_before.points[3]; angle = segment_before.normal_angle(0.99); tan_angle = segment_before.tangent_angle(0.99); } else { point = segment_after.points[0]; angle = angle_mean(segment_after.normal_angle(0.01), segment_before.normal_angle(0.99)); tan_angle = angle_mean(segment_after.tangent_angle(0.01), segment_before.tangent_angle(0.99)); } let vertex = output_bezier.add_vertex(point.add_polar(angle, direction * amplitude)); if ( tangent_length !== 0 ) { vertex.set_in_tangent(Point.polar(tan_angle, -tangent_length)); vertex.set_out_tangent(Point.polar(tan_angle, tangent_length)); } } function zig_zag_segment(output_bezier, segment, amplitude, frequency, direction, tangent_length) { for ( let i = 0; i < frequency; i++ ) { let f = (i + 1) / (frequency + 1); let t = segment.t_at_length_percent(f); let angle = segment.normal_angle(t); let point = segment.point(t); let vertex = output_bezier.add_vertex(point.add_polar(angle, direction * amplitude)); if ( tangent_length !== 0 ) { let tan_angle = segment.tangent_angle(t); vertex.set_in_tangent(Point.polar(tan_angle, -tangent_length)); vertex.set_out_tangent(Point.polar(tan_angle, tangent_length)); } direction = -direction; } return direction; } function zig_zag_bezier(input_bezier, amplitude, frequency, smooth) { let output_bezier = new Bezier(); output_bezier.closed = input_bezier.closed; let count = input_bezier.segment_count(); if ( count == 0 ) return output_bezier; let direction = -1; let segment = input_bezier.closed ? input_bezier.segment(count - 1) : null; let next_segment = input_bezier.segment(0); next_segment.calculate_length_data(); let tangent_length = smooth ? next_segment.length / (frequency + 1) / 2 : 0; zig_zag_corner(output_bezier, segment, next_segment, amplitude, -1, tangent_length); for ( let i = 0; i < count; i++ ) { segment = next_segment; direction = zig_zag_segment(output_bezier, segment, amplitude, frequency, -direction, tangent_length); if ( i == count - 1 && !input_bezier.closed ) next_segment = null; else next_segment = input_bezier.segment((i + 1) % count); zig_zag_corner(output_bezier, segment, next_segment, amplitude, direction, tangent_length); } return output_bezier; } function zig_zag( // Beziers as collected from the other shapes collected_shapes, amplitude, frequency, point_type ) { // Ensure we have an integer number of segments frequency = Math.max(0, Math.round(frequency)); let result = []; for ( let input_bezier of collected_shapes ) result.push(zig_zag_bezier(input_bezier, amplitude, frequency, point_type === 2)); return result; } var lottie_player_48_bezier = new LottiePlayer('lottie_target_48_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_48 = new PlaygroundPlayer( 48, 'playground_48_8', 'lottie_target_48', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 222.72242736816406}, \"ir\": {\"a\": 0, \"k\": 111.36121368408203}, \"r\": {\"a\": 0, \"k\": 358.67291259765625}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"zz\", \"nm\": \"Zig Zag\", \"mn\": \"{b4af429a-546e-4728-a869-711a404c55ae}\", \"r\": {\"a\": 0, \"k\": 0}, \"s\": {\"a\": 0, \"k\": 10}, \"pt\": {\"a\": 0, \"k\": 2}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 3}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let bezier_lottie = lottie_player_48_bezier.lottie; lottie.layers[0].shapes[0].it[1].s.k = data[\"Amplitude\"]; lottie.layers[0].shapes[0].it[1].r.k = data[\"Frequency\"]; lottie.layers[0].shapes[0].it[1].pt.k = Number(data[\"Point Type\"]); lottie.layers[0].shapes[0].it[0].pt.k = data[\"Points\"]; lottie.layers[0].shapes[0].it[0].r.k = data[\"Rotation\"]; lottie.layers[0].shapes[0].it[0].is.k = data[\"Roundness\"]; lottie.layers[0].shapes[0].it[0].os.k = data[\"Roundness\"]; lottie.layers[0].shapes[0].it[2].w.k = data[\"Stroke Width\"]; let star = lottie.layers[0].shapes[0].it[0]; bezier_lottie.layers[0].shapes[0].it[1].w.k = data[\"Stroke Width\"]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; let modifier = lottie.layers[0].shapes[0].it[1]; let bez_result = zig_zag([convert_shape(star)], modifier.s.k, modifier.r.k, modifier.pt.k); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_48_bezier.reload(); this.set_json('playground_48_8_bezier', out_shapes[0].ks.k); }, {} ); function angle_mean(a, b) { if ( Math.abs(a-b) > Math.PI ) return (a + b) / 2 + Math.PI; return (a + b) / 2; } function zig_zag_corner(output_bezier, segment_before, segment_after, amplitude, direction, tangent_length) { let point; let angle; let tan_angle; // We use 0.01 and 0.99 instead of 0 and 1 because they yield better results if ( !segment_before ) { point = segment_after.points[0]; angle = segment_after.normal_angle(0.01); tan_angle = segment_after.tangent_angle(0.01); } else if ( !segment_after ) { point = segment_before.points[3]; angle = segment_before.normal_angle(0.99); tan_angle = segment_before.tangent_angle(0.99); } else { point = segment_after.points[0]; angle = angle_mean(segment_after.normal_angle(0.01), segment_before.normal_angle(0.99)); tan_angle = angle_mean(segment_after.tangent_angle(0.01), segment_before.tangent_angle(0.99)); } let vertex = output_bezier.add_vertex(point.add_polar(angle, direction * amplitude)); if ( tangent_length !== 0 ) { vertex.set_in_tangent(Point.polar(tan_angle, -tangent_length)); vertex.set_out_tangent(Point.polar(tan_angle, tangent_length)); } } function zig_zag_segment(output_bezier, segment, amplitude, frequency, direction, tangent_length) { for ( let i = 0; i < frequency; i++ ) { let f = (i + 1) / (frequency + 1); let t = segment.t_at_length_percent(f); let angle = segment.normal_angle(t); let point = segment.point(t); let vertex = output_bezier.add_vertex(point.add_polar(angle, direction * amplitude)); if ( tangent_length !== 0 ) { let tan_angle = segment.tangent_angle(t); vertex.set_in_tangent(Point.polar(tan_angle, -tangent_length)); vertex.set_out_tangent(Point.polar(tan_angle, tangent_length)); } direction = -direction; } return direction; } function zig_zag_bezier(input_bezier, amplitude, frequency, smooth) { let output_bezier = new Bezier(); output_bezier.closed = input_bezier.closed; let count = input_bezier.segment_count(); if ( count == 0 ) return output_bezier; let direction = -1; let segment = input_bezier.closed ? input_bezier.segment(count - 1) : null; let next_segment = input_bezier.segment(0); next_segment.calculate_length_data(); let tangent_length = smooth ? next_segment.length / (frequency + 1) / 2 : 0; zig_zag_corner(output_bezier, segment, next_segment, amplitude, -1, tangent_length); for ( let i = 0; i < count; i++ ) { segment = next_segment; direction = zig_zag_segment(output_bezier, segment, amplitude, frequency, -direction, tangent_length); if ( i == count - 1 && !input_bezier.closed ) next_segment = null; else next_segment = input_bezier.segment((i + 1) % count); zig_zag_corner(output_bezier, segment, next_segment, amplitude, direction, tangent_length); } return output_bezier; } function zig_zag( // Beziers as collected from the other shapes collected_shapes, amplitude, frequency, point_type ) { // Ensure we have an integer number of segments frequency = Math.max(0, Math.round(frequency)); let result = []; for ( let input_bezier of collected_shapes ) result.push(zig_zag_bezier(input_bezier, amplitude, frequency, point_type === 2)); return result; } // Example invocation zig_zag([convert_shape(star)], modifier.s.k, modifier.r.k, modifier.pt.k);","title":"Zig Zag"},{"location":"rendering/#offset-path","text":"See Offset Path . Amount 10 Miter Limit 100 Line Join Miter Round Bevel Star Roundness 0 /* Simple offset of a linear segment */ function linear_offset(p1, p2, amount) { let angle = Math.atan2(p2.x - p1.x, p2.y - p1.y); return [ p1.add_polar(angle, amount), p2.add_polar(angle, amount) ]; } /* Offset a bezier segment only works well if the segment is flat enough */ function offset_segment(segment, amount) { let [p0, p1a] = linear_offset(segment.points[0], segment.points[1], amount); let [p1b, p2b] = linear_offset(segment.points[1], segment.points[2], amount); let [p2a, p3] = linear_offset(segment.points[2], segment.points[3], amount); let p1 = line_intersection(p0, p1a, p1b, p2b) ?? p1a; let p2 = line_intersection(p2a, p3, p1b, p2b) ?? p2a; return new BezierSegment(p0, p1, p2, p3); } /* Join two segments */ function join_lines(output_bezier, seg1, seg2, line_join, miter_limit) { let p0 = seg1.points[3]; let p1 = seg2.points[0]; // Bevel if ( line_join == 3 ) return p0; // Connected, they don't need a joint if ( p0.is_equal(p1) ) return p0; let last_point = output_bezier.points[output_bezier.points.length - 1]; // Round if ( line_join == 2 ) { const ellipse_constant = 0.5519; let angle_out = seg1.tangent_angle(1); let angle_in = seg2.tangent_angle(0) + Math.PI; let center = line_intersection( p0, p0.add_polar(angle_out + Math.PI / 2, 100), p1, p1.add_polar(angle_out + Math.PI / 2, 100) ); let radius = center ? center.distance(p0) : p0.distance(p1) / 2; last_point.set_out_tangent(Point.polar(angle_out, 2 * radius * ellipse_constant)); output_bezier.add_vertex(p1) .set_in_tangent(Point.polar(angle_in, 2 * radius * ellipse_constant)); return p1; } // Miter let t0 = p0.is_equal(seg1.points[2]) ? seg1.points[0] : seg1.points[2]; let t1 = p1.is_equal(seg2.points[1]) ? seg2.points[3] : seg2.points[1]; let intersection = line_intersection(t0, p0, p1, t1); if ( intersection && intersection.distance(p0) < miter_limit ) { output_bezier.add_vertex(intersection); return intersection; } return p0; } function get_intersection(a, b) { let intersect = a.intersections(b); if ( intersect.length && fuzzy_compare(intersect[0], 1) ) intersect.shift(); if ( intersect.length ) return intersect[0]; return null; } function prune_segment_intersection(a, b) { let out_a = [...a]; let out_b = [...b]; let intersect = get_intersection(a[a.length-1], b[0]); if ( intersect ) { out_a[a.length-1] = a[a.length-1].split(intersect[0])[0]; out_b[0] = b[0].split(intersect[1])[1]; } if ( a.length > 1 && b.length > 1 ) { intersect = get_intersection(a[0], b[b.length - 1]); if ( intersect ) { return [ [a[0].split(intersect[0])[0]], [b[b.length-1].split(intersect[1])[1]], ]; } } return [out_a, out_b]; } function prune_intersections(segments) { for ( let i = 1; i < segments.length; i++ ) { [segments[i-1], segments[i]] = prune_segment_intersection(segments[i - 1], segments[i]); } if ( segments.length > 1 ) [segments[segments.length - 1], segments[0]] = prune_segment_intersection(segments[segments.length - 1], segments[0]); return segments; } function offset_segment_split(segment, amount) { /* We split each bezier segment into smaller pieces based on inflection points, this ensures the control point polygon is convex. (A cubic bezier can have none, one, or two inflection points) */ let flex = segment.inflection_points(); if ( flex.length == 0 ) { return [offset_segment(segment, amount)]; } else if ( flex.length == 1 || flex[1] == 1 ) { let [left, right] = segment.split(flex[0]); return [ offset_segment(left, amount), offset_segment(right, amount) ]; } else { let [left, mid_right] = segment.split(flex[0]); let t = (flex[1] - flex[0]) / (1 - flex[0]); let [mid, right] = mid_right.split(t); return [ offset_segment(left, amount), offset_segment(mid, amount), offset_segment(right, amount) ]; } } function offset_path( // Beziers as collected from the other shapes collected_shapes, amount, line_join, miter_limit, ) { let result = []; for ( let input_bezier of collected_shapes ) { let output_bezier = new Bezier(); output_bezier.closed = input_bezier.closed; let count = input_bezier.segment_count(); let multi_segments = []; for ( let i = 0; i < count; i++ ) multi_segments.push(offset_segment_split(input_bezier.segment(i), amount)); // Open paths are stroked rather than being simply offset if ( !input_bezier.closed ) { for ( let i = count - 1; i >= 0; i-- ) multi_segments.push(offset_segment_split(input_bezier.inverted_segment(i), amount)); } multi_segments = prune_intersections(multi_segments); // Add bezier segments to the output and apply line joints let last_point = null; let last_seg = null; for ( let multi_segment of multi_segments ) { if ( last_seg ) last_point = join_lines(output_bezier, last_seg, multi_segment[0], line_join, miter_limit); last_seg = multi_segment[multi_segment.length - 1]; for ( let segment of multi_segment ) { if ( segment.points[0].is_equal(last_point) ) { output_bezier.points[output_bezier.points.length - 1] .set_out_tangent(segment.points[1].sub(segment.points[0])); } else { output_bezier.add_vertex(segment.points[0]) .set_out_tangent(segment.points[1].sub(segment.points[0])); } output_bezier.add_vertex(segment.points[3]) .set_in_tangent(segment.points[2].sub(segment.points[3])); last_point = segment.points[3]; } } if ( multi_segments.length ) join_lines(output_bezier, last_seg, multi_segments[0][0], line_join, miter_limit); result.push(output_bezier); } return result; } var lottie_player_49_bezier = new LottiePlayer('lottie_target_49_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_49 = new PlaygroundPlayer( 49, 'playground_49_5', 'lottie_target_49', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 222.72242736816406}, \"ir\": {\"a\": 0, \"k\": 111.36121368408203}, \"r\": {\"a\": 0, \"k\": 358.67291259765625}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"op\", \"nm\": \"Offset Path\", \"mn\": \"{b4af429a-546e-4728-a869-711a404c55ae}\", \"a\": {\"a\": 0, \"k\": 10}, \"lj\": 2, \"ml\": {\"a\": 0, \"k\": 100}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 3}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { let bezier_lottie = lottie_player_49_bezier.lottie; lottie.layers[0].shapes[0].it[0].is.k = data[\"Star Roundness\"]; lottie.layers[0].shapes[0].it[0].os.k = data[\"Star Roundness\"]; lottie.layers[0].shapes[0].it[1].a.k = data[\"Amount\"]; lottie.layers[0].shapes[0].it[1].lj = Number(data[\"Line Join\"]); lottie.layers[0].shapes[0].it[1].ml.k = data[\"Miter Limit\"]; let star = lottie.layers[0].shapes[0].it[0]; bezier_lottie.layers[0].shapes[0].it[1].w.k = 3; this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; let modifier = lottie.layers[0].shapes[0].it[1]; let bez_result = offset_path([convert_shape(star)], modifier.a.k, modifier.lj, modifier.ml.k); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_49_bezier.reload(); this.set_json('playground_49_5_bezier', out_shapes[0].ks.k); }, {} ); /* Simple offset of a linear segment */ function linear_offset(p1, p2, amount) { let angle = Math.atan2(p2.x - p1.x, p2.y - p1.y); return [ p1.add_polar(angle, amount), p2.add_polar(angle, amount) ]; } /* Offset a bezier segment only works well if the segment is flat enough */ function offset_segment(segment, amount) { let [p0, p1a] = linear_offset(segment.points[0], segment.points[1], amount); let [p1b, p2b] = linear_offset(segment.points[1], segment.points[2], amount); let [p2a, p3] = linear_offset(segment.points[2], segment.points[3], amount); let p1 = line_intersection(p0, p1a, p1b, p2b) ?? p1a; let p2 = line_intersection(p2a, p3, p1b, p2b) ?? p2a; return new BezierSegment(p0, p1, p2, p3); } /* Join two segments */ function join_lines(output_bezier, seg1, seg2, line_join, miter_limit) { let p0 = seg1.points[3]; let p1 = seg2.points[0]; // Bevel if ( line_join == 3 ) return p0; // Connected, they don't need a joint if ( p0.is_equal(p1) ) return p0; let last_point = output_bezier.points[output_bezier.points.length - 1]; // Round if ( line_join == 2 ) { const ellipse_constant = 0.5519; let angle_out = seg1.tangent_angle(1); let angle_in = seg2.tangent_angle(0) + Math.PI; let center = line_intersection( p0, p0.add_polar(angle_out + Math.PI / 2, 100), p1, p1.add_polar(angle_out + Math.PI / 2, 100) ); let radius = center ? center.distance(p0) : p0.distance(p1) / 2; last_point.set_out_tangent(Point.polar(angle_out, 2 * radius * ellipse_constant)); output_bezier.add_vertex(p1) .set_in_tangent(Point.polar(angle_in, 2 * radius * ellipse_constant)); return p1; } // Miter let t0 = p0.is_equal(seg1.points[2]) ? seg1.points[0] : seg1.points[2]; let t1 = p1.is_equal(seg2.points[1]) ? seg2.points[3] : seg2.points[1]; let intersection = line_intersection(t0, p0, p1, t1); if ( intersection && intersection.distance(p0) < miter_limit ) { output_bezier.add_vertex(intersection); return intersection; } return p0; } function get_intersection(a, b) { let intersect = a.intersections(b); if ( intersect.length && fuzzy_compare(intersect[0], 1) ) intersect.shift(); if ( intersect.length ) return intersect[0]; return null; } function prune_segment_intersection(a, b) { let out_a = [...a]; let out_b = [...b]; let intersect = get_intersection(a[a.length-1], b[0]); if ( intersect ) { out_a[a.length-1] = a[a.length-1].split(intersect[0])[0]; out_b[0] = b[0].split(intersect[1])[1]; } if ( a.length > 1 && b.length > 1 ) { intersect = get_intersection(a[0], b[b.length - 1]); if ( intersect ) { return [ [a[0].split(intersect[0])[0]], [b[b.length-1].split(intersect[1])[1]], ]; } } return [out_a, out_b]; } function prune_intersections(segments) { for ( let i = 1; i < segments.length; i++ ) { [segments[i-1], segments[i]] = prune_segment_intersection(segments[i - 1], segments[i]); } if ( segments.length > 1 ) [segments[segments.length - 1], segments[0]] = prune_segment_intersection(segments[segments.length - 1], segments[0]); return segments; } function offset_segment_split(segment, amount) { /* We split each bezier segment into smaller pieces based on inflection points, this ensures the control point polygon is convex. (A cubic bezier can have none, one, or two inflection points) */ let flex = segment.inflection_points(); if ( flex.length == 0 ) { return [offset_segment(segment, amount)]; } else if ( flex.length == 1 || flex[1] == 1 ) { let [left, right] = segment.split(flex[0]); return [ offset_segment(left, amount), offset_segment(right, amount) ]; } else { let [left, mid_right] = segment.split(flex[0]); let t = (flex[1] - flex[0]) / (1 - flex[0]); let [mid, right] = mid_right.split(t); return [ offset_segment(left, amount), offset_segment(mid, amount), offset_segment(right, amount) ]; } } function offset_path( // Beziers as collected from the other shapes collected_shapes, amount, line_join, miter_limit, ) { let result = []; for ( let input_bezier of collected_shapes ) { let output_bezier = new Bezier(); output_bezier.closed = input_bezier.closed; let count = input_bezier.segment_count(); let multi_segments = []; for ( let i = 0; i < count; i++ ) multi_segments.push(offset_segment_split(input_bezier.segment(i), amount)); // Open paths are stroked rather than being simply offset if ( !input_bezier.closed ) { for ( let i = count - 1; i >= 0; i-- ) multi_segments.push(offset_segment_split(input_bezier.inverted_segment(i), amount)); } multi_segments = prune_intersections(multi_segments); // Add bezier segments to the output and apply line joints let last_point = null; let last_seg = null; for ( let multi_segment of multi_segments ) { if ( last_seg ) last_point = join_lines(output_bezier, last_seg, multi_segment[0], line_join, miter_limit); last_seg = multi_segment[multi_segment.length - 1]; for ( let segment of multi_segment ) { if ( segment.points[0].is_equal(last_point) ) { output_bezier.points[output_bezier.points.length - 1] .set_out_tangent(segment.points[1].sub(segment.points[0])); } else { output_bezier.add_vertex(segment.points[0]) .set_out_tangent(segment.points[1].sub(segment.points[0])); } output_bezier.add_vertex(segment.points[3]) .set_in_tangent(segment.points[2].sub(segment.points[3])); last_point = segment.points[3]; } } if ( multi_segments.length ) join_lines(output_bezier, last_seg, multi_segments[0][0], line_join, miter_limit); result.push(output_bezier); } return result; } // Example invocation offset_path([convert_shape(star)], modifier.a.k, modifier.lj, modifier.ml.k);","title":"Offset Path"},{"location":"rendering/#trim-path","text":"Start 0 End 50 Offset 0 Multiple Shapes Parallel Sequential function trim_path_gather_chunks(collected_shapes, multiple) { let chunks = []; // Shapes are handled as a single unit if ( multiple === 2 ) chunks.push({segments: [], length: 0}); for ( let input_bezier of collected_shapes ) { // Shapes are all affected separately if ( multiple === 1 ) chunks.push({segments: [], length: 0}); let chunk = chunks[chunks.length-1]; for ( let i = 0; i < input_bezier.segment_count(); i++ ) { let segment = input_bezier.segment(i); let length = segment.get_length(); chunk.segments.push(segment); chunk.length += length; } // Use null as a marker to start a new bezier if ( multiple == 2 ) chunk.segments.push(null); } return chunks; } function trim_path_chunk(chunk, start, end, output_shapes) { // Note: start and end have been normalized and have the offset applied // The offset itself was normalized into [0, 1] so this is always true: // 0 <= start < end <= 2 // Some offsets require us to handle different \"splits\" // We want each split to be a pair [s, e] such that // 0 <= s < e <= 1 var splits = []; if ( end <= 1 ) { // Simplest case, the segment is in [0, 1] splits.push([start, end]); } else if ( start > 1 ) { // The whole segment is outside [0, 1] splits.push([start-1, end-1]); } else { // The segment goes over the end point, so we need two splits splits.push([start, 1]); splits.push([0, end-1]); } // Each split is a separate bezier, all left to do is finding the // bezier segment to add to the output for ( let [s, e] of splits ) { let start_length = s * chunk.length; let start_t; let end_length = e * chunk.length; let prev_length = 0; let output_bezier = new Bezier(false); output_shapes.push(output_bezier); for ( let i = 0; i < chunk.segments.length; i++ ) { let segment = chunk.segments[i]; // New bezier marker found if ( segment === null ) { output_bezier = new Bezier(false); output_shapes.push(output_bezier); continue; } if ( segment.length >= end_length ) { let end_t = segment.t_at_length(end_length); if ( segment.length >= start_length ) { start_t = segment.t_at_length(start_length); segment = segment.split(start_t)[1]; end_t = (end_t - start_t) / (1 - start_t); } output_bezier.add_segment(segment.split(end_t)[0], false); break; } if ( start_t === undefined ) { if ( segment.length >= start_length ) { start_t = segment.t_at_length(start_length); output_bezier.add_segment(segment.split(start_t)[1], false); } } else { output_bezier.add_segment(segment, true); } start_length -= segment.length; end_length -= segment.length; } } } function trim_path( collected_shapes, start, end, offset, multiple ) { // Normalize Inputs offset = offset / 360 % 1; if ( offset < 0 ) offset += 1; start = Math.min(1, Math.max(0, start / 100)); end = Math.min(1, Math.max(0, end / 100)); if ( end < start ) [start, end] = [end, start]; // Apply offset start += offset; end += offset; // Handle the degenerate cases if ( fuzzy_compare(start, end) ) return [new Bezier(false)]; if ( fuzzy_zero(start) && fuzzy_compare(end, 1) ) return collected_shapes; // Gather up the segments to trim let chunks = trim_path_gather_chunks(collected_shapes, multiple); let output_shapes = []; for ( let chunk of chunks ) trim_path_chunk(chunk, start, end, output_shapes); return output_shapes; } var lottie_player_50_bezier = new LottiePlayer('lottie_target_50_bezier', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}); var lottie_player_50 = new PlaygroundPlayer( 50, 'playground_50_5', 'lottie_target_50', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [128, 128]}, \"or\": {\"a\": 0, \"k\": 100}, \"ir\": {\"a\": 0, \"k\": 50}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{74587b40-1ef1-445d-b9ab-02b8a42a96aa}\", \"p\": {\"a\": 0, \"k\": [384, 128]}, \"s\": {\"a\": 0, \"k\": [200, 200]}}, {\"ty\": \"rc\", \"nm\": \"Rect\", \"mn\": \"{0776f2df-2619-415c-b10d-f648f2edfa0f}\", \"d\": 1, \"p\": {\"a\": 0, \"k\": [128, 384]}, \"s\": {\"a\": 0, \"k\": [200, 200]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"sr\", \"nm\": \"Triangle\", \"mn\": \"{db373594-d0ae-44ff-9295-30ff72616af2}\", \"p\": {\"a\": 0, \"k\": [384, 384]}, \"or\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 3}, \"sy\": 2, \"os\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"tm\", \"nm\": \"Trim Path\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"s\": {\"a\": 0, \"k\": 0}, \"e\": {\"a\": 0, \"k\": 50}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 20}}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { let bezier_lottie = lottie_player_50_bezier.lottie; lottie.layers[0].shapes[4].s.k = data[\"Start\"]; lottie.layers[0].shapes[4].e.k = data[\"End\"]; lottie.layers[0].shapes[4].o.k = data[\"Offset\"]; lottie.layers[0].shapes[4].m = Number(data[\"Multiple Shapes\"]); let siblings = bezier_lottie.layers[0].shapes[0].it; siblings[siblings.length-2].w.k = 20; let shapes = []; for ( let i = 0; i < 4; i++ ) shapes.push(convert_shape(lottie.layers[0].shapes[i])); this.json_viewer_contents = lottie.layers[0].shapes[4]; let modifier = lottie.layers[0].shapes[4]; let bez_result = trim_path(shapes, modifier.s.k, modifier.e.k, modifier.o.k, modifier.m); if ( !Array.isArray(bez_result) ) bez_result = [bez_result]; let out_shapes = bez_result.map(b => ({ ty: \"sh\", \"ks\": {a: 0, k: b.to_lottie()} })); let bez_target = bezier_lottie.layers[0].shapes[0].it; bez_target.splice(0, bez_target.length - 2, ...out_shapes); lottie_player_50_bezier.reload(); this.set_json('playground_50_5_bezier', out_shapes[0].ks.k); }, {} ); function trim_path_gather_chunks(collected_shapes, multiple) { let chunks = []; // Shapes are handled as a single unit if ( multiple === 2 ) chunks.push({segments: [], length: 0}); for ( let input_bezier of collected_shapes ) { // Shapes are all affected separately if ( multiple === 1 ) chunks.push({segments: [], length: 0}); let chunk = chunks[chunks.length-1]; for ( let i = 0; i < input_bezier.segment_count(); i++ ) { let segment = input_bezier.segment(i); let length = segment.get_length(); chunk.segments.push(segment); chunk.length += length; } // Use null as a marker to start a new bezier if ( multiple == 2 ) chunk.segments.push(null); } return chunks; } function trim_path_chunk(chunk, start, end, output_shapes) { // Note: start and end have been normalized and have the offset applied // The offset itself was normalized into [0, 1] so this is always true: // 0 <= start < end <= 2 // Some offsets require us to handle different \"splits\" // We want each split to be a pair [s, e] such that // 0 <= s < e <= 1 var splits = []; if ( end <= 1 ) { // Simplest case, the segment is in [0, 1] splits.push([start, end]); } else if ( start > 1 ) { // The whole segment is outside [0, 1] splits.push([start-1, end-1]); } else { // The segment goes over the end point, so we need two splits splits.push([start, 1]); splits.push([0, end-1]); } // Each split is a separate bezier, all left to do is finding the // bezier segment to add to the output for ( let [s, e] of splits ) { let start_length = s * chunk.length; let start_t; let end_length = e * chunk.length; let prev_length = 0; let output_bezier = new Bezier(false); output_shapes.push(output_bezier); for ( let i = 0; i < chunk.segments.length; i++ ) { let segment = chunk.segments[i]; // New bezier marker found if ( segment === null ) { output_bezier = new Bezier(false); output_shapes.push(output_bezier); continue; } if ( segment.length >= end_length ) { let end_t = segment.t_at_length(end_length); if ( segment.length >= start_length ) { start_t = segment.t_at_length(start_length); segment = segment.split(start_t)[1]; end_t = (end_t - start_t) / (1 - start_t); } output_bezier.add_segment(segment.split(end_t)[0], false); break; } if ( start_t === undefined ) { if ( segment.length >= start_length ) { start_t = segment.t_at_length(start_length); output_bezier.add_segment(segment.split(start_t)[1], false); } } else { output_bezier.add_segment(segment, true); } start_length -= segment.length; end_length -= segment.length; } } } function trim_path( collected_shapes, start, end, offset, multiple ) { // Normalize Inputs offset = offset / 360 % 1; if ( offset < 0 ) offset += 1; start = Math.min(1, Math.max(0, start / 100)); end = Math.min(1, Math.max(0, end / 100)); if ( end < start ) [start, end] = [end, start]; // Apply offset start += offset; end += offset; // Handle the degenerate cases if ( fuzzy_compare(start, end) ) return [new Bezier(false)]; if ( fuzzy_zero(start) && fuzzy_compare(end, 1) ) return collected_shapes; // Gather up the segments to trim let chunks = trim_path_gather_chunks(collected_shapes, multiple); let output_shapes = []; for ( let chunk of chunks ) trim_path_chunk(chunk, start, end, output_shapes); return output_shapes; } // Example invocation trim_path(shapes, modifier.s.k, modifier.e.k, modifier.o.k, modifier.m);","title":"Trim Path"},{"location":"rendering/#transform","text":"This is how to convert a transform object into a matrix. Assuming the matrix a c 0 0 b d 0 0 0 0 1 0 tx ty 0 1 The names a , b , etc are the ones commonly used for CSS transforms . 4D matrix to allow for 3D transforms, even though currently lottie only supports 2D graphics. Multiplications are right multiplications ( Next = Previous * StepOperation ). If your transform is transposed ( tx , ty are on the last column), perform left multiplication instead. Perform the following operations on a matrix starting from the identity matrix (or the parent object's transform matrix): Translate by -a : 1 0 0 0 0 1 0 0 0 0 1 0 -a[0] -a[1] 0 1 Scale by s/100 : s[0]/100 0 0 0 0 s[1]/100 0 0 0 0 1 0 0 0 0 1 Rotate by -sa (can be skipped if not skewing) cos(-sa) sin(-sa) 0 0 -sin(-sa) cos(-sa) 0 0 0 0 1 0 0 0 0 1 Skew by sk (can be skipped if not skewing) 1 tan(-sk) 0 0 0 1 0 0 0 0 1 0 0 0 0 1 Rotate by sa (can be skipped if not skewing) cos(sa) sin(sa) 0 0 -sin(sa) cos(sa) 0 0 0 0 1 0 0 0 0 1 Rotate by -r cos(-r) sin(-r) 0 0 -sin(-r) cos(-r) 0 0 0 0 1 0 0 0 0 1 If you are handling an auto orient layer, evaluate and apply auto-orient rotation. Translate by p 1 0 0 0 0 1 0 0 0 0 1 0 p[0] p[1] 0 1","title":"Transform"},{"location":"rendering/#3d-transform","text":"If you have a 3D transform, the process is similar, with a , p , s , using their 3D matrices, note that for p and a the Z axis is inverted. The rotation step is a bit more complicated, with the 2D rotation being equivalent to a Z rotation. The rotation step above is replaced with the following set of steps: Rotate by -rz cos(-r) sin(-r) 0 0 -sin(-r) cos(-r) 0 0 0 0 1 0 0 0 0 1 Rotate by ry cos(r) 0 sin(r) 0 0 1 0 0 -sin(r) 0 cos(-r) 0 0 0 1 Rotate by rx 1 0 0 0 0 cos(r) -sin(r) 0 0 -sin(r) cos(-r) 0 0 0 0 1 Then repeat the steps for or : Rotate by -or[2] (Z axis) cos(-r) sin(-r) 0 0 -sin(-r) cos(-r) 0 0 0 0 1 0 0 0 0 1 Rotate by or[1] (Y axis) cos(r) 0 sin(r) 0 0 1 0 0 -sin(r) 0 cos(-r) 0 0 0 1 Rotate by or[0] (X axis) 1 0 0 0 0 cos(r) -sin(r) 0 0 -sin(r) cos(-r) 0 0 0 0 1","title":"3D Transform"},{"location":"rendering/#auto-orient","text":"Auto-orient is only relevant for layers that have ao set to 1 an animated position. You get the derivative of the position property at the current time as a pair ( dx , dy ), and find the angle with atan2(dy, dx) , then rotate by that angle clockwise: cos(-r) sin(-r) 0 0 -sin(-r) cos(-r) 0 0 0 0 1 0 0 0 0 1","title":"Auto Orient"},{"location":"rendering/#animated-properties","text":"Assuming a 1D property, a keyframe looks something like this: { \"t\": start_time, \"s\": [ start_value ], \"o\": { \"x\": [ ox ], \"y\": [ oy ] }, \"i\": { \"x\": [ ix ], \"y\": [ iy ] } } Where: t is the time at the start of the keyframe (in frames), s is the value at that time i and o are the in/out bezier tangents The transition between keyframes is defined by two keyframes, for simplicity we'll refer to the named values above plus end_time and end_value corresponding to t and s on the keyframe after the one listed. The transition is given as a cubic bezier curve whose x axis is time and the y axis is the interpolating factor between start_value and end_value . The four points of this bezier curve are: (0, 0), (ox, oy), (iy, iy), (1, 1). x is given by x = (current_time - start_time) / (end_time - start_time) . If the bezier is defined as a t 3 + b t 2 + c t + d = 0 then you need to find the cubic roots of a t 3 + b t 2 + c t + d - x = 0 to find the t corresponding to that x , (You only need to consider real roots in [0, 1]). Then you can find the y by evaluating the bezier at t . The final value is as follows: lerp(y, start_value, end_value) . KeyframePreviewEditor.stand_alone(document.getElementById(\"editor_51\"), (lottie) => { var raw_json = JSON.stringify(lottie, undefined, 4); var pretty_json = hljs.highlight(\"json\", raw_json).value; document.getElementById(\"json_viewer_51\").innerHTML = pretty_json; }, {foreground: function () { if ( !this.x_input ) return; var t1 = this.points[0].out_tan.logical_coords(); var t2 = this.points[1].in_tan.logical_coords(); var seg = new BezierSegment( new Point(0, 0), new Point(t1.x, t1.y), new Point(t2.x, t2.y), new Point(1, 1) ); let x = Number(this.x_input.value); this.context.lineWidth = 1; this.context.strokeStyle = \"red\"; this.context.beginPath(); this.context.moveTo(...this.logical_to_canvas(x, 0)); this.context.lineTo(...this.logical_to_canvas(x, 1)); let t = seg.t_at_x(x); let y = seg.value(t).y; this.context.moveTo(...this.logical_to_canvas(0, y)); this.context.lineTo(...this.logical_to_canvas(1, y)); this.table_x.innerText = x; this.table_t.innerText = t; this.table_y.innerText = y; this.context.stroke(); }, init: function (editor, container) { var inp = container.appendChild(document.createElement(\"input\")); var style = \"width: \" + editor.bezier_editor.canvas.width + \"px\"; editor.bezier_editor.x_input = inp; inp.setAttribute(\"type\", \"range\"); inp.setAttribute(\"min\", \"0\"); inp.setAttribute(\"max\", \"1\"); inp.setAttribute(\"value\", \"0\"); inp.setAttribute(\"step\", \"0.01\"); inp.setAttribute(\"style\", style); inp.addEventListener(\"input\", () => editor.bezier_editor.draw_frame()); var table = container.appendChild(document.createElement(\"table\")); table.setAttribute(\"style\", style); for ( let v of \"xty\" ) { var tr = table.appendChild(document.createElement(\"tr\")); tr.appendChild(document.createElement(\"th\")).appendChild(document.createTextNode(v)); var td = tr.appendChild(document.createElement(\"td\")); td.setAttribute(\"style\", \"text-align: left; width: 90%;\"); editor.bezier_editor[\"table_\" + v] = td; } editor.bezier_editor.draw_frame(); }, });","title":"Animated Properties"},{"location":"rendering/#effects","text":".webgl-shader { transform: scaleY(-1); }","title":"Effects"},{"location":"rendering/#fill-effect","text":"Opacity Color 1 Red 1 Green 0.9 Blue 0 var lottie_shader_38 = new SinglePassShader(document.getElementById('lottie_target_38_canvas')); lottie_shader_38.set_fragment('#version 100\\n\\nuniform highp vec4 color;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\nvoid main()\\n{\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n highp vec4 pixel = texture2D(texture_sampler, uv);\\n\\n gl_FragColor = color;\\n gl_FragColor.a = 1.0;\\n gl_FragColor *= pixel.a * color.a;\\n}') var lottie_player_38 = new PlaygroundPlayer( 38, 'playground_38_5', 'lottie_target_38', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 21, \"ef\": [{\"ty\": 3, \"v\": {\"k\": [0, 0], \"a\": 0}}, {\"ty\": 7, \"v\": {\"k\": 0, \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [1, 0.9, 0, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}, {\"ty\": 7, \"v\": {\"k\": 0, \"a\": 0}}, {\"ty\": 0, \"v\": {\"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"a\": 0, \"k\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { let shader = lottie_shader_38; lottie.layers[0].ef[0].ef[6].v.k = data[\"Opacity\"]; lottie.layers[0].ef[0].ef[2].v.k[0] = data[\"Red\"]; lottie.layers[0].ef[0].ef[2].v.k[1] = data[\"Green\"]; lottie.layers[0].ef[0].ef[2].v.k[2] = data[\"Blue\"]; shader.set_uniform(\"color\", \"4fv\", [data[\"Red\"], data[\"Green\"], data[\"Blue\"], data[\"Opacity\"]]); this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} ); #version 100 uniform highp vec4 color; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; void main() { highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); highp vec4 pixel = texture2D(texture_sampler, uv); gl_FragColor = color; gl_FragColor.a = 1.0; gl_FragColor *= pixel.a * color.a; }","title":"Fill Effect"},{"location":"rendering/#tritone-effect","text":"Red 1 Green 1 Blue Mid 1 Red 0.3 Green 0.8 Blue Dark 0.3 Red 0 Green 0 Blue 0 var lottie_shader_39 = new SinglePassShader(document.getElementById('lottie_target_39_canvas')); lottie_shader_39.set_fragment('#version 100\\n\\nuniform highp vec4 bright;\\nuniform highp vec4 mid;\\nuniform highp vec4 dark;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\nvoid main()\\n{\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n highp vec4 pixel = texture2D(texture_sampler, uv);\\n\\n highp float lightness = sqrt(pixel.r * pixel.r * 0.299 + pixel.g * pixel.g * 0.587 + pixel.b * pixel.b * 0.114);\\n // If you want results more similar to lottie-web use the lightness below\\n // (this shader has a more accurate lightness calculation)\\n // lightness = sqrt((pixel.r * pixel.r + pixel.g * pixel.g + pixel.b * pixel.b) / 3.0);\\n\\n if ( lightness < 0.5 )\\n {\\n lightness *= 2.0;\\n gl_FragColor = dark * (1.0 - lightness) + mid * lightness;\\n }\\n else\\n {\\n lightness = (lightness - 0.5) * 2.0;\\n gl_FragColor = mid * (1.0 - lightness) + bright * lightness;\\n }\\n\\n gl_FragColor *= pixel.a;\\n}') var lottie_player_39 = new PlaygroundPlayer( 39, 'playground_39_10', 'lottie_target_39', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 23, \"ef\": [{\"ty\": 2, \"v\": {\"k\": [1, 1, 1, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0.3, 0.8, 0.3, 1], \"a\": 0}}, {\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { let shader = lottie_shader_39; lottie.layers[0].ef[0].ef[0].v.k[0] = data[\"r1\"]; lottie.layers[0].ef[0].ef[0].v.k[1] = data[\"g1\"]; lottie.layers[0].ef[0].ef[0].v.k[2] = data[\"b1\"]; lottie.layers[0].ef[0].ef[1].v.k[0] = data[\"r2\"]; lottie.layers[0].ef[0].ef[1].v.k[1] = data[\"g2\"]; lottie.layers[0].ef[0].ef[1].v.k[2] = data[\"b2\"]; lottie.layers[0].ef[0].ef[2].v.k[0] = data[\"r3\"]; lottie.layers[0].ef[0].ef[2].v.k[1] = data[\"g3\"]; lottie.layers[0].ef[0].ef[2].v.k[2] = data[\"b3\"]; shader.set_uniform(\"bright\", \"4fv\", [data[\"r1\"], data[\"g1\"], data[\"b1\"], 1]); shader.set_uniform(\"mid\", \"4fv\", [data[\"r2\"], data[\"g2\"], data[\"b2\"], 1]); shader.set_uniform(\"dark\", \"4fv\", [data[\"r3\"], data[\"g3\"], data[\"b3\"], 1]); this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} ); #version 100 uniform highp vec4 bright; uniform highp vec4 mid; uniform highp vec4 dark; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; void main() { highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); highp vec4 pixel = texture2D(texture_sampler, uv); highp float lightness = sqrt(pixel.r * pixel.r * 0.299 + pixel.g * pixel.g * 0.587 + pixel.b * pixel.b * 0.114); // If you want results more similar to lottie-web use the lightness below // (this shader has a more accurate lightness calculation) // lightness = sqrt((pixel.r * pixel.r + pixel.g * pixel.g + pixel.b * pixel.b) / 3.0); if ( lightness < 0.5 ) { lightness *= 2.0; gl_FragColor = dark * (1.0 - lightness) + mid * lightness; } else { lightness = (lightness - 0.5) * 2.0; gl_FragColor = mid * (1.0 - lightness) + bright * lightness; } gl_FragColor *= pixel.a; }","title":"Tritone Effect"},{"location":"rendering/#gaussian-blur","text":"This is a two-pass shader, the uniform pass is has value 0 on the first pass and value 1 on the second pass. Sigma 25 Direction\" Both Horizontal Vertical Wrap var lottie_shader_40 = new MultiPassShader(document.getElementById('lottie_target_40_canvas')); var program_40_0 = new ShaderProgram(lottie_shader_40.gl); program_40_0.set_fragment('#version 300 es\\n\\n#define PI 3.1415926538\\nprecision highp float;\\n\\nuniform float sigma;\\nuniform int direction;\\nuniform int kernel_size;\\nuniform bool wrap;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\nuniform int pass;\\n\\nout vec4 FragColor;\\n\\n\\nvec4 texture_value(vec2 uv)\\n{\\n if ( wrap )\\n {\\n if ( uv.x < 0. ) uv.x = 1. - uv.x;\\n if ( uv.x > 1. ) uv.x = uv.x - 1.;\\n if ( uv.y < 0. ) uv.y = 1. - uv.y;\\n if ( uv.y > 1. ) uv.y = uv.y - 1.;\\n }\\n else if ( uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1. )\\n {\\n return vec4(0.0);\\n }\\n\\n return texture(texture_sampler, uv);\\n}\\n\\n\\nvec4 blur_pass(float sigma, int kernel_size, vec2 uv, bool horizontal)\\n{\\n float side = float(kernel_size / 2);\\n\\n vec2 direction_vector = horizontal ?\\n vec2(1.0, 0.0) / canvas_size.x :\\n vec2(0.0, 1.0) / canvas_size.y;\\n\\n vec3 delta_gauss;\\n delta_gauss.x = 1.0 / (sqrt(2.0 * PI) * sigma);\\n delta_gauss.y = exp(-0.5 / (sigma * sigma));\\n delta_gauss.z = delta_gauss.y * delta_gauss.y;\\n\\n vec4 avg = vec4(0.0, 0.0, 0.0, 0.0);\\n float sum = 0.0;\\n\\n vec4 pixel = texture_value(uv);\\n avg += pixel * delta_gauss.x;\\n sum += delta_gauss.x;\\n delta_gauss.xy *= delta_gauss.yz;\\n\\n for ( float i = 1.0; i <= side; i++)\\n {\\n for ( float s = -1.0; s <= 1.0; s += 2.0 )\\n {\\n vec2 pos = uv + s * i * direction_vector;\\n pixel = texture_value(pos);\\n avg += pixel * delta_gauss.x;\\n }\\n sum += 2.0 * delta_gauss.x;\\n delta_gauss.xy *= delta_gauss.yz;\\n }\\n\\n avg /= sum;\\n\\n return avg;\\n}\\n\\n\\nvoid main()\\n{\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n\\n int actual_kernel_size = kernel_size == 0 ? int(0.5 + 6.0 * sigma) : kernel_size;\\n\\n const float multiplier = 0.25;\\n\\n if ( sigma == 0.0 )\\n {\\n FragColor = texture(texture_sampler, uv);\\n }\\n else if ( pass == 0 )\\n {\\n if ( direction != 3 )\\n FragColor = blur_pass(sigma * multiplier, actual_kernel_size, uv, true);\\n else\\n FragColor = texture(texture_sampler, uv);\\n }\\n else if ( pass == 1 )\\n {\\n if ( direction != 2 )\\n FragColor = blur_pass(sigma * multiplier, actual_kernel_size, uv, false);\\n else\\n FragColor = texture(texture_sampler, uv);\\n }\\n}') lottie_shader_40.add_pass(program_40_0, {\"pass\": [\"1i\", 0]}) lottie_shader_40.add_pass(program_40_0, {\"pass\": [\"1i\", 1]}) var lottie_player_40 = new PlaygroundPlayer( 40, 'playground_40_4', 'lottie_target_40', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 29, \"en\": 1, \"ef\": [{\"ty\": 0, \"v\": {\"a\": 0, \"k\": 25}}, {\"ty\": 0, \"v\": {\"k\": 0, \"a\": 0}}, {\"ty\": 4, \"v\": {\"k\": 0, \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { let shader = lottie_shader_40; lottie.layers[0].ef[0].ef[0].v.k = data[\"Sigma\"]; lottie.layers[0].ef[0].ef[1].v.k = Number(data[\"Direction\"]); lottie.layers[0].ef[0].ef[2].v.k = Number(data[\"Wrap\"]); for ( let pass of [0, 1] ) { shader.set_uniform(pass, \"sigma\", \"1f\", data[\"Sigma\"]); shader.set_uniform(pass, \"direction\", \"1i\", data[\"Direction\"]); shader.set_uniform(pass, \"wrap\", \"1i\", data[\"Wrap\"]); } this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} ); #version 300 es #define PI 3.1415926538 precision highp float; uniform float sigma; uniform int direction; uniform int kernel_size; uniform bool wrap; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; uniform int pass; out vec4 FragColor; vec4 texture_value(vec2 uv) { if ( wrap ) { if ( uv.x < 0. ) uv.x = 1. - uv.x; if ( uv.x > 1. ) uv.x = uv.x - 1.; if ( uv.y < 0. ) uv.y = 1. - uv.y; if ( uv.y > 1. ) uv.y = uv.y - 1.; } else if ( uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1. ) { return vec4(0.0); } return texture(texture_sampler, uv); } vec4 blur_pass(float sigma, int kernel_size, vec2 uv, bool horizontal) { float side = float(kernel_size / 2); vec2 direction_vector = horizontal ? vec2(1.0, 0.0) / canvas_size.x : vec2(0.0, 1.0) / canvas_size.y; vec3 delta_gauss; delta_gauss.x = 1.0 / (sqrt(2.0 * PI) * sigma); delta_gauss.y = exp(-0.5 / (sigma * sigma)); delta_gauss.z = delta_gauss.y * delta_gauss.y; vec4 avg = vec4(0.0, 0.0, 0.0, 0.0); float sum = 0.0; vec4 pixel = texture_value(uv); avg += pixel * delta_gauss.x; sum += delta_gauss.x; delta_gauss.xy *= delta_gauss.yz; for ( float i = 1.0; i <= side; i++) { for ( float s = -1.0; s <= 1.0; s += 2.0 ) { vec2 pos = uv + s * i * direction_vector; pixel = texture_value(pos); avg += pixel * delta_gauss.x; } sum += 2.0 * delta_gauss.x; delta_gauss.xy *= delta_gauss.yz; } avg /= sum; return avg; } void main() { highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); int actual_kernel_size = kernel_size == 0 ? int(0.5 + 6.0 * sigma) : kernel_size; const float multiplier = 0.25; if ( sigma == 0.0 ) { FragColor = texture(texture_sampler, uv); } else if ( pass == 0 ) { if ( direction != 3 ) FragColor = blur_pass(sigma * multiplier, actual_kernel_size, uv, true); else FragColor = texture(texture_sampler, uv); } else if ( pass == 1 ) { if ( direction != 2 ) FragColor = blur_pass(sigma * multiplier, actual_kernel_size, uv, false); else FragColor = texture(texture_sampler, uv); } }","title":"Gaussian Blur"},{"location":"rendering/#drop-shadow-effect","text":"The effect below is split into multiple shaders: First it generates the shadow Then it has a 2 pass gaussian blur (simplified from the example above) Finally, it composites the original image on top of the blurred shadow Red 0 Green 0 Blue 0 Opacity 128 Angle 135 Distance 10 Blur 7 var lottie_shader_41 = new MultiPassShader(document.getElementById('lottie_target_41_canvas')); lottie_shader_41.add_pass_source('#version 300 es\\n#define PI 3.1415926538\\n\\nuniform highp vec4 color;\\nuniform mediump float angle;\\nuniform mediump float distance;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\nout highp vec4 FragColor;\\n\\nvoid main()\\n{\\n // Base pixel value\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n highp vec4 pixel = texture(texture_sampler, uv);\\n\\n // Pixel value at the given offset\\n mediump float radians = -angle * PI / 180.0 + PI / 2.0;\\n highp vec2 shadow_uv = vec2(\\n (gl_FragCoord.x - distance * cos(radians)) / canvas_size.x,\\n 1.0 - (gl_FragCoord.y - distance * sin(radians)) / canvas_size.y\\n );\\n highp vec4 shadow_pixel = texture(texture_sampler, shadow_uv);\\n\\n // Colorize shadow\\n highp vec4 shadow_color;\\n\\n if ( shadow_uv.x >= 0.0 && shadow_uv.x <= 1.0 && shadow_uv.y >= 0.0 && shadow_uv.y <= 1.0 )\\n {\\n shadow_color = color;\\n shadow_color.a = 1.0;\\n shadow_color *= shadow_pixel.a * color.a / 255.0;\\n }\\n\\n // Apply shadow below the base pixel\\n FragColor = shadow_color; //pixel * pixel.a + shadow_color * (1.0 - pixel.a);\\n}', {\"pass\": [\"1i\", 0]}) var program_41_1 = new ShaderProgram(lottie_shader_41.gl); program_41_1.set_fragment('#version 300 es\\n\\n#define PI 3.1415926538\\nprecision highp float;\\n\\nuniform float sigma;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\nuniform int pass;\\n\\nout vec4 FragColor;\\n\\nvec4 blur_pass(float sigma, int kernel_size, vec2 uv, bool horizontal)\\n{\\n float side = float(kernel_size / 2);\\n\\n vec2 direction_vector = horizontal ?\\n vec2(1.0, 0.0) / canvas_size.x :\\n vec2(0.0, 1.0) / canvas_size.y;\\n\\n vec3 delta_gauss;\\n delta_gauss.x = 1.0 / (sqrt(2.0 * PI) * sigma);\\n delta_gauss.y = exp(-0.5 / (sigma * sigma));\\n delta_gauss.z = delta_gauss.y * delta_gauss.y;\\n\\n vec4 avg = vec4(0.0, 0.0, 0.0, 0.0);\\n float sum = 0.0;\\n\\n vec4 pixel = texture(texture_sampler, uv);\\n avg += pixel * delta_gauss.x;\\n sum += delta_gauss.x;\\n delta_gauss.xy *= delta_gauss.yz;\\n\\n for ( float i = 1.0; i <= side; i++)\\n {\\n for ( float s = -1.0; s <= 1.0; s += 2.0 )\\n {\\n vec2 pos = uv + s * i * direction_vector;\\n pixel = texture(texture_sampler, pos);\\n avg += pixel * delta_gauss.x;\\n }\\n sum += 2.0 * delta_gauss.x;\\n delta_gauss.xy *= delta_gauss.yz;\\n }\\n\\n avg /= sum;\\n\\n return avg;\\n}\\n\\n\\nvoid main()\\n{\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n\\n int kernel_size = int(0.5 + 6.0 * sigma);\\n\\n const float multiplier = 0.25;\\n\\n if ( sigma == 0.0 )\\n FragColor = texture(texture_sampler, uv);\\n else if ( pass == 1 )\\n FragColor = blur_pass(sigma * multiplier, kernel_size, uv, true);\\n else if ( pass == 2 )\\n FragColor = blur_pass(sigma * multiplier, kernel_size, uv, false);\\n}') lottie_shader_41.add_pass(program_41_1, {\"pass\": [\"1i\", 1]}) lottie_shader_41.add_pass(program_41_1, {\"pass\": [\"1i\", 2]}) lottie_shader_41.add_pass_source('#version 300 es\\n\\nprecision highp float;\\n\\nuniform sampler2D original;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\nout vec4 FragColor;\\n\\nvec4 alpha_blend(vec4 top, vec4 bottom)\\n{\\n float comp_alpha = bottom.a * (1.0 - top.a);\\n vec4 result;\\n result.a = top.a + comp_alpha;\\n result.rgb = (top.rgb * top.a + bottom.rgb * comp_alpha) / result.a;\\n return result;\\n}\\n\\nvoid main()\\n{\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n\\n FragColor = alpha_blend(\\n texture(original, uv),\\n texture(texture_sampler, vec2(uv.x, 1.0 - uv.y))\\n );\\n}', {\"pass\": [\"1i\", 3]}) var lottie_player_41 = new PlaygroundPlayer( 41, 'playground_41_8', 'lottie_target_41', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 25, \"ef\": [{\"ty\": 2, \"v\": {\"k\": [0, 0, 0, 1], \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 128, \"a\": 0}}, {\"ty\": 1, \"v\": {\"k\": 135, \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 10, \"a\": 0}}, {\"ty\": 0, \"v\": {\"k\": 7, \"a\": 0}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { let shader = lottie_shader_41; lottie.layers[0].ef[0].ef[0].v.k[0] = data[\"Red\"]; lottie.layers[0].ef[0].ef[0].v.k[1] = data[\"Green\"]; lottie.layers[0].ef[0].ef[0].v.k[2] = data[\"Blue\"]; lottie.layers[0].ef[0].ef[1].v.k = data[\"Opacity\"]; lottie.layers[0].ef[0].ef[2].v.k = data[\"Angle\"]; lottie.layers[0].ef[0].ef[3].v.k = data[\"Distance\"]; lottie.layers[0].ef[0].ef[4].v.k = data[\"Blur\"]; shader.set_uniform(0, \"color\", \"4fv\", [data[\"Red\"], data[\"Green\"], data[\"Blue\"], data[\"Opacity\"]]); shader.set_uniform(0, \"angle\", \"1f\", data[\"Angle\"]); // 0.77 is just to take into account the canvas is 394 instead of 512 shader.set_uniform(0, \"distance\", \"1f\", data[\"Distance\"] * 0.77); shader.set_uniform(1, \"sigma\", \"1f\", data[\"Blur\"]); shader.set_uniform(2, \"sigma\", \"1f\", data[\"Blur\"]); shader.texture(\"/lottie-docs/examples/blep.png\").set_uniform(shader.passes[3].program, \"original\"); this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} ); #version 300 es #define PI 3.1415926538 uniform highp vec4 color; uniform mediump float angle; uniform mediump float distance; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; out highp vec4 FragColor; void main() { // Base pixel value highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); highp vec4 pixel = texture(texture_sampler, uv); // Pixel value at the given offset mediump float radians = -angle * PI / 180.0 + PI / 2.0; highp vec2 shadow_uv = vec2( (gl_FragCoord.x - distance * cos(radians)) / canvas_size.x, 1.0 - (gl_FragCoord.y - distance * sin(radians)) / canvas_size.y ); highp vec4 shadow_pixel = texture(texture_sampler, shadow_uv); // Colorize shadow highp vec4 shadow_color; if ( shadow_uv.x >= 0.0 && shadow_uv.x <= 1.0 && shadow_uv.y >= 0.0 && shadow_uv.y <= 1.0 ) { shadow_color = color; shadow_color.a = 1.0; shadow_color *= shadow_pixel.a * color.a / 255.0; } // Apply shadow below the base pixel FragColor = shadow_color; //pixel * pixel.a + shadow_color * (1.0 - pixel.a); } #version 300 es #define PI 3.1415926538 precision highp float; uniform float sigma; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; uniform int pass; out vec4 FragColor; vec4 blur_pass(float sigma, int kernel_size, vec2 uv, bool horizontal) { float side = float(kernel_size / 2); vec2 direction_vector = horizontal ? vec2(1.0, 0.0) / canvas_size.x : vec2(0.0, 1.0) / canvas_size.y; vec3 delta_gauss; delta_gauss.x = 1.0 / (sqrt(2.0 * PI) * sigma); delta_gauss.y = exp(-0.5 / (sigma * sigma)); delta_gauss.z = delta_gauss.y * delta_gauss.y; vec4 avg = vec4(0.0, 0.0, 0.0, 0.0); float sum = 0.0; vec4 pixel = texture(texture_sampler, uv); avg += pixel * delta_gauss.x; sum += delta_gauss.x; delta_gauss.xy *= delta_gauss.yz; for ( float i = 1.0; i <= side; i++) { for ( float s = -1.0; s <= 1.0; s += 2.0 ) { vec2 pos = uv + s * i * direction_vector; pixel = texture(texture_sampler, pos); avg += pixel * delta_gauss.x; } sum += 2.0 * delta_gauss.x; delta_gauss.xy *= delta_gauss.yz; } avg /= sum; return avg; } void main() { highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); int kernel_size = int(0.5 + 6.0 * sigma); const float multiplier = 0.25; if ( sigma == 0.0 ) FragColor = texture(texture_sampler, uv); else if ( pass == 1 ) FragColor = blur_pass(sigma * multiplier, kernel_size, uv, true); else if ( pass == 2 ) FragColor = blur_pass(sigma * multiplier, kernel_size, uv, false); } #version 300 es precision highp float; uniform sampler2D original; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; out vec4 FragColor; vec4 alpha_blend(vec4 top, vec4 bottom) { float comp_alpha = bottom.a * (1.0 - top.a); vec4 result; result.a = top.a + comp_alpha; result.rgb = (top.rgb * top.a + bottom.rgb * comp_alpha) / result.a; return result; } void main() { highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); FragColor = alpha_blend( texture(original, uv), texture(texture_sampler, vec2(uv.x, 1.0 - uv.y)) ); }","title":"Drop Shadow Effect"},{"location":"rendering/#pro-levels-effect","text":"In Black 0 In White 1 Gamma 1 Out Black 0 Out White Red 1 In Black 0 In White 1 Gamma 1 Out Black 0 Out White Green 1 In Black 0 In White 1 Gamma 1 Out Black 0 Out White Blue 1 In Black 0 In White 1 Gamma 1 Out Black 0 Out White 1 var lottie_shader_42 = new SinglePassShader(document.getElementById('lottie_target_42_canvas')); lottie_shader_42.set_fragment('#version 100\\nprecision highp float;\\n\\nuniform highp float composite_in_black;\\nuniform highp float composite_in_white;\\nuniform highp float composite_gamma;\\nuniform highp float composite_out_black;\\nuniform highp float composite_out_white;\\n\\nuniform highp float red_in_black;\\nuniform highp float red_in_white;\\nuniform highp float red_gamma;\\nuniform highp float red_out_black;\\nuniform highp float red_out_white;\\n\\nuniform highp float green_in_black;\\nuniform highp float green_in_white;\\nuniform highp float green_gamma;\\nuniform highp float green_out_black;\\nuniform highp float green_out_white;\\n\\nuniform highp float blue_in_black;\\nuniform highp float blue_in_white;\\nuniform highp float blue_gamma;\\nuniform highp float blue_out_black;\\nuniform highp float blue_out_white;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\n\\nfloat adjust_channel(float value, float in_black, float in_white, float gamma, float out_black, float out_white)\\n{\\n float in_delta = in_white - in_black;\\n float out_delta = out_white - out_black;\\n if ( in_delta == 0.0 )\\n return out_black;\\n\\n // Clamp to input range\\n if ( value <= in_black && value <= in_white )\\n return out_black;\\n\\n if ( value >= in_black && value >= in_white )\\n return out_white;\\n\\n // Apply adjustment\\n return out_black + out_delta * pow((value - in_black) / in_delta, 1.0 / gamma);\\n}\\n\\n\\nvoid main()\\n{\\n // Base pixel value\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n highp vec4 pixel = texture2D(texture_sampler, uv);\\n\\n // First Pass: composite\\n pixel.rgb = vec3(\\n adjust_channel(pixel.r, composite_in_black, composite_in_white, composite_gamma, composite_out_black, composite_out_white),\\n adjust_channel(pixel.g, composite_in_black, composite_in_white, composite_gamma, composite_out_black, composite_out_white),\\n adjust_channel(pixel.b, composite_in_black, composite_in_white, composite_gamma, composite_out_black, composite_out_white)\\n );\\n\\n // Second Pass: individual Channels\\n pixel.rgb = vec3(\\n adjust_channel(pixel.r, red_in_black, red_in_white, red_gamma, red_out_black, red_out_white),\\n adjust_channel(pixel.g, green_in_black, green_in_white, green_gamma, green_out_black, green_out_white),\\n adjust_channel(pixel.b, blue_in_black, blue_in_white, blue_gamma, blue_out_black, blue_out_white)\\n );\\n\\n gl_FragColor.rgb = pixel.rgb * pixel.a;\\n gl_FragColor.a = pixel.a;\\n}') var lottie_player_42 = new PlaygroundPlayer( 42, 'playground_42_21', 'lottie_target_42', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {\"a\": {\"k\": [0, 0], \"a\": 0}, \"p\": {\"k\": [0, 0], \"a\": 0}, \"s\": {\"k\": [100, 100], \"a\": 0}, \"r\": {\"k\": 0, \"a\": 0}, \"o\": {\"k\": 100, \"a\": 0}, \"sk\": {\"k\": 0, \"a\": 0}, \"sa\": {\"k\": 0, \"a\": 0}}, \"ao\": 0, \"ip\": 0, \"op\": 60, \"st\": 0, \"bm\": 0, \"ind\": 0, \"ef\": [{\"ty\": 24, \"ef\": [{\"ty\": 7, \"v\": {\"nm\": \"00 Dropdown\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"01\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"02\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"comp_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"08\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"09 slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"r_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"r_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"r_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"r_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"r_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"15 slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"16 slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"g_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"g_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"g_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"g_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"g_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"22\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"23\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"b_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"b_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"b_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"b_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"b_outwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"29\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"a_inblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"a_inwhite slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"a_gamma slider\", \"a\": 0, \"k\": 1}}, {\"ty\": 0, \"v\": {\"nm\": \"a_outblack slider\", \"a\": 0, \"k\": 0}}, {\"ty\": 0, \"v\": {\"nm\": \"a_outwhite slider\", \"a\": 0, \"k\": 1}}]}], \"refId\": \"blep\"}]}, function (lottie, data) { let shader = lottie_shader_42; lottie.layers[0].ef[0].ef[3].v.k = data[\"Composite In Black\"]; lottie.layers[0].ef[0].ef[4].v.k = data[\"Composite In White\"]; lottie.layers[0].ef[0].ef[5].v.k = data[\"Composite Gamma\"]; lottie.layers[0].ef[0].ef[6].v.k = data[\"Composite Out Black\"]; lottie.layers[0].ef[0].ef[7].v.k = data[\"Composite Out White\"]; lottie.layers[0].ef[0].ef[10].v.k = data[\"Red In Black\"]; lottie.layers[0].ef[0].ef[11].v.k = data[\"Red In White\"]; lottie.layers[0].ef[0].ef[12].v.k = data[\"Red Gamma\"]; lottie.layers[0].ef[0].ef[13].v.k = data[\"Red Out Black\"]; lottie.layers[0].ef[0].ef[14].v.k = data[\"Red Out White\"]; lottie.layers[0].ef[0].ef[17].v.k = data[\"Green In Black\"]; lottie.layers[0].ef[0].ef[18].v.k = data[\"Green In White\"]; lottie.layers[0].ef[0].ef[19].v.k = data[\"Green Gamma\"]; lottie.layers[0].ef[0].ef[20].v.k = data[\"Green Out Black\"]; lottie.layers[0].ef[0].ef[21].v.k = data[\"Green Out White\"]; lottie.layers[0].ef[0].ef[24].v.k = data[\"Blue In Black\"]; lottie.layers[0].ef[0].ef[25].v.k = data[\"Blue In White\"]; lottie.layers[0].ef[0].ef[26].v.k = data[\"Blue Gamma\"]; lottie.layers[0].ef[0].ef[27].v.k = data[\"Blue Out Black\"]; lottie.layers[0].ef[0].ef[28].v.k = data[\"Blue Out White\"]; shader.set_uniform(\"composite_in_black\", \"1f\", data[\"Composite In Black\"]); shader.set_uniform(\"composite_in_white\", \"1f\", data[\"Composite In White\"]); shader.set_uniform(\"composite_gamma\", \"1f\", data[\"Composite Gamma\"]); shader.set_uniform(\"composite_out_black\", \"1f\", data[\"Composite Out Black\"]); shader.set_uniform(\"composite_out_white\", \"1f\", data[\"Composite Out White\"]); shader.set_uniform(\"red_in_black\", \"1f\", data[\"Red In Black\"]); shader.set_uniform(\"red_in_white\", \"1f\", data[\"Red In White\"]); shader.set_uniform(\"red_gamma\", \"1f\", data[\"Red Gamma\"]); shader.set_uniform(\"red_out_black\", \"1f\", data[\"Red Out Black\"]); shader.set_uniform(\"red_out_white\", \"1f\", data[\"Red Out White\"]); shader.set_uniform(\"green_in_black\", \"1f\", data[\"Green In Black\"]); shader.set_uniform(\"green_in_white\", \"1f\", data[\"Green In White\"]); shader.set_uniform(\"green_gamma\", \"1f\", data[\"Green Gamma\"]); shader.set_uniform(\"green_out_black\", \"1f\", data[\"Green Out Black\"]); shader.set_uniform(\"green_out_white\", \"1f\", data[\"Green Out White\"]); shader.set_uniform(\"blue_in_black\", \"1f\", data[\"Blue In Black\"]); shader.set_uniform(\"blue_in_white\", \"1f\", data[\"Blue In White\"]); shader.set_uniform(\"blue_gamma\", \"1f\", data[\"Blue Gamma\"]); shader.set_uniform(\"blue_out_black\", \"1f\", data[\"Blue Out Black\"]); shader.set_uniform(\"blue_out_white\", \"1f\", data[\"Blue Out White\"]); this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} ); #version 100 precision highp float; uniform highp float composite_in_black; uniform highp float composite_in_white; uniform highp float composite_gamma; uniform highp float composite_out_black; uniform highp float composite_out_white; uniform highp float red_in_black; uniform highp float red_in_white; uniform highp float red_gamma; uniform highp float red_out_black; uniform highp float red_out_white; uniform highp float green_in_black; uniform highp float green_in_white; uniform highp float green_gamma; uniform highp float green_out_black; uniform highp float green_out_white; uniform highp float blue_in_black; uniform highp float blue_in_white; uniform highp float blue_gamma; uniform highp float blue_out_black; uniform highp float blue_out_white; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; float adjust_channel(float value, float in_black, float in_white, float gamma, float out_black, float out_white) { float in_delta = in_white - in_black; float out_delta = out_white - out_black; if ( in_delta == 0.0 ) return out_black; // Clamp to input range if ( value <= in_black && value <= in_white ) return out_black; if ( value >= in_black && value >= in_white ) return out_white; // Apply adjustment return out_black + out_delta * pow((value - in_black) / in_delta, 1.0 / gamma); } void main() { // Base pixel value highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); highp vec4 pixel = texture2D(texture_sampler, uv); // First Pass: composite pixel.rgb = vec3( adjust_channel(pixel.r, composite_in_black, composite_in_white, composite_gamma, composite_out_black, composite_out_white), adjust_channel(pixel.g, composite_in_black, composite_in_white, composite_gamma, composite_out_black, composite_out_white), adjust_channel(pixel.b, composite_in_black, composite_in_white, composite_gamma, composite_out_black, composite_out_white) ); // Second Pass: individual Channels pixel.rgb = vec3( adjust_channel(pixel.r, red_in_black, red_in_white, red_gamma, red_out_black, red_out_white), adjust_channel(pixel.g, green_in_black, green_in_white, green_gamma, green_out_black, green_out_white), adjust_channel(pixel.b, blue_in_black, blue_in_white, blue_gamma, blue_out_black, blue_out_white) ); gl_FragColor.rgb = pixel.rgb * pixel.a; gl_FragColor.a = pixel.a; }","title":"Pro Levels Effect"},{"location":"rendering/#matte3","text":"Channel Red Green Blue Alpha Luma Hue Lightness Saturation Full Off Invert Stretch To Fit Show Mask Premultiply Mask var lottie_shader_43 = new SinglePassShader(document.getElementById('lottie_target_43_canvas')); lottie_shader_43.set_fragment('#version 100\\nprecision highp float;\\n\\nuniform int channel;\\nuniform int invert;\\nuniform int premultiply_mask;\\nuniform int show_mask;\\nuniform sampler2D mask_layer;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\nhighp vec3 hsl(vec4 c)\\n{\\n float maxc = max(c.r, max(c.g, c.b));\\n float minc = min(c.r, min(c.g, c.b));\\n float h = 0.0;\\n float s = 0.0;\\n float l = (maxc + minc) / 2.0;\\n\\n if ( maxc != minc)\\n {\\n float d = maxc - minc;\\n s = l > 0.5 ? d / (2.0 - d) : d / (maxc + minc);\\n if ( maxc == c.r )\\n h = (c.g - c.b) / d + (c.g < c.b ? 6.0 : 0.0);\\n else if ( maxc == c.g )\\n h = (c.b - c.r) / d + 2.0;\\n else if ( maxc == c.b )\\n h = (c.r - c.g) / d + 4.0;\\n\\n h /= 6.0;\\n }\\n\\n return vec3(h, s, l);\\n}\\n\\nhighp float opacity(vec4 pixel, int channel, int invert, int premultiply)\\n{\\n if ( premultiply == 1 )\\n pixel *= pixel.a;\\n\\n highp float opacity;\\n\\n if ( channel == 1 )\\n opacity = pixel.r;\\n else if ( channel == 2 )\\n opacity = pixel.g;\\n else if ( channel == 3 )\\n opacity = pixel.b;\\n else if ( channel == 4 )\\n opacity = pixel.a;\\n else if ( channel == 5 )\\n opacity = sqrt(pixel.r * pixel.r * 0.299 + pixel.g * pixel.g * 0.587 + pixel.b * pixel.b * 0.114);\\n else if ( channel == 6 )\\n opacity = hsl(pixel).x;\\n else if ( channel == 7 )\\n opacity = hsl(pixel).z;\\n else if ( channel == 8 )\\n opacity = hsl(pixel).y;\\n else if ( channel == 9 )\\n opacity = 1.0;\\n else if ( channel == 10 )\\n opacity = 0.0;\\n\\n\\n return invert == 1 ? 1.0 - opacity : opacity;\\n}\\n\\nvec4 alpha_blend(vec4 top, vec4 bottom)\\n{\\n float comp_alpha = bottom.a * (1.0 - top.a);\\n vec4 result;\\n result.a = top.a + comp_alpha;\\n result.rgb = (top.rgb * top.a + bottom.rgb * comp_alpha) / result.a;\\n return result;\\n}\\n\\nvoid main()\\n{\\n // Base pixel value\\n highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y);\\n highp vec4 pixel = texture2D(texture_sampler, uv);\\n\\n highp vec4 mask = texture2D(mask_layer, uv);\\n\\n\\n gl_FragColor.a = pixel.a * opacity(mask, channel, invert, premultiply_mask);\\n gl_FragColor.rgb = pixel.rgb * gl_FragColor.a;\\n\\n if ( show_mask == 1 )\\n gl_FragColor = alpha_blend(gl_FragColor, mask);\\n}') var lottie_player_43 = new PlaygroundPlayer( 43, 'playground_43_6', 'lottie_target_43', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [{\"id\": \"blep\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}, {\"id\": \"thumbs-up\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/examples/thumbs-up.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {}, \"ip\": 0, \"op\": 60, \"st\": 0, \"ind\": 0, \"ef\": [{\"ty\": 28, \"nm\": \"Set Matte\", \"np\": 8, \"mn\": \"ADBE Set Matte3\", \"ix\": 1, \"en\": 1, \"ef\": [{\"ty\": 10, \"nm\": \"Take Matte From Layer\", \"mn\": \"ADBE Set Matte3-0001\", \"ix\": 1, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 1}}, {\"ty\": 7, \"nm\": \"Use For Matte\", \"mn\": \"ADBE Set Matte3-0002\", \"ix\": 2, \"v\": {\"a\": 0, \"k\": 4, \"ix\": 2}}, {\"ty\": 7, \"nm\": \"Invert Matte\", \"mn\": \"ADBE Set Matte3-0003\", \"ix\": 3, \"v\": {\"a\": 0, \"k\": 0, \"ix\": 3}}, {\"ty\": 7, \"nm\": \"If Layer Sizes Differ\", \"mn\": \"ADBE Set Matte3-0004\", \"ix\": 4, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 4}}, {\"ty\": 7, \"nm\": \"Composite Matte with Original\", \"mn\": \"ADBE Set Matte3-0005\", \"ix\": 5, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 5}}, {\"ty\": 7, \"nm\": \"Premultiply Matte Layer\", \"mn\": \"ADBE Set Matte3-0006\", \"ix\": 6, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 6}}]}], \"refId\": \"blep\"}, {\"ddd\": 0, \"ty\": 2, \"sr\": 1, \"ks\": {}, \"ip\": 0, \"op\": 60, \"st\": 0, \"ind\": 1, \"refId\": \"thumbs-up\"}]}, function (lottie, data) { let shader = lottie_shader_43; lottie.layers[0].ef[0].ef[1].v.k = Number(data[\"Channel\"]); lottie.layers[0].ef[0].ef[2].v.k = Number(data[\"Invert\"]); lottie.layers[0].ef[0].ef[3].v.k = Number(data[\"Stretch To Fit\"]); lottie.layers[0].ef[0].ef[4].v.k = Number(data[\"Show Mask\"]); lottie.layers[0].ef[0].ef[5].v.k = Number(data[\"Premultiply Mask\"]); shader.set_uniform(\"channel\", \"1i\", Number(data[\"Channel\"])); shader.set_uniform(\"invert\", \"1i\", Number(data[\"Invert\"])); shader.set_uniform(\"show_mask\", \"1i\", Number(data[\"Show Mask\"])); shader.set_uniform(\"premultiply_mask\", \"1i\", Number(data[\"Premultiply Mask\"])); shader.texture(\"/lottie-docs/examples/thumbs-up.png\").set_uniform(shader.program, \"mask_layer\"); this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} ); #version 100 precision highp float; uniform int channel; uniform int invert; uniform int premultiply_mask; uniform int show_mask; uniform sampler2D mask_layer; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; highp vec3 hsl(vec4 c) { float maxc = max(c.r, max(c.g, c.b)); float minc = min(c.r, min(c.g, c.b)); float h = 0.0; float s = 0.0; float l = (maxc + minc) / 2.0; if ( maxc != minc) { float d = maxc - minc; s = l > 0.5 ? d / (2.0 - d) : d / (maxc + minc); if ( maxc == c.r ) h = (c.g - c.b) / d + (c.g < c.b ? 6.0 : 0.0); else if ( maxc == c.g ) h = (c.b - c.r) / d + 2.0; else if ( maxc == c.b ) h = (c.r - c.g) / d + 4.0; h /= 6.0; } return vec3(h, s, l); } highp float opacity(vec4 pixel, int channel, int invert, int premultiply) { if ( premultiply == 1 ) pixel *= pixel.a; highp float opacity; if ( channel == 1 ) opacity = pixel.r; else if ( channel == 2 ) opacity = pixel.g; else if ( channel == 3 ) opacity = pixel.b; else if ( channel == 4 ) opacity = pixel.a; else if ( channel == 5 ) opacity = sqrt(pixel.r * pixel.r * 0.299 + pixel.g * pixel.g * 0.587 + pixel.b * pixel.b * 0.114); else if ( channel == 6 ) opacity = hsl(pixel).x; else if ( channel == 7 ) opacity = hsl(pixel).z; else if ( channel == 8 ) opacity = hsl(pixel).y; else if ( channel == 9 ) opacity = 1.0; else if ( channel == 10 ) opacity = 0.0; return invert == 1 ? 1.0 - opacity : opacity; } vec4 alpha_blend(vec4 top, vec4 bottom) { float comp_alpha = bottom.a * (1.0 - top.a); vec4 result; result.a = top.a + comp_alpha; result.rgb = (top.rgb * top.a + bottom.rgb * comp_alpha) / result.a; return result; } void main() { // Base pixel value highp vec2 uv = vec2(gl_FragCoord.x / canvas_size.x, gl_FragCoord.y / canvas_size.y); highp vec4 pixel = texture2D(texture_sampler, uv); highp vec4 mask = texture2D(mask_layer, uv); gl_FragColor.a = pixel.a * opacity(mask, channel, invert, premultiply_mask); gl_FragColor.rgb = pixel.rgb * gl_FragColor.a; if ( show_mask == 1 ) gl_FragColor = alpha_blend(gl_FragColor, mask); }","title":"Matte3"},{"location":"rendering/#bulge","text":"Center X 286 Center Y 277 Radius X 197 Radius Y 179 Height 1.9 var lottie_shader_44 = new SinglePassShader(document.getElementById('lottie_target_44_canvas')); lottie_shader_44.set_fragment('#version 100\\n\\nprecision highp float;\\n\\nuniform vec2 center;\\nuniform vec2 radius;\\nuniform float height;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\nvec2 normalize_uv(vec2 coord)\\n{\\n return vec2(coord.x / canvas_size.x, coord.y / canvas_size.y);\\n}\\n\\nvec2 exponential_displacement(vec2 uv, float magnitude)\\n{\\n return uv * pow(dot(uv, uv), magnitude) - uv;\\n}\\n\\n\\nvec2 spherical_displacement(vec2 uv, float magnitude)\\n{\\n float radius = (1.0 + magnitude) / (2.0 * sqrt(magnitude));\\n\\n\\n float arc_ratio = asin(length(uv) / radius) / asin(1.0 / radius);\\n return normalize(uv) * arc_ratio - uv;\\n}\\n\\nvec2 displace(vec2 owo)\\n{\\n float t = dot(owo, owo);\\n if (t >= 1.0)\\n return owo;\\n\\n float magnitude = abs(height);\\n // We modify the magniture to more closely match AE\\n magnitude = (2.0/(1.0+exp(-3.0*magnitude))-1.0) * (0.23 * magnitude + 0.14);\\n // If the above is too expensive, you can use this instead:\\n // magnitude = magnitude * 0.275;\\n // Both of the above were derived by interpolating sample points\\n\\n float sign = height > 0.0 ? 1.0 : -1.0;\\n vec2 displacement =\\n exponential_displacement(owo, magnitude) +\\n spherical_displacement(owo, magnitude)\\n ;\\n return owo + displacement * magnitude * sign;\\n\\n}\\n\\nvoid main()\\n{\\n highp vec2 uv = normalize_uv(gl_FragCoord.xy);\\n vec2 norm_center = normalize_uv(center);\\n vec2 norm_radius = normalize_uv(radius);\\n\\n // forward transform\\n uv = (uv - norm_center) / norm_radius;\\n //displace\\n uv = displace(uv);\\n // backward transform\\n uv = uv * norm_radius + norm_center;\\n\\n gl_FragColor = texture2D(texture_sampler, uv);\\n}') var lottie_player_44 = new PlaygroundPlayer( 44, 'playground_44_6', 'lottie_target_44', {\"v\": \"5.9.0\", \"fr\": 60, \"ip\": 0, \"op\": 1800, \"w\": 512, \"h\": 512, \"nm\": \"Comp 1\", \"ddd\": 0, \"assets\": [{\"id\": \"image_0\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ind\": 1, \"ty\": 2, \"nm\": \"blep.png\", \"cl\": \"png\", \"refId\": \"image_0\", \"sr\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100, \"ix\": 11}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 10}, \"p\": {\"a\": 0, \"k\": [256, 256, 0], \"ix\": 2, \"l\": 2}, \"a\": {\"a\": 0, \"k\": [256, 256, 0], \"ix\": 1, \"l\": 2}, \"s\": {\"a\": 0, \"k\": [100, 100, 100], \"ix\": 6, \"l\": 2}}, \"ao\": 0, \"ef\": [{\"ty\": 5, \"nm\": \"Bulge\", \"np\": 9, \"mn\": \"ADBE Bulge\", \"ix\": 1, \"en\": 1, \"ef\": [{\"ty\": 0, \"nm\": \"Horizontal Radius\", \"mn\": \"ADBE Bulge-0001\", \"ix\": 1, \"v\": {\"a\": 0, \"k\": 197, \"ix\": 1}}, {\"ty\": 0, \"nm\": \"Vertical Radius\", \"mn\": \"ADBE Bulge-0002\", \"ix\": 2, \"v\": {\"a\": 0, \"k\": 179, \"ix\": 2}}, {\"ty\": 3, \"nm\": \"Bulge Center\", \"mn\": \"ADBE Bulge-0003\", \"ix\": 3, \"v\": {\"a\": 0, \"k\": [286, 277], \"ix\": 3}}, {\"ty\": 0, \"nm\": \"Bulge Height\", \"mn\": \"ADBE Bulge-0004\", \"ix\": 4, \"v\": {\"a\": 0, \"k\": 1.85, \"ix\": 4}}, {\"ty\": 0, \"nm\": \"Taper Radius\", \"mn\": \"ADBE Bulge-0005\", \"ix\": 5, \"v\": {\"a\": 0, \"k\": 0, \"ix\": 5}}, {\"ty\": 7, \"nm\": \"Antialiasing (Best Qual Only)\", \"mn\": \"ADBE Bulge-0006\", \"ix\": 6, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 6}}, {\"ty\": 7, \"nm\": \"Pinning\", \"mn\": \"ADBE Bulge-0007\", \"ix\": 7, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 7}}]}], \"ip\": 0, \"op\": 1800, \"st\": 0, \"bm\": 0}], \"markers\": []}, function (lottie, data) { let shader = lottie_shader_44; lottie.layers[0].ef[0].ef[0].v.k = data[\"Radius X\"]; lottie.layers[0].ef[0].ef[1].v.k = data[\"Radius Y\"]; lottie.layers[0].ef[0].ef[2].v.k = [data[\"Center X\"], data[\"Center Y\"]]; lottie.layers[0].ef[0].ef[3].v.k = data[\"Height\"]; shader.set_uniform(\"center\", \"2fv\", [data[\"Center X\"] * 0.77, data[\"Center Y\"] * 0.77]); shader.set_uniform(\"radius\", \"2fv\", [data[\"Radius X\"] * 0.77, data[\"Radius Y\"] * 0.77]); shader.set_uniform(\"height\", \"1f\", data[\"Height\"]); this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} ); #version 100 precision highp float; uniform vec2 center; uniform vec2 radius; uniform float height; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; vec2 normalize_uv(vec2 coord) { return vec2(coord.x / canvas_size.x, coord.y / canvas_size.y); } vec2 exponential_displacement(vec2 uv, float magnitude) { return uv * pow(dot(uv, uv), magnitude) - uv; } vec2 spherical_displacement(vec2 uv, float magnitude) { float radius = (1.0 + magnitude) / (2.0 * sqrt(magnitude)); float arc_ratio = asin(length(uv) / radius) / asin(1.0 / radius); return normalize(uv) * arc_ratio - uv; } vec2 displace(vec2 owo) { float t = dot(owo, owo); if (t >= 1.0) return owo; float magnitude = abs(height); // We modify the magniture to more closely match AE magnitude = (2.0/(1.0+exp(-3.0*magnitude))-1.0) * (0.23 * magnitude + 0.14); // If the above is too expensive, you can use this instead: // magnitude = magnitude * 0.275; // Both of the above were derived by interpolating sample points float sign = height > 0.0 ? 1.0 : -1.0; vec2 displacement = exponential_displacement(owo, magnitude) + spherical_displacement(owo, magnitude) ; return owo + displacement * magnitude * sign; } void main() { highp vec2 uv = normalize_uv(gl_FragCoord.xy); vec2 norm_center = normalize_uv(center); vec2 norm_radius = normalize_uv(radius); // forward transform uv = (uv - norm_center) / norm_radius; //displace uv = displace(uv); // backward transform uv = uv * norm_radius + norm_center; gl_FragColor = texture2D(texture_sampler, uv); }","title":"Bulge"},{"location":"rendering/#wave-warp","text":"This effect is animated by default, so it has a \"time\" slider (in seconds). Shape Sine Square Triangle Sawtooth Circle Semicircle Uncircle Noise Smooth noise Amplitude 10 Wavelength 40 Direction 90 Phase 0 Speed 1 Time 0 var lottie_shader_45 = new SinglePassShader(document.getElementById('lottie_target_45_canvas')); lottie_shader_45.set_fragment('#version 100\\n\\n#define PI 3.1415926538\\n#define TAU 6.283185307\\n\\nprecision highp float;\\n\\nuniform int shape;\\nuniform float amplitude;\\nuniform float wavelength;\\nuniform float angle;\\nuniform float speed;\\nuniform float phase;\\nuniform float time;\\n\\nuniform mediump vec2 canvas_size;\\nuniform sampler2D texture_sampler;\\n\\n\\nvec2 normalize_uv(vec2 coord)\\n{\\n return vec2(coord.x / canvas_size.x, coord.y / canvas_size.y);\\n}\\n\\nfloat clamp_angle(float angle)\\n{\\n return mod(angle, TAU);\\n}\\n\\nvec2 project(vec2 a , vec2 b)\\n{\\n return dot(a, b) / dot(b, b) * b;\\n}\\n\\nfloat semicircle(float x)\\n{\\n return sqrt(1.0 - pow(clamp_angle(x) / PI - 1.0, 2.0));\\n}\\n\\n// Adapted from http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\\nhighp float noise(float x)\\n{\\n highp float a = 12.9898;\\n highp float b = 78.233;\\n highp float c = 43758.5453;\\n highp float dt = x * a;\\n highp float sn = mod(dt, PI);\\n return fract(sin(sn) * c) * 2.0 - 1.0;\\n}\\n\\n// Interpolate between two random points\\nfloat smooth_noise(float x)\\n{\\n float x_fract = fract(x);\\n float x_int = x - x_fract;\\n float n1 = noise(x_int);\\n float n2 = noise(x_int + 1.0);\\n return (n1 * (1.0 - x_fract) + n2 * x_fract);\\n}\\n\\nvec2 displace(vec2 uv)\\n{\\n float rad = angle / 180.0 * PI;\\n vec2 normal = vec2(cos(rad), sin(rad));\\n rad -= PI /2.0;\\n vec2 direction = vec2(cos(rad), sin(rad));\\n float x = length(project(uv, direction));\\n\\n x = x / wavelength * PI - time * speed * TAU + phase / 180.0 * PI;\\n\\n\\n float y;\\n\\n if ( shape == 1 ) // sine\\n y = sin(x);\\n else if ( shape == 2 ) // square\\n y = clamp_angle(x) < PI ? 1.0 : -1.0;\\n else if ( shape == 3 ) // triangle\\n y = 1.0 - abs(clamp_angle(x) - PI) / PI * 2.0;\\n else if ( shape == 4 ) // sawtooth\\n y = 1.0 - clamp_angle(x) / PI;\\n else if ( shape == 5 ) // circle\\n y = sign(clamp_angle(x) - PI) * semicircle(2.0 * x);\\n else if ( shape == 6 ) // semi circle\\n y = 2.0 * semicircle(x) - 1.0;\\n else if ( shape == 7 ) // uncircle\\n y = sign(clamp_angle(-x) - PI) * (semicircle(2.0 * x) - 1.0);\\n else if ( shape == 8 ) // noise\\n y = noise(x);\\n else if ( shape == 9 ) // smooth noise\\n y = smooth_noise(x * 4.0) ;\\n\\n return uv + y * normal * amplitude;\\n\\n}\\n\\nvoid main()\\n{\\n vec2 uv = displace(gl_FragCoord.xy);\\n gl_FragColor = texture2D(texture_sampler, normalize_uv(uv));\\n}') var lottie_player_45 = new PlaygroundPlayer( 45, 'playground_45_8', 'lottie_target_45', {\"v\": \"5.9.0\", \"fr\": 60, \"ip\": 0, \"op\": 1800, \"w\": 512, \"h\": 512, \"nm\": \"Comp 1\", \"ddd\": 0, \"assets\": [{\"id\": \"image_0\", \"h\": 512, \"w\": 512, \"p\": \"/lottie-docs/static/examples/blep.png\", \"u\": \"\", \"e\": 1}], \"layers\": [{\"ddd\": 0, \"ind\": 1, \"ty\": 2, \"nm\": \"blep.png\", \"cl\": \"png\", \"refId\": \"image_0\", \"sr\": 1, \"ks\": {\"o\": {\"a\": 0, \"k\": 100, \"ix\": 11}, \"r\": {\"a\": 0, \"k\": 0, \"ix\": 10}, \"p\": {\"a\": 0, \"k\": [256, 256, 0], \"ix\": 2, \"l\": 2}, \"a\": {\"a\": 0, \"k\": [256, 256, 0], \"ix\": 1, \"l\": 2}, \"s\": {\"a\": 0, \"k\": [100, 100, 100], \"ix\": 6, \"l\": 2}}, \"ao\": 0, \"ef\": [{\"ty\": 5, \"nm\": \"Wave Warp\", \"np\": 10, \"mn\": \"ADBE Wave Warp\", \"ix\": 1, \"en\": 1, \"ef\": [{\"ty\": 7, \"nm\": \"Wave Type\", \"mn\": \"ADBE Wave Warp-0001\", \"ix\": 1, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 1}}, {\"ty\": 0, \"nm\": \"Wave Height\", \"mn\": \"ADBE Wave Warp-0002\", \"ix\": 2, \"v\": {\"a\": 0, \"k\": 10, \"ix\": 2}}, {\"ty\": 0, \"nm\": \"Wave Width\", \"mn\": \"ADBE Wave Warp-0003\", \"ix\": 3, \"v\": {\"a\": 0, \"k\": 64, \"ix\": 3}}, {\"ty\": 0, \"nm\": \"Direction\", \"mn\": \"ADBE Wave Warp-0004\", \"ix\": 4, \"v\": {\"a\": 0, \"k\": 90, \"ix\": 4}}, {\"ty\": 7, \"nm\": \"Wave Speed\", \"mn\": \"ADBE Wave Warp-0005\", \"ix\": 5, \"v\": {\"a\": 0, \"k\": 2, \"ix\": 5}}, {\"ty\": 7, \"nm\": \"Pinning\", \"mn\": \"ADBE Wave Warp-0006\", \"ix\": 6, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 6}}, {\"ty\": 0, \"nm\": \"Phase\", \"mn\": \"ADBE Wave Warp-0007\", \"ix\": 7, \"v\": {\"a\": 0, \"k\": 0, \"ix\": 7}}, {\"ty\": 7, \"nm\": \"Antialiasing (Best Quality)\", \"mn\": \"ADBE Wave Warp-0008\", \"ix\": 8, \"v\": {\"a\": 0, \"k\": 1, \"ix\": 8}}]}], \"ip\": 0, \"op\": 1800, \"st\": 0, \"bm\": 0}], \"markers\": []}, function (lottie, data) { let shader = lottie_shader_45; lottie.layers[0].ef[0].ef[0].v.k = Number(data[\"Shape\"]); lottie.layers[0].ef[0].ef[1].v.k = data[\"Amplitude\"]; lottie.layers[0].ef[0].ef[2].v.k = data[\"Wavelength\"]; lottie.layers[0].ef[0].ef[3].v.k = data[\"Direction\"]; lottie.layers[0].ef[0].ef[5].v.k = data[\"Speed\"]; // 5 \"pinning\" not implemented lottie.layers[0].ef[0].ef[6].v.k = data[\"Phase\"]; // & \"antialiasing\" unused shader.set_uniform(\"shape\", \"1i\", Number(data[\"Shape\"])); shader.set_uniform(\"amplitude\", \"1f\", data[\"Amplitude\"]); shader.set_uniform(\"wavelength\", \"1f\", data[\"Wavelength\"]); shader.set_uniform(\"angle\", \"1f\", data[\"Direction\"]); shader.set_uniform(\"phase\", \"1f\", data[\"Phase\"]); shader.set_uniform(\"speed\", \"1f\", data[\"Speed\"]); shader.set_uniform(\"time\", \"1f\", data[\"Time\"]); this.json_viewer_contents = lottie.layers[0].ef[0]; shader.render(); }, {} ); #version 100 #define PI 3.1415926538 #define TAU 6.283185307 precision highp float; uniform int shape; uniform float amplitude; uniform float wavelength; uniform float angle; uniform float speed; uniform float phase; uniform float time; uniform mediump vec2 canvas_size; uniform sampler2D texture_sampler; vec2 normalize_uv(vec2 coord) { return vec2(coord.x / canvas_size.x, coord.y / canvas_size.y); } float clamp_angle(float angle) { return mod(angle, TAU); } vec2 project(vec2 a , vec2 b) { return dot(a, b) / dot(b, b) * b; } float semicircle(float x) { return sqrt(1.0 - pow(clamp_angle(x) / PI - 1.0, 2.0)); } // Adapted from http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/ highp float noise(float x) { highp float a = 12.9898; highp float b = 78.233; highp float c = 43758.5453; highp float dt = x * a; highp float sn = mod(dt, PI); return fract(sin(sn) * c) * 2.0 - 1.0; } // Interpolate between two random points float smooth_noise(float x) { float x_fract = fract(x); float x_int = x - x_fract; float n1 = noise(x_int); float n2 = noise(x_int + 1.0); return (n1 * (1.0 - x_fract) + n2 * x_fract); } vec2 displace(vec2 uv) { float rad = angle / 180.0 * PI; vec2 normal = vec2(cos(rad), sin(rad)); rad -= PI /2.0; vec2 direction = vec2(cos(rad), sin(rad)); float x = length(project(uv, direction)); x = x / wavelength * PI - time * speed * TAU + phase / 180.0 * PI; float y; if ( shape == 1 ) // sine y = sin(x); else if ( shape == 2 ) // square y = clamp_angle(x) < PI ? 1.0 : -1.0; else if ( shape == 3 ) // triangle y = 1.0 - abs(clamp_angle(x) - PI) / PI * 2.0; else if ( shape == 4 ) // sawtooth y = 1.0 - clamp_angle(x) / PI; else if ( shape == 5 ) // circle y = sign(clamp_angle(x) - PI) * semicircle(2.0 * x); else if ( shape == 6 ) // semi circle y = 2.0 * semicircle(x) - 1.0; else if ( shape == 7 ) // uncircle y = sign(clamp_angle(-x) - PI) * (semicircle(2.0 * x) - 1.0); else if ( shape == 8 ) // noise y = noise(x); else if ( shape == 9 ) // smooth noise y = smooth_noise(x * 4.0) ; return uv + y * normal * amplitude; } void main() { vec2 uv = displace(gl_FragCoord.xy); gl_FragColor = texture2D(texture_sampler, normalize_uv(uv)); }","title":"Wave Warp"},{"location":"schema/","text":"JSON Schema This page shows a formatted version of the JSON schema, you can click on highlighted objects to get a link to that section of the schema. You can also click on $ref values to jump to the relevant section. If you want you can also view the raw schema file . { \"$schema\" : \"https://json-schema.org/draft/2020-12/schema\" , \"$id\" : \"https://lottiefiles.github.io/lottie-docs/schema/lottie.schema.json\" , \"$ref\" : \"#/$defs/composition/animation\" , \"$defs\" : { \"assets\" : { \"image\" : { \"type\" : \"object\" , \"title\" : \"Image\" , \"description\" : \"Asset containing an image that can be referenced by layers.\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/assets/file-asset\" }, { \"$ref\" : \"#/$defs/helpers/slottable-object\" }, { \"type\" : \"object\" , \"properties\" : { \"w\" : { \"title\" : \"Width\" , \"description\" : \"Width of the image\" , \"type\" : \"number\" }, \"h\" : { \"title\" : \"Height\" , \"description\" : \"Height of the image\" , \"type\" : \"number\" }, \"t\" : { \"title\" : \"Type\" , \"description\" : \"Marks as part of an image sequence if present\" , \"type\" : \"string\" , \"const\" : \"seq\" } }, \"if\" : { \"required\" : [ \"sid\" ] }, \"else\" : { \"required\" : [ \"w\" , \"h\" , \"p\" ] } } ] }, \"asset\" : { \"type\" : \"object\" , \"title\" : \"Asset\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"id\" : { \"title\" : \"ID\" , \"description\" : \"Unique identifier used by layers when referencing this asset\" , \"type\" : \"string\" } }, \"required\" : [ \"id\" ] } ] }, \"data-source\" : { \"type\" : \"object\" , \"title\" : \"Data source\" , \"description\" : \"External data source, usually a JSON file\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/assets/file-asset\" }, { \"type\" : \"object\" , \"properties\" : { \"t\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 3 } }, \"required\" : [ \"t\" ] } ] }, \"all-assets\" : { \"oneOf\" : [ { \"$ref\" : \"#/$defs/assets/precomposition\" }, { \"$ref\" : \"#/$defs/assets/image\" }, { \"$ref\" : \"#/$defs/assets/data-source\" }, { \"$ref\" : \"#/$defs/assets/sound\" } ] }, \"file-asset\" : { \"type\" : \"object\" , \"title\" : \"File Asset\" , \"description\" : \"Asset referencing a file\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/assets/asset\" }, { \"type\" : \"object\" , \"properties\" : { \"p\" : { \"title\" : \"File Name\" , \"description\" : \"Name of the asset file or a data url\" , \"type\" : \"string\" }, \"u\" : { \"title\" : \"File Path\" , \"description\" : \"Path to the asset file\" , \"type\" : \"string\" }, \"e\" : { \"title\" : \"Embedded\" , \"description\" : \"If '1', 'p' is a Data URL\" , \"$ref\" : \"#/$defs/values/int-boolean\" } }, \"if\" : { \"properties\" : { \"e\" : { \"const\" : 1 } }, \"required\" : [ \"e\" ] }, \"then\" : { \"properties\" : { \"p\" : { \"$ref\" : \"#/$defs/values/data-url\" } } } } ] }, \"precomposition\" : { \"type\" : \"object\" , \"title\" : \"Precomposition\" , \"description\" : \"Asset containing a composition that can be referenced by layers.\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/assets/asset\" }, { \"$ref\" : \"#/$defs/composition/composition\" }, { \"type\" : \"object\" , \"properties\" : { \"fr\" : { \"title\" : \"Framerate\" , \"description\" : \"Framerate in frames per second\" , \"type\" : \"number\" }, \"xt\" : { \"title\" : \"Extra\" , \"description\" : \"Extra composition\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"default\" : 0 } } } ] }, \"sound\" : { \"type\" : \"object\" , \"title\" : \"Sound\" , \"description\" : \"External sound\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/assets/file-asset\" } ] } }, \"composition\" : { \"metadata\" : { \"type\" : \"object\" , \"title\" : \"Metadata\" , \"description\" : \"Document metadata\" , \"properties\" : { \"a\" : { \"title\" : \"Author\" , \"type\" : \"string\" }, \"d\" : { \"title\" : \"Description\" , \"type\" : \"string\" }, \"tc\" : { \"title\" : \"Theme Color\" , \"type\" : \"string\" }, \"g\" : { \"title\" : \"Generator\" , \"description\" : \"Software used to generate the file\" , \"type\" : \"string\" } }, \"anyOf\" : [ { \"properties\" : { \"k\" : { \"title\" : \"Keywords\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" } } } }, { \"properties\" : { \"k\" : { \"title\" : \"Keywords\" , \"type\" : \"string\" } } } ] }, \"composition\" : { \"type\" : \"object\" , \"title\" : \"Composition\" , \"description\" : \"An object that contains a list of layers\" , \"properties\" : { \"layers\" : { \"title\" : \"Layers\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/layers/all-layers\" } } }, \"required\" : [ \"layers\" ] }, \"animation\" : { \"type\" : \"object\" , \"title\" : \"Animation\" , \"description\" : \"Top level object, describing the animation\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"v\" : { \"title\" : \"Bodymovin version, on very old versions some things might be slightly different from what is explained here\" , \"type\" : \"string\" }, \"ver\" : { \"title\" : \"Specification Version\" , \"description\" : \"Specification version this Lottie is targeting. This is a 6 digit number with version components encoded as MMmmpp , with MM being major version, mm being minor and pp being patch.\" , \"type\" : \"integer\" , \"minimum\" : 10000 }, \"fr\" : { \"title\" : \"Framerate\" , \"description\" : \"Framerate in frames per second\" , \"type\" : \"number\" , \"exclusiveMinimum\" : 0 }, \"ip\" : { \"title\" : \"In Point\" , \"description\" : \"Frame the animation starts at (usually 0)\" , \"type\" : \"number\" }, \"op\" : { \"title\" : \"Out Point\" , \"description\" : \"Frame the animation stops/loops at, which makes this the duration in frames when ip is 0\" , \"type\" : \"number\" }, \"w\" : { \"title\" : \"Width\" , \"description\" : \"Width of the animation\" , \"type\" : \"integer\" , \"minimum\" : 0 }, \"h\" : { \"title\" : \"Height\" , \"description\" : \"Height of the animation\" , \"type\" : \"integer\" , \"minimum\" : 0 }, \"ddd\" : { \"title\" : \"Threedimensional\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"default\" : 0 , \"description\" : \"Whether the animation has 3D layers\" }, \"assets\" : { \"title\" : \"Assets\" , \"type\" : \"array\" , \"description\" : \"List of assets that can be referenced by layers\" , \"items\" : { \"$ref\" : \"#/$defs/assets/all-assets\" } }, \"comps\" : { \"title\" : \"Extra Compositions\" , \"type\" : \"array\" , \"description\" : \"List of Extra compositions not referenced by anything\" , \"items\" : { \"$ref\" : \"#/$defs/assets/precomposition\" } }, \"fonts\" : { \"title\" : \"Fonts\" , \"$ref\" : \"#/$defs/text/font-list\" }, \"chars\" : { \"title\" : \"Characters\" , \"description\" : \"Data defining text characters as lottie shapes. If present a player might only render characters defined here and nothing else.\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/text/character-data\" } }, \"meta\" : { \"title\" : \"Metadata\" , \"description\" : \"Document metadata\" , \"$ref\" : \"#/$defs/composition/metadata\" }, \"metadata\" : { \"title\" : \"User Metadata\" , \"$ref\" : \"#/$defs/composition/user-metadata\" }, \"markers\" : { \"title\" : \"Markers\" , \"description\" : \"Markers defining named sections of the composition.\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/helpers/marker\" } }, \"mb\" : { \"title\" : \"Motion Blur\" , \"$ref\" : \"#/$defs/composition/motion-blur\" }, \"slots\" : { \"title\" : \"Slots\" , \"description\" : \"Dictionary of slot ids that will replace matching properties.\" , \"type\" : \"object\" , \"additionalProperties\" : { \"$ref\" : \"#/$defs/helpers/slot\" } } }, \"required\" : [ \"w\" , \"h\" , \"fr\" , \"op\" , \"ip\" ] }, { \"$ref\" : \"#/$defs/composition/composition\" } ] }, \"user-metadata\" : { \"type\" : \"object\" , \"title\" : \"User Metadata\" , \"description\" : \"User-defined metadata\" , \"properties\" : { \"filename\" : { \"title\" : \"Filename\" , \"type\" : \"string\" }, \"customProps\" : { \"title\" : \"Custom Properties\" , \"type\" : \"object\" } } }, \"motion-blur\" : { \"type\" : \"object\" , \"title\" : \"Motion Blur\" , \"description\" : \"Motion blur settings\" , \"properties\" : { \"sa\" : { \"title\" : \"Shutter Angle\" , \"description\" : \"Angle in degrees\" , \"type\" : \"number\" }, \"sp\" : { \"title\" : \"Shutter Phase\" , \"description\" : \"Angle in degrees\" , \"type\" : \"number\" }, \"spf\" : { \"title\" : \"Samples per Frame\" , \"type\" : \"number\" }, \"asl\" : { \"title\" : \"Adaptive Sample Limit\" , \"type\" : \"number\" } } } }, \"constants\" : { \"font-path-origin\" : { \"type\" : \"integer\" , \"title\" : \"Font Path Origin\" , \"description\" : \"\" , \"oneOf\" : [ { \"title\" : \"Local\" , \"const\" : 0 }, { \"title\" : \"Css Url\" , \"const\" : 1 }, { \"title\" : \"Script Url\" , \"const\" : 2 }, { \"title\" : \"Font Url\" , \"const\" : 3 } ] }, \"stroke-dash-type\" : { \"type\" : \"string\" , \"title\" : \"Stroke Dash Type\" , \"description\" : \"Type of a dash item in a stroked line\" , \"oneOf\" : [ { \"title\" : \"Dash\" , \"const\" : \"d\" }, { \"title\" : \"Gap\" , \"const\" : \"g\" }, { \"title\" : \"Offset\" , \"const\" : \"o\" } ] }, \"merge-mode\" : { \"type\" : \"integer\" , \"title\" : \"Merge Mode\" , \"description\" : \"Boolean operation on shapes\" , \"oneOf\" : [ { \"title\" : \"Normal\" , \"const\" : 1 }, { \"title\" : \"Add\" , \"const\" : 2 }, { \"title\" : \"Subtract\" , \"const\" : 3 }, { \"title\" : \"Intersect\" , \"const\" : 4 }, { \"title\" : \"Exclude Intersections\" , \"const\" : 5 } ] }, \"gradient-type\" : { \"type\" : \"integer\" , \"title\" : \"Gradient Type\" , \"description\" : \"Whether a Gradient is a linear or radial.\" , \"oneOf\" : [ { \"title\" : \"Linear\" , \"description\" : \"Colors transition in a single linear direction.\" , \"const\" : 1 }, { \"title\" : \"Radial\" , \"description\" : \"Colors transition outward from a center point.\" , \"const\" : 2 } ] }, \"text-range-units\" : { \"type\" : \"integer\" , \"title\" : \"Text Range Units\" , \"description\" : \"Unit type for a text selector\" , \"oneOf\" : [ { \"title\" : \"Percent\" , \"const\" : 1 }, { \"title\" : \"Index\" , \"const\" : 2 } ] }, \"blend-mode\" : { \"type\" : \"integer\" , \"title\" : \"Blend Mode\" , \"description\" : \"Layer and shape blend mode\" , \"oneOf\" : [ { \"title\" : \"Normal\" , \"const\" : 0 }, { \"title\" : \"Multiply\" , \"const\" : 1 }, { \"title\" : \"Screen\" , \"const\" : 2 }, { \"title\" : \"Overlay\" , \"const\" : 3 }, { \"title\" : \"Darken\" , \"const\" : 4 }, { \"title\" : \"Lighten\" , \"const\" : 5 }, { \"title\" : \"Color Dodge\" , \"const\" : 6 }, { \"title\" : \"Color Burn\" , \"const\" : 7 }, { \"title\" : \"Hard Light\" , \"const\" : 8 }, { \"title\" : \"Soft Light\" , \"const\" : 9 }, { \"title\" : \"Difference\" , \"const\" : 10 }, { \"title\" : \"Exclusion\" , \"const\" : 11 }, { \"title\" : \"Hue\" , \"const\" : 12 }, { \"title\" : \"Saturation\" , \"const\" : 13 }, { \"title\" : \"Color\" , \"const\" : 14 }, { \"title\" : \"Luminosity\" , \"const\" : 15 }, { \"title\" : \"Add\" , \"const\" : 16 }, { \"title\" : \"Hard Mix\" , \"const\" : 17 } ] }, \"trim-multiple-shapes\" : { \"type\" : \"integer\" , \"title\" : \"Trim Multiple Shapes\" , \"description\" : \"How to handle multiple shapes in trim path\" , \"oneOf\" : [ { \"title\" : \"Parallel\" , \"description\" : \"All shapes apply the trim at the same time\" , \"const\" : 1 }, { \"title\" : \"Sequential\" , \"description\" : \"Shapes are considered as a continuous sequence\" , \"const\" : 2 } ] }, \"composite\" : { \"type\" : \"integer\" , \"title\" : \"Composite\" , \"description\" : \"How to stack copies in a repeater\" , \"oneOf\" : [ { \"title\" : \"Below\" , \"description\" : \"Subsequent copies are added underneath the previous ones.\" , \"const\" : 1 }, { \"title\" : \"Above\" , \"description\" : \"Subsequent copies are added on top of the previous ones.\" , \"const\" : 2 } ] }, \"fill-rule\" : { \"type\" : \"integer\" , \"title\" : \"Fill Rule\" , \"description\" : \"Rule used to handle multiple shapes rendered with the same fill object\" , \"oneOf\" : [ { \"title\" : \"Non Zero\" , \"description\" : \"Everything is colored (You can think of this as an OR)\" , \"const\" : 1 }, { \"title\" : \"Even Odd\" , \"description\" : \"Colored based on intersections and path direction, can be used to create \\\"holes\\\"\" , \"const\" : 2 } ] }, \"text-grouping\" : { \"type\" : \"integer\" , \"title\" : \"Text Grouping\" , \"description\" : \"\" , \"oneOf\" : [ { \"title\" : \"Characters\" , \"const\" : 1 }, { \"title\" : \"Word\" , \"const\" : 2 }, { \"title\" : \"Line\" , \"const\" : 3 }, { \"title\" : \"All\" , \"const\" : 4 } ] }, \"star-type\" : { \"type\" : \"integer\" , \"title\" : \"Star Type\" , \"description\" : \"Whether a PolyStar is a star or a polygon\" , \"oneOf\" : [ { \"title\" : \"Star\" , \"const\" : 1 }, { \"title\" : \"Polygon\" , \"const\" : 2 } ] }, \"text-shape\" : { \"type\" : \"integer\" , \"title\" : \"Text Shape\" , \"description\" : \"Defines the function used to determine the interpolating factor on a text range selector.\" , \"oneOf\" : [ { \"title\" : \"Square\" , \"const\" : 1 }, { \"title\" : \"Ramp Up\" , \"const\" : 2 }, { \"title\" : \"Ramp Down\" , \"const\" : 3 }, { \"title\" : \"Triangle\" , \"const\" : 4 }, { \"title\" : \"Round\" , \"const\" : 5 }, { \"title\" : \"Smooth\" , \"const\" : 6 } ] }, \"shape-direction\" : { \"type\" : \"integer\" , \"title\" : \"Shape Direction\" , \"description\" : \"Drawing direction of the shape curve, useful for trim path\" , \"oneOf\" : [ { \"title\" : \"Normal\" , \"description\" : \"Usually clockwise\" , \"const\" : 1 }, { \"title\" : \"Reversed\" , \"description\" : \"Usually counter clockwise\" , \"const\" : 3 } ] }, \"mask-mode\" : { \"type\" : \"string\" , \"title\" : \"Mask Mode\" , \"description\" : \"Describes how a mask interacts (blends) with the preceding masks in the stack.\" , \"oneOf\" : [ { \"title\" : \"None\" , \"const\" : \"n\" , \"description\" : \"The mask is ignored.\" }, { \"title\" : \"Add\" , \"const\" : \"a\" , \"description\" : \"Mask coverage is added (Normal blending).\" }, { \"title\" : \"Subtract\" , \"const\" : \"s\" , \"description\" : \"Mask coverage is subtracted (Subtract blending).\" }, { \"title\" : \"Intersect\" , \"const\" : \"i\" , \"description\" : \"Mask coverage is intersected (Source-In blending).\" }, { \"title\" : \"Lighten\" , \"const\" : \"l\" }, { \"title\" : \"Darken\" , \"const\" : \"d\" }, { \"title\" : \"Difference\" , \"const\" : \"f\" } ] }, \"line-join\" : { \"type\" : \"integer\" , \"title\" : \"Line Join\" , \"description\" : \"Style at a sharp corner of a stoked line\" , \"oneOf\" : [ { \"title\" : \"Miter\" , \"const\" : 1 }, { \"title\" : \"Round\" , \"const\" : 2 }, { \"title\" : \"Bevel\" , \"const\" : 3 } ] }, \"matte-mode\" : { \"type\" : \"integer\" , \"title\" : \"Matte Mode\" , \"description\" : \"How a layer should mask another layer\" , \"oneOf\" : [ { \"title\" : \"Normal\" , \"description\" : \"The layer is not used as a track matte\" , \"const\" : 0 }, { \"title\" : \"Alpha\" , \"description\" : \"The masked layer opacity is modulated by the track matte layer opacity\" , \"const\" : 1 }, { \"title\" : \"Inverted Alpha\" , \"description\" : \"The masked layer opacity is modulated by the inverted track matte layer opacity\" , \"const\" : 2 }, { \"title\" : \"Luma\" , \"description\" : \"The masked layer opacity is modulated by the track matte layer luminance\" , \"const\" : 3 }, { \"title\" : \"Inverted Luma\" , \"description\" : \"The masked layer opacity is modulated by the inverted track matte layer luminance\" , \"const\" : 4 } ] }, \"text-caps\" : { \"type\" : \"integer\" , \"title\" : \"Text Caps\" , \"oneOf\" : [ { \"title\" : \"Regular\" , \"const\" : 0 }, { \"title\" : \"All Caps\" , \"const\" : 1 }, { \"title\" : \"Small Caps\" , \"const\" : 2 } ], \"default\" : 0 }, \"text-justify\" : { \"type\" : \"integer\" , \"title\" : \"Text Justify\" , \"description\" : \"Text alignment / justification\" , \"oneOf\" : [ { \"title\" : \"Left\" , \"const\" : 0 }, { \"title\" : \"Right\" , \"const\" : 1 }, { \"title\" : \"Center\" , \"const\" : 2 }, { \"title\" : \"Justify with Last Line Left\" , \"const\" : 3 }, { \"title\" : \"Justify with Last Line Right\" , \"const\" : 4 }, { \"title\" : \"Justify with Last Line Center\" , \"const\" : 5 }, { \"title\" : \"Justify with Last Line Full\" , \"const\" : 6 } ] }, \"line-cap\" : { \"type\" : \"integer\" , \"title\" : \"Line Cap\" , \"description\" : \"Style at the end of a stoked line\" , \"oneOf\" : [ { \"title\" : \"Butt\" , \"const\" : 1 }, { \"title\" : \"Round\" , \"const\" : 2 }, { \"title\" : \"Square\" , \"const\" : 3 } ] }, \"text-based\" : { \"type\" : \"integer\" , \"title\" : \"Text Based\" , \"description\" : \"\" , \"oneOf\" : [ { \"title\" : \"Characters\" , \"const\" : 1 }, { \"title\" : \"Character Excluding Spaces\" , \"const\" : 2 }, { \"title\" : \"Words\" , \"const\" : 3 }, { \"title\" : \"Lines\" , \"const\" : 4 } ] } }, \"effect-values\" : { \"ignored\" : { \"type\" : \"object\" , \"title\" : \"Ignored Value\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 6 }, \"v\" : { \"title\" : \"Value\" , \"type\" : \"number\" , \"default\" : 0 } }, \"required\" : [ \"ty\" ] } ] }, \"no-value\" : { \"type\" : \"object\" , \"title\" : \"Effect No Value\" , \"description\" : \"\" }, \"angle\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Angle\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 1 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"effect-value\" : { \"type\" : \"object\" , \"title\" : \"Effect Value\" , \"description\" : \"Value for an effect\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"ix\" : { \"title\" : \"Effect Index\" , \"type\" : \"integer\" }, \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" } }, \"required\" : [] } ] }, \"drop-down\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Drop Down\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 7 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"point\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Point\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 3 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/properties/vector-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"slider\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Slider\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 0 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"color\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Color\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 2 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/properties/color-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"layer\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Layer\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 10 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"all-effect-values\" : { \"oneOf\" : [ { \"$ref\" : \"#/$defs/effect-values/angle\" }, { \"$ref\" : \"#/$defs/effect-values/checkbox\" }, { \"$ref\" : \"#/$defs/effect-values/color\" }, { \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"$ref\" : \"#/$defs/effect-values/ignored\" }, { \"$ref\" : \"#/$defs/effect-values/layer\" }, { \"$ref\" : \"#/$defs/effect-values/no-value\" }, { \"$ref\" : \"#/$defs/effect-values/point\" }, { \"$ref\" : \"#/$defs/effect-values/slider\" } ] }, \"checkbox\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Checkbox\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 4 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] } }, \"effects\" : { \"spherize-effect\" : { \"type\" : \"object\" , \"title\" : \"Spherize Effect\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 33 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"radius\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"center\" , \"$ref\" : \"#/$defs/effect-values/point\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"puppet-effect\" : { \"type\" : \"object\" , \"title\" : \"Puppet Effect\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 34 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Puppet Engine\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Mesh Rotation Refinement\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"On Transparent\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"03\" , \"$ref\" : \"#/$defs/effect-values/no-value\" } ] } }, \"required\" : [ \"ty\" , \"ef\" ] } ] }, \"tritone-effect\" : { \"type\" : \"object\" , \"title\" : \"Tritone Effect\" , \"description\" : \"Maps layers colors based on bright/mid/dark colors\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 23 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"bright\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"mid\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"dark\" , \"$ref\" : \"#/$defs/effect-values/color\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"displacement-map-effect\" : { \"type\" : \"object\" , \"title\" : \"Displacement Map Effect\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 27 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Displacement Map Layer\" , \"$ref\" : \"#/$defs/effect-values/layer\" }, { \"title\" : \"Use For Horizontal Displacement\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Max Horizontal Displacement\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Use For Vertical Displacement\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Max Vertical Displacement\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Displacement Map Behavior\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Edge Behavior\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Expand Output\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" } ] } }, \"required\" : [ \"ty\" , \"ef\" ] } ] }, \"wavy-effect\" : { \"type\" : \"object\" , \"title\" : \"Wavy Effect\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 32 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Radius\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Center\" , \"$ref\" : \"#/$defs/effect-values/point\" }, { \"title\" : \"Conversion type\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Speed\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Width\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Height\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Phase\" , \"$ref\" : \"#/$defs/effect-values/slider\" } ] } }, \"required\" : [ \"ty\" , \"ef\" ] } ] }, \"gaussian-blur-effect\" : { \"type\" : \"object\" , \"title\" : \"Gaussian Blur Effect\" , \"description\" : \"Gaussian blur\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 29 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"sigma\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"direction\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"wrap\" , \"$ref\" : \"#/$defs/effect-values/checkbox\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"pro-levels-effect\" : { \"type\" : \"object\" , \"title\" : \"Pro Levels Effect\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 24 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"00\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"01\" , \"$ref\" : \"#/$defs/effect-values/no-value\" }, { \"title\" : \"02\" , \"$ref\" : \"#/$defs/effect-values/no-value\" }, { \"title\" : \"comp_inblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"comp_inwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"comp_gamma\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"comp_outblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"comp_outwhite\" , \"$ref\" : \"#/$defs/effect-values/no-value\" }, { \"title\" : \"08\" , \"$ref\" : \"#/$defs/effect-values/no-value\" }, { \"title\" : \"09\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"r_inblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"r_inwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"r_gamma\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"r_outblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"r_outwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"15\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"16\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"g_inblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"g_inwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"g_gamma\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"g_outblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"g_outwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"22\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"23\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"b_inblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"b_inwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"b_gamma\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"b_outblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"b_outwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"29\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"a_inblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"a_inwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"a_gamma\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"a_outblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"a_outwhite\" , \"$ref\" : \"#/$defs/effect-values/no-value\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"all-effects\" : { \"oneOf\" : [ { \"$ref\" : \"#/$defs/effects/custom-effect\" }, { \"$ref\" : \"#/$defs/effects/displacement-map-effect\" }, { \"$ref\" : \"#/$defs/effects/drop-shadow-effect\" }, { \"$ref\" : \"#/$defs/effects/effect\" }, { \"$ref\" : \"#/$defs/effects/fill-effect\" }, { \"$ref\" : \"#/$defs/effects/gaussian-blur-effect\" }, { \"$ref\" : \"#/$defs/effects/matte3-effect\" }, { \"$ref\" : \"#/$defs/effects/mesh-warp-effect\" }, { \"$ref\" : \"#/$defs/effects/pro-levels-effect\" }, { \"$ref\" : \"#/$defs/effects/puppet-effect\" }, { \"$ref\" : \"#/$defs/effects/radial-wipe-effect\" }, { \"$ref\" : \"#/$defs/effects/spherize-effect\" }, { \"$ref\" : \"#/$defs/effects/stroke-effect\" }, { \"$ref\" : \"#/$defs/effects/tint-effect\" }, { \"$ref\" : \"#/$defs/effects/tritone-effect\" }, { \"$ref\" : \"#/$defs/effects/twirl-effect\" }, { \"$ref\" : \"#/$defs/effects/wavy-effect\" } ] }, \"tint-effect\" : { \"type\" : \"object\" , \"title\" : \"Tint Effect\" , \"description\" : \"Colorizes the layer\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 20 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Black Color\" , \"description\" : \"Tint of the darker parts of the layer\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"White Color\" , \"description\" : \"Tint of the lighter parts of the layer\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"Intensity\" , \"description\" : \"Intensity of the effect, 0 means the layer is unchanged. 100 means full effect\" , \"$ref\" : \"#/$defs/effect-values/slider\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"effect\" : { \"type\" : \"object\" , \"title\" : \"Effect\" , \"description\" : \"Layer effect\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"ef\" : { \"title\" : \"Effect Values\" , \"type\" : \"array\" , \"items\" : { \"oneOf\" : [ { \"$ref\" : \"#/$defs/effect-values/no-value\" }, { \"$ref\" : \"#/$defs/effect-values/angle\" }, { \"$ref\" : \"#/$defs/effect-values/checkbox\" }, { \"$ref\" : \"#/$defs/effect-values/color\" }, { \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"$ref\" : \"#/$defs/effect-values/ignored\" }, { \"$ref\" : \"#/$defs/effect-values/layer\" }, { \"$ref\" : \"#/$defs/effect-values/point\" }, { \"$ref\" : \"#/$defs/effect-values/slider\" } ] } }, \"np\" : { \"title\" : \"Property Count\" , \"description\" : \"Number of values in ef \" , \"type\" : \"integer\" }, \"ix\" : { \"title\" : \"Effect Index\" , \"type\" : \"integer\" }, \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Effect type\" , \"type\" : \"integer\" }, \"en\" : { \"title\" : \"Enabled\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"default\" : 1 } }, \"required\" : [ \"ty\" , \"ef\" ] } ] }, \"mesh-warp-effect\" : { \"type\" : \"object\" , \"title\" : \"Mesh Warp Effect\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 31 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Rows\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Columns\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Quality\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"03\" , \"$ref\" : \"#/$defs/effect-values/no-value\" } ] } }, \"required\" : [ \"ty\" , \"ef\" ] } ] }, \"matte3-effect\" : { \"type\" : \"object\" , \"title\" : \"Set Matte Effect\" , \"description\" : \"Uses a layer as a mask\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 28 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Layer\" , \"description\" : \"Use this layer as a mask\" , \"$ref\" : \"#/$defs/effect-values/layer\" }, { \"title\" : \"Channel\" , \"description\" : \"Channel to use as a mask:\\n1 - Red\\n2 - Green\\n3 - Blue\\n4 - Alpha\\n5 - Luminance\\n6 - Hue\\n7 - Lightness\\n8 - Saturation\\n9 - Full\\n10 - Off\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Invert\" , \"description\" : \"Use 0 as opaque value when true\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Stretch To Fit\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Show Mask\" , \"description\" : \"If false, the mask layer won't be shown\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Premultiply Mask\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"fill-effect\" : { \"type\" : \"object\" , \"title\" : \"Fill Effect\" , \"description\" : \"Replaces the whole layer with the given color\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 21 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"10\" , \"$ref\" : \"#/$defs/effect-values/layer\" }, { \"title\" : \"01\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"color\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"03\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"04\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"05\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"opacity\" , \"description\" : \"Opacity in [0, 1]\" , \"$ref\" : \"#/$defs/effect-values/slider\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"drop-shadow-effect\" : { \"type\" : \"object\" , \"title\" : \"Drop Shadow Effect\" , \"description\" : \"Adds a shadow to the layer\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 25 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"color\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"opacity\" , \"description\" : \"Opacity between 0 and 255\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"angle\" , \"$ref\" : \"#/$defs/effect-values/angle\" }, { \"title\" : \"distance\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"blur\" , \"$ref\" : \"#/$defs/effect-values/slider\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"radial-wipe-effect\" : { \"type\" : \"object\" , \"title\" : \"Radial Wipe\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 26 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Completion\" , \"description\" : \"Between 0 and 100\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Start Angle\" , \"$ref\" : \"#/$defs/effect-values/angle\" }, { \"title\" : \"Wipe Center\" , \"$ref\" : \"#/$defs/effect-values/point\" }, { \"title\" : \"Wipe\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Feather\" , \"$ref\" : \"#/$defs/effect-values/slider\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"stroke-effect\" : { \"type\" : \"object\" , \"title\" : \"Stroke Effect\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 22 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"00\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"01\" , \"$ref\" : \"#/$defs/effect-values/checkbox\" }, { \"title\" : \"02\" , \"$ref\" : \"#/$defs/effect-values/checkbox\" }, { \"title\" : \"color\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"04\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"05\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"06\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"07\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"08\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"09\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"type\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"twirl-effect\" : { \"type\" : \"object\" , \"title\" : \"Twirl Effect\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 30 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Angle\" , \"$ref\" : \"#/$defs/effect-values/angle\" }, { \"title\" : \"Radius\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Center\" , \"$ref\" : \"#/$defs/effect-values/point\" } ] } }, \"required\" : [ \"ty\" , \"ef\" ] } ] }, \"custom-effect\" : { \"type\" : \"object\" , \"title\" : \"Custom Effect\" , \"description\" : \"Some lottie files use ty = 5 for many different effects\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 5 } }, \"required\" : [ \"ty\" ] } ] } }, \"helpers\" : { \"mask\" : { \"type\" : \"object\" , \"title\" : \"Mask\" , \"description\" : \"Mask for layer content.\" , \"allOf\" : [ { \"properties\" : { \"mode\" : { \"title\" : \"Mode\" , \"$ref\" : \"#/$defs/constants/mask-mode\" , \"default\" : \"i\" }, \"o\" : { \"title\" : \"Opacity\" , \"description\" : \"Mask opacity, as a percentage [0..100].\" , \"$ref\" : \"#/$defs/properties/scalar-property\" , \"default\" : 100 }, \"pt\" : { \"title\" : \"Shape\" , \"description\" : \"Mask shape\" , \"$ref\" : \"#/$defs/properties/bezier-property\" }, \"x\" : { \"title\" : \"Expand\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"inv\" : { \"title\" : \"Inverted\" , \"type\" : \"boolean\" , \"default\" : false } }, \"required\" : [ \"pt\" ] } ] }, \"slot\" : { \"type\" : \"object\" , \"title\" : \"Slot\" , \"description\" : \"Defines a property value that will be set to all matched properties\" , \"properties\" : { \"p\" : { \"title\" : \"Property Value\" , \"description\" : \"Property Value\" } }, \"required\" : [ \"p\" ] }, \"slottable-object\" : { \"type\" : \"object\" , \"title\" : \"Slottable Object\" , \"description\" : \"Object that may have its value replaced with a slot value\" , \"properties\" : { \"sid\" : { \"title\" : \"Slot Id\" , \"description\" : \"Identifier to look up the slot\" , \"type\" : \"string\" } } }, \"marker\" : { \"type\" : \"object\" , \"title\" : \"Marker\" , \"description\" : \"Defines named portions of the composition.\" , \"properties\" : { \"cm\" : { \"title\" : \"Comment\" , \"type\" : \"string\" }, \"tm\" : { \"title\" : \"Time\" , \"type\" : \"number\" }, \"dr\" : { \"title\" : \"Duration\" , \"type\" : \"number\" } } }, \"transform\" : { \"type\" : \"object\" , \"title\" : \"Transform\" , \"description\" : \"Layer transform\" , \"allOf\" : [ { \"properties\" : { \"a\" : { \"title\" : \"Anchor Point\" , \"description\" : \"Anchor point: a position (relative to its parent) around which transformations are applied (ie: center for rotation / scale)\" , \"$ref\" : \"#/$defs/properties/position-property\" }, \"p\" : { \"title\" : \"Position\" , \"description\" : \"Position / Translation\" , \"$ref\" : \"#/$defs/properties/splittable-position-property\" }, \"r\" : { \"title\" : \"Rotation\" , \"description\" : \"Rotation in degrees, clockwise\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"s\" : { \"title\" : \"Scale\" , \"description\" : \"Scale factor, [100, 100] for no scaling\" , \"$ref\" : \"#/$defs/properties/vector-property\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"sk\" : { \"title\" : \"Skew\" , \"description\" : \"Skew amount as an angle in degrees\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"sa\" : { \"title\" : \"Skew Axis\" , \"description\" : \"Direction along which skew is applied, in degrees ( 0 skews along the X axis, 90 along the Y axis)\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"rx\" : { \"title\" : \"X Rotation\" , \"description\" : \"Split rotation component\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"ry\" : { \"title\" : \"Y Rotation\" , \"description\" : \"Split rotation component\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"rz\" : { \"title\" : \"Z Rotation\" , \"description\" : \"Split rotation component, equivalent to r when not split\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"or\" : { \"title\" : \"Orientation\" , \"$ref\" : \"#/$defs/properties/vector-property\" } } } ] }, \"visual-object\" : { \"type\" : \"object\" , \"title\" : \"Visual Object\" , \"description\" : \"\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"nm\" : { \"title\" : \"Name\" , \"description\" : \"Human readable name, as seen from editors and the like\" , \"type\" : \"string\" }, \"mn\" : { \"title\" : \"Match Name\" , \"description\" : \"Match name, used in expressions\" , \"type\" : \"string\" } }, \"required\" : [] } ] } }, \"layers\" : { \"precomposition-layer\" : { \"type\" : \"object\" , \"title\" : \"Precomposition Layer\" , \"description\" : \"Layer that renders a Precomposition asset\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/visual-layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 0 }, \"refId\" : { \"title\" : \"Reference Id\" , \"description\" : \"ID of the precomp as specified in the assets\" , \"type\" : \"string\" }, \"w\" : { \"title\" : \"Width\" , \"description\" : \"Width of the clipping rect\" , \"type\" : \"integer\" }, \"h\" : { \"title\" : \"Height\" , \"description\" : \"Height of the clipping rect\" , \"type\" : \"integer\" }, \"st\" : { \"title\" : \"Start Time\" , \"type\" : \"number\" , \"default\" : 0 }, \"tm\" : { \"title\" : \"Time Remap\" , \"description\" : \"Timeline remap function (frame index -> time in seconds)\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" , \"refId\" ] } ] }, \"null-layer\" : { \"type\" : \"object\" , \"title\" : \"Null Layer\" , \"description\" : \"Layer with no data, useful to group layers together\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/visual-layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 3 } }, \"required\" : [ \"ty\" ] } ] }, \"data-layer\" : { \"type\" : \"object\" , \"title\" : \"Data Layer\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 15 }, \"refId\" : { \"title\" : \"Data source Id\" , \"description\" : \"ID of the data source in assets\" , \"type\" : \"string\" } }, \"required\" : [ \"ty\" ] } ] }, \"unknown-layer\" : { \"type\" : \"object\" , \"title\" : \"Unknown layer types\" , \"description\" : \"Unknown layer types. Types not defined by the specification are still allowed.\" , \"properties\" : { \"ty\" : { \"not\" : { \"$comment\" : \"enum list is dynamically generated\" , \"enum\" : [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 15 , 13 ] } } } }, \"image-layer\" : { \"type\" : \"object\" , \"title\" : \"Image Layer\" , \"description\" : \"Layer containing an image\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/visual-layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 2 }, \"refId\" : { \"title\" : \"Reference Id\" , \"description\" : \"ID of the image as specified in the assets\" , \"type\" : \"string\" } }, \"required\" : [ \"ty\" , \"refId\" ] } ] }, \"solid-layer\" : { \"type\" : \"object\" , \"title\" : \"Solid Layer\" , \"description\" : \"Solid color, rectangle-shaped layer\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/visual-layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 1 }, \"sw\" : { \"title\" : \"Width\" , \"description\" : \"Solid rectangle width\" , \"type\" : \"integer\" }, \"sh\" : { \"title\" : \"Height\" , \"description\" : \"Solid rectangle height\" , \"type\" : \"integer\" }, \"sc\" : { \"title\" : \"Color\" , \"description\" : \"Solid fill color\" , \"$ref\" : \"#/$defs/values/hexcolor\" } }, \"required\" : [ \"ty\" , \"sw\" , \"sh\" , \"sc\" ] } ] }, \"audio-layer\" : { \"type\" : \"object\" , \"title\" : \"Audio Layer\" , \"description\" : \"A layer playing sounds\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 6 }, \"au\" : { \"title\" : \"Audio Settings\" , \"$ref\" : \"#/$defs/layers/audio-settings\" }, \"refId\" : { \"title\" : \"Sound Id\" , \"description\" : \"ID of the sound as specified in the assets\" , \"type\" : \"string\" } }, \"required\" : [ \"ty\" , \"au\" ] } ] }, \"audio-settings\" : { \"type\" : \"object\" , \"title\" : \"Audio Settings\" , \"description\" : \"\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"lv\" : { \"title\" : \"Level\" , \"$ref\" : \"#/$defs/properties/vector-property\" } }, \"required\" : [ \"lv\" ] } ] }, \"text-layer\" : { \"type\" : \"object\" , \"title\" : \"Text Layer\" , \"description\" : \"Layer with some text\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/visual-layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 5 }, \"t\" : { \"title\" : \"Data\" , \"$ref\" : \"#/$defs/text/text-data\" } }, \"required\" : [ \"ty\" , \"t\" ] } ] }, \"shape-layer\" : { \"type\" : \"object\" , \"title\" : \"Shape Layer\" , \"description\" : \"Layer containing Shapes\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/visual-layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 4 }, \"shapes\" : { \"title\" : \"Shapes\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/shapes/all-graphic-elements\" } } }, \"required\" : [ \"ty\" , \"shapes\" ] } ] }, \"all-layers\" : { \"oneOf\" : [ { \"$ref\" : \"#/$defs/layers/precomposition-layer\" }, { \"$ref\" : \"#/$defs/layers/solid-layer\" }, { \"$ref\" : \"#/$defs/layers/image-layer\" }, { \"$ref\" : \"#/$defs/layers/null-layer\" }, { \"$ref\" : \"#/$defs/layers/shape-layer\" }, { \"$ref\" : \"#/$defs/layers/text-layer\" }, { \"$ref\" : \"#/$defs/layers/audio-layer\" }, { \"$ref\" : \"#/$defs/layers/data-layer\" }, { \"$ref\" : \"#/$defs/layers/camera-layer\" }, { \"$ref\" : \"#/$defs/layers/unknown-layer\" } ] }, \"camera-layer\" : { \"type\" : \"object\" , \"title\" : \"Camera Layer\" , \"description\" : \"3D Camera\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 13 }, \"ks\" : { \"title\" : \"Transform\" , \"description\" : \"Layer transform\" , \"$ref\" : \"#/$defs/helpers/transform\" }, \"pe\" : { \"title\" : \"Perspective\" , \"description\" : \"Distance from the Z=0 plane.\\nSmall values yield a higher perspective effect.\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" , \"ks\" , \"pe\" ] } ] }, \"visual-layer\" : { \"type\" : \"object\" , \"title\" : \"Visual Layer\" , \"description\" : \"Layer used to affect visual elements\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ks\" : { \"title\" : \"Transform\" , \"description\" : \"Layer transform\" , \"$ref\" : \"#/$defs/helpers/transform\" }, \"ao\" : { \"title\" : \"Auto Orient\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"default\" : 0 , \"description\" : \"If 1, the layer will rotate itself to match its animated position path\" }, \"tt\" : { \"title\" : \"Matte Mode\" , \"$ref\" : \"#/$defs/constants/matte-mode\" , \"description\" : \"Defines the track matte mode for the layer\" }, \"tp\" : { \"title\" : \"Matte Parent\" , \"type\" : \"integer\" , \"description\" : \"Index of the layer used as matte, if omitted assume the layer above the current one\" }, \"td\" : { \"title\" : \"Matte Target\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"description\" : \"If set to 1, it means a layer is using this layer as a track matte\" }, \"hasMask\" : { \"title\" : \"Has Masks\" , \"description\" : \"Whether the layer has masks applied\" , \"type\" : \"boolean\" }, \"masksProperties\" : { \"title\" : \"Masks\" , \"description\" : \"Optional array of masks for the layer.\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/helpers/mask\" } }, \"ef\" : { \"title\" : \"Effects\" , \"description\" : \"List of layer effects\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/effects/all-effects\" } }, \"mb\" : { \"title\" : \"Motion Blur\" , \"description\" : \"Whether motion blur is enabled for the layer\" , \"type\" : \"boolean\" }, \"sy\" : { \"title\" : \"Layer style\" , \"description\" : \"Styling effects for this layer\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/styles/all-layer-styles\" } }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/constants/blend-mode\" , \"default\" : 0 }, \"cl\" : { \"title\" : \"CSS Class\" , \"description\" : \"CSS class used by the SVG renderer\" , \"type\" : \"string\" }, \"ln\" : { \"title\" : \"Layer XML ID\" , \"description\" : \" id attribute used by the SVG renderer\" , \"type\" : \"string\" }, \"tg\" : { \"title\" : \"Layer XML tag name\" , \"description\" : \"tag name used by the SVG renderer\" , \"type\" : \"string\" }, \"cp\" : { \"deprecated\" : true , \"title\" : \"Collapse Transform\" , \"description\" : \"This is deprecated in favour of ct \" , \"type\" : \"boolean\" }, \"ct\" : { \"title\" : \"Collapse Transform\" , \"description\" : \"Marks that transforms should be applied before masks\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"default\" : 0 } }, \"required\" : [ \"ks\" ] } ] }, \"layer\" : { \"type\" : \"object\" , \"title\" : \"Layer\" , \"description\" : \"Common properties for all layers\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"ddd\" : { \"title\" : \"Threedimensional\" , \"description\" : \"Whether the layer is threedimensional\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"default\" : 0 }, \"hd\" : { \"title\" : \"Hidden\" , \"description\" : \"Whether the layer is hidden\" , \"type\" : \"boolean\" }, \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" }, \"ind\" : { \"title\" : \"Index\" , \"type\" : \"integer\" , \"description\" : \"Index that can be used for parenting and referenced in expressions\" }, \"parent\" : { \"title\" : \"Parent Index\" , \"description\" : \"Must be the ind property of another layer\" , \"type\" : \"integer\" }, \"sr\" : { \"title\" : \"Time Stretch\" , \"type\" : \"number\" , \"default\" : 1 }, \"ip\" : { \"title\" : \"In Point\" , \"description\" : \"Frame when the layer becomes visible\" , \"type\" : \"number\" }, \"op\" : { \"title\" : \"Out Point\" , \"description\" : \"Frame when the layer becomes invisible\" , \"type\" : \"number\" }, \"st\" : { \"title\" : \"Start Time\" , \"type\" : \"number\" , \"default\" : 0 } }, \"required\" : [ \"ty\" , \"ip\" , \"op\" ] } ] } }, \"properties\" : { \"gradient-stops\" : { \"type\" : \"object\" , \"title\" : \"Gradient stops\" , \"description\" : \"Animatable vector representing the gradient stops\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/properties/property\" } ], \"oneOf\" : [ { \"$comment\" : \"Not animated\" , \"properties\" : { \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"const\" : 0 }, \"k\" : { \"title\" : \"Value\" , \"description\" : \"Static Value\" , \"$ref\" : \"#/$defs/values/gradient\" } } }, { \"$comment\" : \"Animated\" , \"properties\" : { \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"const\" : 1 }, \"k\" : { \"type\" : \"array\" , \"title\" : \"Keyframes\" , \"description\" : \"Array of keyframes\" , \"items\" : { \"$ref\" : \"#/$defs/properties/gradient-keyframe\" } } } } ], \"required\" : [ \"a\" , \"k\" ] }, \"easing-handle\" : { \"type\" : \"object\" , \"title\" : \"Keyframe Easing\" , \"description\" : \"Bezier handle for keyframe interpolation\" , \"properties\" : { \"x\" : { \"title\" : \"X\" , \"description\" : \"Time component:\\n0 means start time of the keyframe,\\n1 means time of the next keyframe.\" , \"oneOf\" : [ { \"type\" : \"array\" , \"$ref\" : \"#/$defs/values/vector\" , \"items\" : { \"type\" : \"number\" , \"default\" : 0 , \"minimum\" : 0 , \"maximum\" : 1 }, \"minItems\" : 1 }, { \"type\" : \"number\" , \"default\" : 0 , \"minimum\" : 0 , \"maximum\" : 1 } ] }, \"y\" : { \"title\" : \"Y\" , \"description\" : \"Value interpolation component:\\n0 means start value of the keyframe,\\n1 means value at the next keyframe.\" , \"oneOf\" : [ { \"type\" : \"array\" , \"$ref\" : \"#/$defs/values/vector\" , \"items\" : { \"type\" : \"number\" , \"default\" : 0 }, \"minItems\" : 1 }, { \"type\" : \"number\" , \"default\" : 0 } ] } }, \"required\" : [ \"x\" , \"y\" ] }, \"position-property\" : { \"type\" : \"object\" , \"title\" : \"Position Property\" , \"description\" : \"An animatable property to represent a position in space\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/properties/property\" }, { \"properties\" : { \"l\" : { \"title\" : \"Length\" , \"description\" : \"Number of components in the value arrays.\\nIf present values will be truncated or expanded to match this length when accessed from expressions.\" , \"type\" : \"integer\" } } } ], \"oneOf\" : [ { \"$comment\" : \"Not animated\" , \"properties\" : { \"ix\" : { \"title\" : \"Property Index\" , \"type\" : \"integer\" }, \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"const\" : 0 }, \"k\" : { \"title\" : \"Value\" , \"description\" : \"Static Value\" , \"$ref\" : \"#/$defs/values/vector\" } } }, { \"$comment\" : \"Animated\" , \"properties\" : { \"ix\" : { \"title\" : \"Property Index\" , \"type\" : \"integer\" }, \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"const\" : 1 }, \"k\" : { \"type\" : \"array\" , \"title\" : \"Keyframes\" , \"description\" : \"Array of keyframes\" , \"items\" : { \"$ref\" : \"#/$defs/properties/position-keyframe\" } } } } ], \"required\" : [ \"a\" , \"k\" ] }, \"position-keyframe\" : { \"type\" : \"object\" , \"title\" : \"Position Keyframe\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/properties/vector-keyframe\" }, { \"properties\" : { \"ti\" : { \"title\" : \"Value In Tangent\" , \"description\" : \"Tangent for values (eg: moving position around a curved path)\" , \"$ref\" : \"#/$defs/values/vector\" }, \"to\" : { \"title\" : \"Value Out Tangent\" , \"description\" : \"Tangent for values (eg: moving position around a curved path)\" , \"$ref\" : \"#/$defs/values/vector\" } } } ] }, \"vector-keyframe\" : { \"type\" : \"object\" , \"title\" : \"Vector Keyframe\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/properties/base-keyframe\" }, { \"properties\" : { \"s\" : { \"title\" : \"Value\" , \"description\" : \"Value at this keyframe.\" , \"$ref\" : \"#/$defs/values/vector\" }, \"e\" : { \"title\" : \"End value\" , \"description\" : \"Value at the end of the keyframe, note that this is deprecated and you should use s from the next keyframe to get this value\" , \"deprecated\" : true , \"$ref\" : \"#/$defs/values/vector\" } } } ], \"required\" : [ \"s\" ] }, \"color-keyframe\" : { \"type\" : \"object\" , \"title\" : \"Color Keyframe\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/properties/base-keyframe\" }, { \"properties\" : { \"s\" : { \"title\" : \"Value\" , \"description\" : \"Value at this keyframe.\" , \"$ref\" : \"#/$defs/values/color\" }, \"e\" : { \"title\" : \"End value\" , \"description\" : \"Value at the end of the keyframe, note that this is deprecated and you should use s from the next keyframe to get this value\" , \"deprecated\" : true , \"$ref\" : \"#/$defs/values/color\" } } } ], \"required\" : [ \"s\" ] }, \"vector-property\" : { \"type\" : \"object\" , \"title\" : \"Vector Property\" , \"description\" : \"An animatable property that holds an array of numbers\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/properties/property\" }, { \"properties\" : { \"l\" : { \"title\" : \"Length\" , \"description\" : \"Number of components in the value arrays.\\nIf present values will be truncated or expanded to match this length when accessed from expressions.\" , \"type\" : \"integer\" } } } ], \"oneOf\" : [ { \"$comment\" : \"Not animated\" , \"properties\" : { \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"const\" : 0 }, \"k\" : { \"title\" : \"Value\" , \"description\" : \"Static Value\" , \"$ref\" : \"#/$defs/values/vector\" } } }, { \"$comment\" : \"Animated\" , \"properties\" : { \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"const\" : 1 }, \"k\" : { \"type\" : \"array\" , \"title\" : \"Keyframes\" , \"description\" : \"Array of keyframes\" , \"items\" : { \"$ref\" : \"#/$defs/properties/vector-keyframe\" } } } } ] }, \"scalar-property\" : { \"type\" : \"object\" , \"title\" : \"Scalar Property\" , \"description\" : \"An animatable property that holds a float\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/properties/property\" } ], \"oneOf\" : [ { \"$comment\" : \"Not animated\" , \"properties\" : { \"ix\" : { \"title\" : \"Property Index\" , \"type\" : \"integer\" }, \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"const\" : 0 }, \"k\" : { \"title\" : \"Value\" , \"description\" : \"Static Value\" , \"type\" : \"number\" } } }, { \"$comment\" : \"Animated\" , \"properties\" : { \"ix\" : { \"title\" : \"Property Index\" , \"type\" : \"integer\" }, \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"const\" : 1 }, \"k\" : { \"type\" : \"array\" , \"title\" : \"Keyframes\" , \"description\" : \"Array of keyframes\" , \"items\" : { \"$ref\" : \"#/$defs/properties/vector-keyframe\" } } } } ] }, \"bezier-property\" : { \"type\" : \"object\" , \"title\" : \"Bezier Property\" , \"description\" : \"An animatable property that holds a Bezier shape\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/properties/property\" } ], \"oneOf\" : [ { \"$comment\" : \"Not animated\" , \"properties\" : { \"ix\" : { \"title\" : \"Property Index\" , \"type\" : \"integer\" }, \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"const\" : 0 }, \"k\" : { \"title\" : \"Value\" , \"description\" : \"Static Value\" , \"$ref\" : \"#/$defs/values/bezier\" } } }, { \"$comment\" : \"Animated\" , \"properties\" : { \"ix\" : { \"title\" : \"Property Index\" , \"type\" : \"integer\" }, \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"const\" : 1 }, \"k\" : { \"type\" : \"array\" , \"title\" : \"Keyframes\" , \"description\" : \"Array of keyframes\" , \"items\" : { \"$ref\" : \"#/$defs/properties/bezier-keyframe\" } } } } ], \"required\" : [ \"a\" , \"k\" ] }, \"color-property\" : { \"type\" : \"object\" , \"title\" : \"Color Property\" , \"description\" : \"An animatable property that holds a Color\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/properties/property\" } ], \"oneOf\" : [ { \"$comment\" : \"Not animated\" , \"properties\" : { \"ix\" : { \"title\" : \"Property Index\" , \"type\" : \"integer\" }, \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"const\" : 0 }, \"k\" : { \"title\" : \"Value\" , \"description\" : \"Static Value\" , \"$ref\" : \"#/$defs/values/color\" } } }, { \"$comment\" : \"Animated\" , \"properties\" : { \"ix\" : { \"title\" : \"Property Index\" , \"type\" : \"integer\" }, \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"const\" : 1 }, \"k\" : { \"type\" : \"array\" , \"title\" : \"Keyframes\" , \"description\" : \"Array of keyframes\" , \"items\" : { \"$ref\" : \"#/$defs/properties/color-keyframe\" } } } } ] }, \"bezier-keyframe\" : { \"type\" : \"object\" , \"title\" : \"Shape Keyframe\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/properties/base-keyframe\" }, { \"properties\" : { \"s\" : { \"title\" : \"Value\" , \"description\" : \"Value at this keyframe.\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/values/bezier\" }, \"minItems\" : 1 , \"maxItems\" : 1 }, \"e\" : { \"title\" : \"End value\" , \"description\" : \"Value at the end of the keyframe, note that this is deprecated and you should use s from the next keyframe to get this value\" , \"deprecated\" : true , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/values/bezier\" }, \"minItems\" : 1 , \"maxItems\" : 1 } } } ], \"required\" : [ \"s\" ] }, \"gradient-keyframe\" : { \"type\" : \"object\" , \"title\" : \"Gradient Keyframe\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/properties/base-keyframe\" }, { \"properties\" : { \"s\" : { \"title\" : \"Value\" , \"description\" : \"Value at this keyframe.\" , \"$ref\" : \"#/$defs/values/gradient\" }, \"e\" : { \"title\" : \"End value\" , \"description\" : \"Value at the end of the keyframe, note that this is deprecated and you should use s from the next keyframe to get this value\" , \"deprecated\" : true , \"type\" : \"array\" , \"$ref\" : \"#/$defs/values/gradient\" } } } ], \"required\" : [ \"s\" ] }, \"split-position\" : { \"type\" : \"object\" , \"title\" : \"Split Position\" , \"description\" : \"An animatable position where x and y are definied and animated separately.\" , \"properties\" : { \"s\" : { \"title\" : \"Split\" , \"description\" : \"Whether the position has split values\" , \"type\" : \"boolean\" , \"const\" : true }, \"x\" : { \"title\" : \"X Position\" , \"description\" : \"X Position\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"y\" : { \"title\" : \"Y Position\" , \"description\" : \"Y Position\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"s\" , \"x\" , \"y\" ] }, \"base-keyframe\" : { \"type\" : \"object\" , \"title\" : \"Base Keyframe\" , \"description\" : \"A Keyframes specifies the value at a specific time and the interpolation function to reach the next keyframe.\" , \"allOf\" : [ { \"properties\" : { \"t\" : { \"title\" : \"Time\" , \"description\" : \"Frame number\" , \"type\" : \"number\" , \"default\" : 0 }, \"h\" : { \"title\" : \"Hold\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"default\" : 0 }, \"i\" : { \"title\" : \"In Tangent\" , \"description\" : \"Easing tangent going into the next keyframe\" , \"$ref\" : \"#/$defs/properties/easing-handle\" }, \"o\" : { \"title\" : \"Out Tangent\" , \"description\" : \"Easing tangent leaving the current keyframe\" , \"$ref\" : \"#/$defs/properties/easing-handle\" } } } ], \"required\" : [ \"t\" ] }, \"splittable-position-property\" : { \"type\" : \"object\" , \"title\" : \"Splittable Position Property\" , \"description\" : \"An animatable position where position values may be defined and animated separately.\" , \"oneOf\" : [ { \"$comment\" : \"Grouped XY position coordinates\" , \"$ref\" : \"#/$defs/properties/position-property\" , \"properties\" : { \"s\" : { \"title\" : \"Split\" , \"description\" : \"Whether the position has split values\" , \"type\" : \"boolean\" , \"const\" : false } } }, { \"$comment\" : \"Split XY position coordinates\" , \"$ref\" : \"#/$defs/properties/split-position\" } ] }, \"gradient-property\" : { \"type\" : \"object\" , \"title\" : \"Gradient Property\" , \"description\" : \"An animatable property that holds a Gradient\" , \"properties\" : { \"p\" : { \"title\" : \"Color stop count\" , \"type\" : \"number\" }, \"k\" : { \"title\" : \"Gradient stops\" , \"$ref\" : \"#/$defs/properties/gradient-stops\" } } }, \"property\" : { \"type\" : \"object\" , \"title\" : \"Property\" , \"properties\" : { \"ix\" : { \"title\" : \"Property Index\" , \"type\" : \"integer\" }, \"x\" : { \"title\" : \"Expression\" , \"type\" : \"string\" }, \"sid\" : { \"title\" : \"Slot ID\" , \"description\" : \"One of the ID in the file's slots\" , \"type\" : \"string\" }, \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"default\" : 0 } }, \"if\" : { \"required\" : [ \"sid\" ] }, \"else\" : { \"required\" : [ \"a\" , \"k\" ] } } }, \"shapes\" : { \"twist\" : { \"type\" : \"object\" , \"title\" : \"Twist\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/modifier\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"tw\" }, \"a\" : { \"title\" : \"Angle\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"c\" : { \"title\" : \"Center\" , \"$ref\" : \"#/$defs/properties/vector-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"shape\" : { \"type\" : \"object\" , \"title\" : \"Shape\" , \"description\" : \"Drawable shape, defines the actual shape but not the style\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/graphic-element\" }, { \"type\" : \"object\" , \"properties\" : { \"d\" : { \"title\" : \"Direction\" , \"description\" : \"Direction the shape is drawn as, mostly relevant when using trim path\" , \"$ref\" : \"#/$defs/constants/shape-direction\" } } } ] }, \"merge\" : { \"type\" : \"object\" , \"title\" : \"Merge\" , \"description\" : \"Boolean operator on shapes\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/graphic-element\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"mm\" }, \"mm\" : { \"title\" : \"Merge Mode\" , \"$ref\" : \"#/$defs/constants/merge-mode\" , \"default\" : 1 } }, \"required\" : [ \"ty\" ] } ] }, \"stroke-dash\" : { \"type\" : \"object\" , \"title\" : \"Stroke Dash\" , \"description\" : \"An item used to described the dash pattern in a stroked path\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"n\" : { \"title\" : \"Dash Type\" , \"$ref\" : \"#/$defs/constants/stroke-dash-type\" , \"default\" : \"d\" }, \"v\" : { \"title\" : \"Length\" , \"description\" : \"Length of the dash\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [] } ] }, \"rounded-corners\" : { \"type\" : \"object\" , \"title\" : \"Rounded Corners\" , \"description\" : \"Rounds corners of other shapes\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/modifier\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"rd\" }, \"r\" : { \"title\" : \"Radius\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" , \"r\" ] } ] }, \"offset-path\" : { \"type\" : \"object\" , \"title\" : \"Offset Path\" , \"description\" : \"Interpolates the shape with its center point and bezier tangents with the opposite direction\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/modifier\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"op\" }, \"a\" : { \"title\" : \"Amount\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"lj\" : { \"title\" : \"Line Join\" , \"$ref\" : \"#/$defs/constants/line-join\" , \"default\" : 2 }, \"ml\" : { \"title\" : \"Miter Limit\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"transform\" : { \"type\" : \"object\" , \"title\" : \"Transform Shape\" , \"description\" : \"Group transform\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/graphic-element\" }, { \"$ref\" : \"#/$defs/helpers/transform\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"tr\" } }, \"required\" : [ \"ty\" ] } ] }, \"graphic-element\" : { \"type\" : \"object\" , \"title\" : \"Graphic Element\" , \"description\" : \"Element used to display vector data in a shape layer\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"hd\" : { \"title\" : \"Hidden\" , \"description\" : \"Whether the shape is hidden\" , \"type\" : \"boolean\" }, \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/constants/blend-mode\" }, \"ix\" : { \"title\" : \"Property index\" , \"description\" : \"Index used in expressions\" , \"type\" : \"integer\" }, \"cl\" : { \"title\" : \"CSS Class\" , \"description\" : \"CSS class used by the SVG renderer\" , \"type\" : \"string\" }, \"ln\" : { \"title\" : \"Layer XML ID\" , \"description\" : \" id attribute used by the SVG renderer\" , \"type\" : \"string\" } }, \"required\" : [ \"ty\" ] } ] }, \"base-stroke\" : { \"type\" : \"object\" , \"title\" : \"Base Stroke\" , \"description\" : \"Common properties for stroke styles\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"lc\" : { \"title\" : \"Line Cap\" , \"$ref\" : \"#/$defs/constants/line-cap\" , \"default\" : 2 }, \"lj\" : { \"title\" : \"Line Join\" , \"$ref\" : \"#/$defs/constants/line-join\" , \"default\" : 2 }, \"ml\" : { \"title\" : \"Miter Limit\" , \"type\" : \"number\" , \"default\" : 0 }, \"ml2\" : { \"title\" : \"Miter Limit\" , \"description\" : \"Animatable alternative to ml\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"w\" : { \"title\" : \"Width\" , \"description\" : \"Stroke width\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"d\" : { \"title\" : \"Dashes\" , \"description\" : \"Dashed line definition\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/shapes/stroke-dash\" } } }, \"required\" : [ \"w\" ] } ] }, \"gradient-stroke\" : { \"type\" : \"object\" , \"title\" : \"Gradient Stroke\" , \"description\" : \"Gradient stroke\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-style\" }, { \"$ref\" : \"#/$defs/shapes/base-stroke\" }, { \"$ref\" : \"#/$defs/shapes/base-gradient\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"gs\" } }, \"required\" : [ \"ty\" ] } ] }, \"stroke\" : { \"type\" : \"object\" , \"title\" : \"Stroke\" , \"description\" : \"Solid stroke\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-style\" }, { \"$ref\" : \"#/$defs/shapes/base-stroke\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"st\" }, \"c\" : { \"title\" : \"Color\" , \"description\" : \"Stroke color\" , \"$ref\" : \"#/$defs/properties/color-property\" } }, \"required\" : [ \"ty\" , \"c\" ] } ] }, \"shape-style\" : { \"type\" : \"object\" , \"title\" : \"Shape Style\" , \"description\" : \"Describes the visual appearance (like fill and stroke) of neighbouring shapes\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/graphic-element\" }, { \"type\" : \"object\" , \"properties\" : { \"o\" : { \"title\" : \"Opacity\" , \"description\" : \"Opacity, 100 means fully opaque\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"o\" ] } ] }, \"all-graphic-elements\" : { \"$comment\" : \"List of valid shapes\" , \"oneOf\" : [ { \"$ref\" : \"#/$defs/shapes/ellipse\" }, { \"$ref\" : \"#/$defs/shapes/fill\" }, { \"$ref\" : \"#/$defs/shapes/gradient-fill\" }, { \"$ref\" : \"#/$defs/shapes/gradient-stroke\" }, { \"$ref\" : \"#/$defs/shapes/group\" }, { \"$ref\" : \"#/$defs/shapes/merge\" }, { \"$ref\" : \"#/$defs/shapes/no-style\" }, { \"$ref\" : \"#/$defs/shapes/offset-path\" }, { \"$ref\" : \"#/$defs/shapes/path\" }, { \"$ref\" : \"#/$defs/shapes/polystar\" }, { \"$ref\" : \"#/$defs/shapes/pucker-bloat\" }, { \"$ref\" : \"#/$defs/shapes/rectangle\" }, { \"$ref\" : \"#/$defs/shapes/repeater\" }, { \"$ref\" : \"#/$defs/shapes/rounded-corners\" }, { \"$ref\" : \"#/$defs/shapes/stroke\" }, { \"$ref\" : \"#/$defs/shapes/transform\" }, { \"$ref\" : \"#/$defs/shapes/trim-path\" }, { \"$ref\" : \"#/$defs/shapes/twist\" }, { \"$ref\" : \"#/$defs/shapes/zig-zag\" }, { \"$ref\" : \"#/$defs/shapes/unknown-shape\" } ] }, \"trim-path\" : { \"type\" : \"object\" , \"title\" : \"Trim Path\" , \"description\" : \"Trims shapes into a segment\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/modifier\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"tm\" }, \"s\" : { \"title\" : \"Start\" , \"description\" : \"Segment start\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"e\" : { \"title\" : \"End\" , \"description\" : \"Segment end\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"o\" : { \"title\" : \"Offset\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"m\" : { \"title\" : \"Multiple\" , \"description\" : \"How to treat multiple copies\" , \"$ref\" : \"#/$defs/constants/trim-multiple-shapes\" } }, \"required\" : [ \"ty\" , \"o\" , \"s\" , \"e\" ] } ] }, \"modifier\" : { \"type\" : \"object\" , \"title\" : \"Modifier\" , \"description\" : \"Modifiers change the bezier curves of neighbouring shapes\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/graphic-element\" } ] }, \"repeater-transform\" : { \"type\" : \"object\" , \"title\" : \"Repeater Transform\" , \"description\" : \"Transform used by a repeater, the transform is applied to each subsequent repeated object.\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/transform\" }, { \"type\" : \"object\" , \"properties\" : { \"so\" : { \"title\" : \"Start Opacity\" , \"description\" : \"Opacity of the first repeated object.\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"eo\" : { \"title\" : \"End Opacity\" , \"description\" : \"Opacity of the last repeated object.\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [] } ] }, \"zig-zag\" : { \"type\" : \"object\" , \"title\" : \"Zig Zag\" , \"description\" : \"Changes the edges of affected shapes into a series of peaks and valleys of uniform size\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/modifier\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"zz\" }, \"r\" : { \"title\" : \"Frequency\" , \"description\" : \"Number of ridges per segment\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"s\" : { \"title\" : \"Amplitude\" , \"description\" : \"Distance between peaks and troughs\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"pt\" : { \"title\" : \"Point Type\" , \"description\" : \"Point type (1 = corner, 2 = smooth)\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"rectangle\" : { \"type\" : \"object\" , \"title\" : \"Rectangle\" , \"description\" : \"A simple rectangle shape\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"rc\" }, \"p\" : { \"title\" : \"Position\" , \"description\" : \"Center of the rectangle\" , \"$ref\" : \"#/$defs/properties/position-property\" }, \"s\" : { \"title\" : \"Size\" , \"$ref\" : \"#/$defs/properties/vector-property\" }, \"r\" : { \"title\" : \"Rounded\" , \"description\" : \"Rounded corners radius\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" , \"s\" , \"p\" ] } ] }, \"base-gradient\" : { \"type\" : \"object\" , \"title\" : \"Base Gradient\" , \"description\" : \"Common properties for gradients\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"g\" : { \"title\" : \"Colors\" , \"description\" : \"Gradient colors\" , \"$ref\" : \"#/$defs/properties/gradient-property\" }, \"s\" : { \"title\" : \"Start Point\" , \"description\" : \"Starting point for the gradient\" , \"$ref\" : \"#/$defs/properties/position-property\" }, \"e\" : { \"title\" : \"End Point\" , \"description\" : \"End point for the gradient\" , \"$ref\" : \"#/$defs/properties/position-property\" }, \"t\" : { \"title\" : \"Gradient Type\" , \"description\" : \"Type of the gradient\" , \"$ref\" : \"#/$defs/constants/gradient-type\" }, \"h\" : { \"title\" : \"Highlight Length\" , \"description\" : \"Highlight Length, as a percentage between s and e \" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"a\" : { \"title\" : \"Highlight Angle\" , \"description\" : \"Highlight Angle in clockwise degrees, relative to the direction from s to e \" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"s\" , \"e\" , \"g\" , \"t\" ] } ] }, \"unknown-shape\" : { \"type\" : \"object\" , \"title\" : \"Unknown shape types\" , \"description\" : \"Unknown shape types. Types not defined by the specification are still allowed.\" , \"properties\" : { \"ty\" : { \"not\" : { \"$comment\" : \"enum list is dynamically generated\" , \"enum\" : [ \"el\" , \"fl\" , \"gf\" , \"gs\" , \"gr\" , \"mm\" , \"no\" , \"op\" , \"sh\" , \"sr\" , \"pb\" , \"rc\" , \"rp\" , \"rd\" , \"st\" , \"tr\" , \"tm\" , \"tw\" , \"zz\" ] } } } }, \"ellipse\" : { \"type\" : \"object\" , \"title\" : \"Ellipse\" , \"description\" : \"Ellipse shape\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"el\" }, \"p\" : { \"title\" : \"Position\" , \"$ref\" : \"#/$defs/properties/position-property\" }, \"s\" : { \"title\" : \"Size\" , \"$ref\" : \"#/$defs/properties/vector-property\" } }, \"required\" : [ \"ty\" , \"s\" , \"p\" ] } ] }, \"path\" : { \"type\" : \"object\" , \"title\" : \"Path\" , \"description\" : \"Custom Bezier shape\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"sh\" }, \"ks\" : { \"title\" : \"Shape\" , \"description\" : \"Bezier path\" , \"$ref\" : \"#/$defs/properties/bezier-property\" } }, \"required\" : [ \"ty\" , \"ks\" ] } ] }, \"polystar\" : { \"type\" : \"object\" , \"title\" : \"PolyStar\" , \"description\" : \"Star or regular polygon\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"sr\" }, \"p\" : { \"title\" : \"Position\" , \"$ref\" : \"#/$defs/properties/position-property\" }, \"or\" : { \"title\" : \"Outer Radius\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"os\" : { \"title\" : \"Outer Roundness\" , \"description\" : \"Outer Roundness as a percentage\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"r\" : { \"title\" : \"Rotation\" , \"description\" : \"Rotation, clockwise in degrees\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"pt\" : { \"title\" : \"Points\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"sy\" : { \"title\" : \"Star Type\" , \"$ref\" : \"#/$defs/constants/star-type\" , \"default\" : 1 }, \"ir\" : { \"title\" : \"Inner Radius\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"is\" : { \"title\" : \"Inner Roundness\" , \"description\" : \"Inner Roundness as a percentage\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" , \"or\" , \"os\" , \"pt\" , \"p\" , \"r\" ] }, { \"if\" : { \"properties\" : { \"sy\" : { \"const\" : 1 } } }, \"then\" : { \"required\" : [ \"ir\" , \"is\" ] } } ] }, \"no-style\" : { \"type\" : \"object\" , \"title\" : \"No Style\" , \"description\" : \"Represents a style for shapes without fill or stroke\" , \"deprecated\" : true , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"no\" } }, \"required\" : [ \"ty\" ] } ] }, \"repeater\" : { \"type\" : \"object\" , \"title\" : \"Repeater\" , \"description\" : \"Duplicates previous shapes in a group\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/modifier\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"rp\" }, \"c\" : { \"title\" : \"Copies\" , \"description\" : \"Number of copies\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"o\" : { \"title\" : \"Offset\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"m\" : { \"title\" : \"Composite\" , \"description\" : \"Stacking order\" , \"$ref\" : \"#/$defs/constants/composite\" , \"default\" : 1 }, \"tr\" : { \"title\" : \"Transform\" , \"description\" : \"Transform applied to each copy\" , \"$ref\" : \"#/$defs/shapes/repeater-transform\" } }, \"required\" : [ \"ty\" , \"c\" , \"tr\" ] } ] }, \"group\" : { \"type\" : \"object\" , \"title\" : \"Group\" , \"description\" : \"Shape Element that can contain other shapes\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/graphic-element\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"gr\" }, \"np\" : { \"title\" : \"Number Of Properties\" , \"type\" : \"number\" }, \"it\" : { \"title\" : \"Shapes\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/shapes/all-graphic-elements\" } }, \"cix\" : { \"title\" : \"Property index\" , \"description\" : \"Index used in expressions\" , \"type\" : \"integer\" } }, \"required\" : [ \"ty\" ] } ] }, \"pucker-bloat\" : { \"type\" : \"object\" , \"title\" : \"Pucker Bloat\" , \"description\" : \"Interpolates the shape with its center point and bezier tangents with the opposite direction\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/modifier\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"pb\" }, \"a\" : { \"title\" : \"Amount\" , \"description\" : \"Amount as a percentage\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"gradient-fill\" : { \"type\" : \"object\" , \"title\" : \"Gradient\" , \"description\" : \"Gradient fill color\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-style\" }, { \"$ref\" : \"#/$defs/shapes/base-gradient\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"gf\" }, \"r\" : { \"title\" : \"Fill Rule\" , \"$ref\" : \"#/$defs/constants/fill-rule\" } }, \"required\" : [ \"ty\" ] } ] }, \"fill\" : { \"type\" : \"object\" , \"title\" : \"Fill\" , \"description\" : \"Solid fill color\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"fl\" }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/properties/color-property\" }, \"r\" : { \"title\" : \"Fill Rule\" , \"$ref\" : \"#/$defs/constants/fill-rule\" } }, \"required\" : [ \"ty\" , \"c\" ] } ] } }, \"styles\" : { \"outer-glow-style\" : { \"type\" : \"object\" , \"title\" : \"Outer Glow\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 3 }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/properties/color-property\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"r\" : { \"title\" : \"Range\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"ch\" : { \"title\" : \"Choke Spread\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"no\" : { \"title\" : \"Noise\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"j\" : { \"title\" : \"Jitter\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"stroke-style\" : { \"type\" : \"object\" , \"title\" : \"Layer Stroke\" , \"description\" : \"Stroke / frame\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 0 }, \"s\" : { \"title\" : \"Size\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/properties/color-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"drop-shadow-style\" : { \"type\" : \"object\" , \"title\" : \"Drop Shadow\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 1 }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/properties/color-property\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"a\" : { \"title\" : \"Angle\" , \"description\" : \"Local light angle\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"s\" : { \"title\" : \"Size\" , \"description\" : \"Blur size\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"d\" : { \"title\" : \"Distance\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"ch\" : { \"title\" : \"Choke Spread\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"no\" : { \"title\" : \"Noise\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"lc\" : { \"title\" : \"Layer Conceal\" , \"description\" : \"Layer knowck out drop shadow\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"layer-style\" : { \"type\" : \"object\" , \"title\" : \"Layer Style\" , \"description\" : \"Style applied to a layer\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Style Type\" , \"type\" : \"integer\" } }, \"required\" : [ \"ty\" ] } ] }, \"all-layer-styles\" : { \"oneOf\" : [ { \"$ref\" : \"#/$defs/styles/bevel-emboss-style\" }, { \"$ref\" : \"#/$defs/styles/color-overlay-style\" }, { \"$ref\" : \"#/$defs/styles/drop-shadow-style\" }, { \"$ref\" : \"#/$defs/styles/gradient-overlay-style\" }, { \"$ref\" : \"#/$defs/styles/inner-glow-style\" }, { \"$ref\" : \"#/$defs/styles/inner-shadow-style\" }, { \"$ref\" : \"#/$defs/styles/outer-glow-style\" }, { \"$ref\" : \"#/$defs/styles/satin-style\" }, { \"$ref\" : \"#/$defs/styles/stroke-style\" } ] }, \"inner-glow-style\" : { \"type\" : \"object\" , \"title\" : \"Inner Glow\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 4 }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/properties/color-property\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"r\" : { \"title\" : \"Range\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"sr\" : { \"title\" : \"Source\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"ch\" : { \"title\" : \"Choke Spread\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"no\" : { \"title\" : \"Noise\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"j\" : { \"title\" : \"Jitter\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"satin-style\" : { \"type\" : \"object\" , \"title\" : \"Satin\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 6 }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/properties/color-property\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"a\" : { \"title\" : \"Angle\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"d\" : { \"title\" : \"Distance\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"s\" : { \"title\" : \"Size\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"in\" : { \"title\" : \"Invert\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"color-overlay-style\" : { \"type\" : \"object\" , \"title\" : \"Color Overlay\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 7 }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/properties/color-property\" }, \"so\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"inner-shadow-style\" : { \"type\" : \"object\" , \"title\" : \"Inner Shadow\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 2 }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/properties/color-property\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"a\" : { \"title\" : \"Angle\" , \"description\" : \"Local light angle\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"s\" : { \"title\" : \"Size\" , \"description\" : \"Blur size\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"d\" : { \"title\" : \"Distance\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"ch\" : { \"title\" : \"Choke Spread\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"no\" : { \"title\" : \"Noise\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"gradient-overlay-style\" : { \"type\" : \"object\" , \"title\" : \"Gradient Overlay\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 8 }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"gf\" : { \"title\" : \"Gradient\" , \"$ref\" : \"#/$defs/properties/gradient-property\" }, \"gs\" : { \"title\" : \"Smoothness\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"a\" : { \"title\" : \"Angle\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"gt\" : { \"title\" : \"Gradient Type\" , \"$ref\" : \"#/$defs/constants/gradient-type\" }, \"re\" : { \"title\" : \"Reverse\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"al\" : { \"title\" : \"Align\" , \"description\" : \"Align with layer\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"s\" : { \"title\" : \"Scale\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"of\" : { \"title\" : \"Offset\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"bevel-emboss-style\" : { \"type\" : \"object\" , \"title\" : \"Bevel Emboss\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 5 }, \"bs\" : { \"title\" : \"Bevel Style\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"bt\" : { \"title\" : \"Technique\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"sr\" : { \"title\" : \"Strength\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"s\" : { \"title\" : \"Size\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"sf\" : { \"title\" : \"Soften\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"ga\" : { \"title\" : \"Global Angle\" , \"description\" : \"Use global light\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"a\" : { \"title\" : \"Angle\" , \"description\" : \"Local lighting angle\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"ll\" : { \"title\" : \"Altitude\" , \"description\" : \"Local lighting altitude\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"hm\" : { \"title\" : \"Highlight Mode\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"hc\" : { \"title\" : \"Highlight Color\" , \"$ref\" : \"#/$defs/properties/color-property\" }, \"ho\" : { \"title\" : \"Highlight Opacity\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"sm\" : { \"title\" : \"Shadow Mode\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"sc\" : { \"title\" : \"Shadow Color\" , \"$ref\" : \"#/$defs/properties/color-property\" }, \"so\" : { \"title\" : \"Shadow Opacity\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] } }, \"text\" : { \"text-document-keyframe\" : { \"type\" : \"object\" , \"title\" : \"Text Document Keyframe\" , \"description\" : \"A keyframe containing a text document\" , \"properties\" : { \"s\" : { \"title\" : \"Start\" , \"$ref\" : \"#/$defs/text/text-document\" }, \"t\" : { \"title\" : \"Time\" , \"type\" : \"number\" , \"default\" : 0 } }, \"required\" : [ \"s\" , \"t\" ] }, \"character-shapes\" : { \"type\" : \"object\" , \"title\" : \"Character Shape\" , \"description\" : \"Defines a character as shapes\" , \"properties\" : { \"shapes\" : { \"title\" : \"Shapes\" , \"description\" : \"Shapes forming the character\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/shapes/all-graphic-elements\" } } }, \"required\" : [ \"shapes\" ] }, \"font\" : { \"type\" : \"object\" , \"title\" : \"Font\" , \"description\" : \"Describes how a font with given settings should be loaded\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"ascent\" : { \"title\" : \"Ascent\" , \"type\" : \"number\" , \"description\" : \"Text will be moved down based on this value\" }, \"fFamily\" : { \"title\" : \"Font Family\" , \"type\" : \"string\" , \"default\" : \"sans\" }, \"fName\" : { \"title\" : \"Name\" , \"description\" : \"Name used by text documents to reference this font, usually it's fFamily followed by fStyle \" , \"type\" : \"string\" , \"default\" : \"sans-Regular\" }, \"fStyle\" : { \"title\" : \"Font Style\" , \"examples\" : [ \"Regular\" , \"Bold\" , \"Bold Italic\" ], \"type\" : \"string\" , \"default\" : \"Regular\" }, \"fPath\" : { \"title\" : \"Path\" , \"type\" : \"string\" }, \"fWeight\" : { \"title\" : \"Weight\" , \"type\" : \"string\" }, \"origin\" : { \"title\" : \"Origin\" , \"$ref\" : \"#/$defs/constants/font-path-origin\" }, \"fClass\" : { \"type\" : \"string\" , \"title\" : \"CSS Class\" , \"description\" : \"CSS Class applied to text objects using this font\" } }, \"required\" : [ \"fFamily\" , \"fName\" , \"fStyle\" ] } ] }, \"text-data\" : { \"type\" : \"object\" , \"title\" : \"Text Data\" , \"description\" : \"Contains all the text data and animation\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"a\" : { \"title\" : \"Ranges\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/text/text-range\" } }, \"d\" : { \"title\" : \"Document\" , \"$ref\" : \"#/$defs/text/animated-text-document\" }, \"m\" : { \"title\" : \"Alignment\" , \"$ref\" : \"#/$defs/text/text-alignment-options\" }, \"p\" : { \"title\" : \"Follow Path\" , \"$ref\" : \"#/$defs/text/text-follow-path\" } }, \"required\" : [ \"a\" , \"d\" , \"m\" , \"p\" ] } ] }, \"text-follow-path\" : { \"type\" : \"object\" , \"title\" : \"Text Follow Path\" , \"description\" : \"Uses the path described by a layer mask to put the text on said path.\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"m\" : { \"title\" : \"Mask\" , \"type\" : \"integer\" , \"description\" : \"Index of the mask to use\" }, \"f\" : { \"title\" : \"First Margin\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"l\" : { \"title\" : \"Last Margin\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"r\" : { \"title\" : \"Reverse Path\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"a\" : { \"title\" : \"Force Alignment\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"p\" : { \"title\" : \"Perpendicular To Path\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [] } ] }, \"text-range\" : { \"type\" : \"object\" , \"title\" : \"Text Range\" , \"description\" : \"Range of text with custom animations and style\" , \"properties\" : { \"nm\" : { \"title\" : \"Name\" , \"type\" : \"string\" }, \"s\" : { \"title\" : \"Selector\" , \"$ref\" : \"#/$defs/text/text-range-selector\" }, \"a\" : { \"title\" : \"Style\" , \"$ref\" : \"#/$defs/text/text-style\" } } }, \"text-document\" : { \"type\" : \"object\" , \"title\" : \"Text Document\" , \"description\" : \"\" , \"properties\" : { \"f\" : { \"title\" : \"Font Family\" , \"type\" : \"string\" , \"default\" : \"\" }, \"fc\" : { \"title\" : \"Fill Color\" , \"$ref\" : \"#/$defs/values/color\" , \"default\" : [ 0 , 0 , 0 ] }, \"sc\" : { \"title\" : \"Stroke Color\" , \"$ref\" : \"#/$defs/values/color\" }, \"sw\" : { \"title\" : \"Stroke Width\" , \"type\" : \"number\" , \"default\" : 0 }, \"of\" : { \"title\" : \"Stroke Over Fill\" , \"description\" : \"Render stroke above the fill\" , \"type\" : \"boolean\" }, \"s\" : { \"title\" : \"Font Size\" , \"type\" : \"number\" , \"default\" : 10 }, \"lh\" : { \"title\" : \"Line Height\" , \"description\" : \"Distance between lines on multiline or wrapped text\" , \"type\" : \"number\" }, \"sz\" : { \"title\" : \"Wrap Size\" , \"description\" : \"Size of the box containing the text\" , \"type\" : \"array\" , \"minItems\" : 2 , \"maxItems\" : 2 , \"items\" : { \"type\" : \"number\" } }, \"ps\" : { \"title\" : \"Wrap Position\" , \"description\" : \"Position of the box containing the text\" , \"type\" : \"array\" , \"minItems\" : 2 , \"maxItems\" : 2 , \"items\" : { \"type\" : \"number\" } }, \"t\" : { \"title\" : \"Text\" , \"type\" : \"string\" , \"description\" : \"Text, note that newlines are encoded with \\r\" , \"default\" : \"\" }, \"j\" : { \"title\" : \"Justify\" , \"$ref\" : \"#/$defs/constants/text-justify\" , \"default\" : 0 }, \"ca\" : { \"title\" : \"Text Caps\" , \"$ref\" : \"#/$defs/constants/text-caps\" }, \"tr\" : { \"title\" : \"Tracking\" , \"description\" : \"Text Tracking\" , \"type\" : \"number\" }, \"ls\" : { \"title\" : \"Baseline Shift\" , \"type\" : \"number\" , \"default\" : 0 } }, \"required\" : [ \"f\" , \"fc\" , \"s\" , \"t\" ] }, \"text-style\" : { \"type\" : \"object\" , \"title\" : \"Text Style\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/transform\" }, { \"type\" : \"object\" , \"properties\" : { \"sw\" : { \"title\" : \"Stroke Width\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"sc\" : { \"title\" : \"Stroke Color\" , \"$ref\" : \"#/$defs/properties/color-property\" }, \"sh\" : { \"title\" : \"Stroke Hue\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"ss\" : { \"title\" : \"Stroke Saturation\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"sb\" : { \"title\" : \"Stroke Brightness\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"so\" : { \"title\" : \"Stroke Opacity\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"fc\" : { \"title\" : \"Fill Color\" , \"$ref\" : \"#/$defs/properties/color-property\" }, \"fh\" : { \"title\" : \"Fill Hue\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"fs\" : { \"title\" : \"Fill Saturation\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"fb\" : { \"title\" : \"Fill Brightness\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"fo\" : { \"title\" : \"Fill Opacity\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"t\" : { \"title\" : \"Letter Spacing\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"bl\" : { \"title\" : \"Blur\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"ls\" : { \"title\" : \"Line Spacing\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [] } ] }, \"font-list\" : { \"type\" : \"object\" , \"title\" : \"Font List\" , \"description\" : \"List of fonts\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"list\" : { \"title\" : \"List\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/text/font\" } } }, \"required\" : [] } ] }, \"text-range-selector\" : { \"type\" : \"object\" , \"title\" : \"Text Range Selector\" , \"properties\" : { \"t\" : { \"title\" : \"Expressible\" , \"$ref\" : \"#/$defs/values/int-boolean\" }, \"xe\" : { \"title\" : \"Max Ease\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"ne\" : { \"title\" : \"Min Ease\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"a\" : { \"title\" : \"Max Amount\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"b\" : { \"title\" : \"Based On\" , \"$ref\" : \"#/$defs/constants/text-based\" }, \"rn\" : { \"title\" : \"Randomize\" , \"$ref\" : \"#/$defs/values/int-boolean\" }, \"sh\" : { \"title\" : \"Shape\" , \"$ref\" : \"#/$defs/constants/text-shape\" }, \"o\" : { \"title\" : \"Offset\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"r\" : { \"title\" : \"Range Units\" , \"$ref\" : \"#/$defs/constants/text-range-units\" }, \"sm\" : { \"title\" : \"Selector Smoothness\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"s\" : { \"title\" : \"Start\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"e\" : { \"title\" : \"End\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"t\" , \"a\" , \"b\" , \"sh\" ] }, \"animated-text-document\" : { \"type\" : \"object\" , \"title\" : \"Animated Text Document\" , \"description\" : \"Animated property representing the text contents\" , \"properties\" : { \"k\" : { \"title\" : \"Keyframes\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/text/text-document-keyframe\" } }, \"x\" : { \"title\" : \"Expression\" , \"type\" : \"string\" }, \"sid\" : { \"title\" : \"Slot ID\" , \"description\" : \"One of the ID in the file's slots\" , \"type\" : \"string\" } }, \"required\" : [ \"k\" ] }, \"text-alignment-options\" : { \"type\" : \"object\" , \"title\" : \"Text Alignment Options\" , \"description\" : \"\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"a\" : { \"title\" : \"Alignment\" , \"description\" : \"Group alignment\" , \"$ref\" : \"#/$defs/properties/vector-property\" }, \"g\" : { \"title\" : \"Grouping\" , \"description\" : \"Anchor point grouping\" , \"$ref\" : \"#/$defs/constants/text-grouping\" } }, \"required\" : [] } ] }, \"character-precomp\" : { \"type\" : \"object\" , \"title\" : \"Character Precomp\" , \"description\" : \"Defines a character as a precomp layer\" , \"properties\" : { \"refId\" : { \"title\" : \"Reference Id\" , \"description\" : \"ID of the precomp as specified in the assets\" , \"type\" : \"string\" }, \"ks\" : { \"title\" : \"Transform\" , \"description\" : \"Layer transform\" , \"$ref\" : \"#/$defs/helpers/transform\" }, \"ip\" : { \"title\" : \"In Point\" , \"description\" : \"Frame when the layer becomes visible\" , \"type\" : \"number\" , \"default\" : 0 }, \"op\" : { \"title\" : \"Out Point\" , \"description\" : \"Frame when the layer becomes invisible\" , \"type\" : \"number\" , \"default\" : 99999 }, \"sr\" : { \"title\" : \"Time Stretch\" , \"type\" : \"number\" , \"default\" : 1 }, \"st\" : { \"title\" : \"Start Time\" , \"type\" : \"number\" , \"default\" : 0 } }, \"required\" : [ \"refId\" ] }, \"character-data\" : { \"type\" : \"object\" , \"title\" : \"Character Data\" , \"description\" : \"Defines character shapes\" , \"properties\" : { \"ch\" : { \"title\" : \"Character\" , \"type\" : \"string\" , \"default\" : \"\" }, \"fFamily\" : { \"title\" : \"Font Family\" , \"type\" : \"string\" , \"default\" : \"\" }, \"size\" : { \"title\" : \"Font Size\" , \"type\" : \"number\" , \"default\" : 0 }, \"style\" : { \"title\" : \"Font Style\" , \"type\" : \"string\" , \"default\" : \"\" }, \"w\" : { \"title\" : \"Width\" , \"type\" : \"number\" , \"default\" : 0 }, \"data\" : { \"title\" : \"Data\" , \"oneOf\" : [ { \"$ref\" : \"#/$defs/text/character-shapes\" }, { \"$ref\" : \"#/$defs/text/character-precomp\" } ] } }, \"required\" : [ \"data\" , \"ch\" , \"fFamily\" , \"size\" , \"style\" , \"w\" ] } }, \"values\" : { \"hexcolor\" : { \"type\" : \"string\" , \"title\" : \"Hex Color\" , \"description\" : \"Color value in hexadecimal format, with two digits per component ('#RRGGBB')\" , \"pattern\" : \"^#([a-fA-F0-9]{6})$\" , \"examples\" : [ \"#FF00AA\" ] }, \"int-boolean\" : { \"type\" : \"integer\" , \"title\" : \"Integer Boolean\" , \"description\" : \"Represents boolean values as an integer. 0 is false, 1 is true.\" , \"default\" : 0 , \"examples\" : [ 0 ], \"enum\" : [ 0 , 1 ], \"oneOf\" : [ { \"title\" : \"True\" , \"const\" : 1 }, { \"title\" : \"False\" , \"const\" : 0 } ] }, \"gradient\" : { \"type\" : \"array\" , \"title\" : \"Gradient\" , \"description\" : \"A flat list of color stops followed by optional transparency stops. A color stop is [offset, red, green, blue]. A transparency stop is [offset, transparency]. All values are between 0 and 1\" , \"items\" : { \"type\" : \"number\" , \"minimum\" : 0 , \"maximum\" : 1 } }, \"bezier\" : { \"type\" : \"object\" , \"title\" : \"Bezier\" , \"description\" : \"Cubic polybezier\" , \"properties\" : { \"c\" : { \"title\" : \"Closed\" , \"type\" : \"boolean\" , \"default\" : false }, \"i\" : { \"title\" : \"In Tangents\" , \"type\" : \"array\" , \"description\" : \"Array of points, each point is an array of coordinates.\\nThese points are along the in tangents relative to the corresponding v .\" , \"items\" : { \"$ref\" : \"#/$defs/values/vector\" , \"default\" : [] } }, \"o\" : { \"title\" : \"Out Tangents\" , \"type\" : \"array\" , \"description\" : \"Array of points, each point is an array of coordinates.\\nThese points are along the out tangents relative to the corresponding v .\" , \"items\" : { \"$ref\" : \"#/$defs/values/vector\" , \"default\" : [] } }, \"v\" : { \"title\" : \"Vertices\" , \"description\" : \"Array of points, each point is an array of coordinates.\\nThese points are along the bezier path\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/values/vector\" , \"default\" : [] } } }, \"required\" : [ \"i\" , \"v\" , \"o\" ] }, \"color\" : { \"type\" : \"array\" , \"title\" : \"Color\" , \"description\" : \"Color as a [r, g, b] array with values in [0, 1]\" , \"items\" : { \"type\" : \"number\" , \"minimum\" : 0 , \"maximum\" : 1 }, \"minItems\" : 3 , \"maxItems\" : 4 }, \"data-url\" : { \"type\" : \"string\" , \"title\" : \"Data URL\" , \"description\" : \"An embedded data object\" , \"pattern\" : \"^data:([\\w/]+)(;base64)?,(.+)$\" }, \"vector\" : { \"type\" : \"array\" , \"title\" : \"Vector\" , \"description\" : \"An array of numbers\" , \"items\" : { \"type\" : \"number\" } } } } }","title":"JSON Schema"},{"location":"schema/#json-schema","text":"This page shows a formatted version of the JSON schema, you can click on highlighted objects to get a link to that section of the schema. You can also click on $ref values to jump to the relevant section. If you want you can also view the raw schema file . { \"$schema\" : \"https://json-schema.org/draft/2020-12/schema\" , \"$id\" : \"https://lottiefiles.github.io/lottie-docs/schema/lottie.schema.json\" , \"$ref\" : \"#/$defs/composition/animation\" , \"$defs\" : { \"assets\" : { \"image\" : { \"type\" : \"object\" , \"title\" : \"Image\" , \"description\" : \"Asset containing an image that can be referenced by layers.\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/assets/file-asset\" }, { \"$ref\" : \"#/$defs/helpers/slottable-object\" }, { \"type\" : \"object\" , \"properties\" : { \"w\" : { \"title\" : \"Width\" , \"description\" : \"Width of the image\" , \"type\" : \"number\" }, \"h\" : { \"title\" : \"Height\" , \"description\" : \"Height of the image\" , \"type\" : \"number\" }, \"t\" : { \"title\" : \"Type\" , \"description\" : \"Marks as part of an image sequence if present\" , \"type\" : \"string\" , \"const\" : \"seq\" } }, \"if\" : { \"required\" : [ \"sid\" ] }, \"else\" : { \"required\" : [ \"w\" , \"h\" , \"p\" ] } } ] }, \"asset\" : { \"type\" : \"object\" , \"title\" : \"Asset\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"id\" : { \"title\" : \"ID\" , \"description\" : \"Unique identifier used by layers when referencing this asset\" , \"type\" : \"string\" } }, \"required\" : [ \"id\" ] } ] }, \"data-source\" : { \"type\" : \"object\" , \"title\" : \"Data source\" , \"description\" : \"External data source, usually a JSON file\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/assets/file-asset\" }, { \"type\" : \"object\" , \"properties\" : { \"t\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 3 } }, \"required\" : [ \"t\" ] } ] }, \"all-assets\" : { \"oneOf\" : [ { \"$ref\" : \"#/$defs/assets/precomposition\" }, { \"$ref\" : \"#/$defs/assets/image\" }, { \"$ref\" : \"#/$defs/assets/data-source\" }, { \"$ref\" : \"#/$defs/assets/sound\" } ] }, \"file-asset\" : { \"type\" : \"object\" , \"title\" : \"File Asset\" , \"description\" : \"Asset referencing a file\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/assets/asset\" }, { \"type\" : \"object\" , \"properties\" : { \"p\" : { \"title\" : \"File Name\" , \"description\" : \"Name of the asset file or a data url\" , \"type\" : \"string\" }, \"u\" : { \"title\" : \"File Path\" , \"description\" : \"Path to the asset file\" , \"type\" : \"string\" }, \"e\" : { \"title\" : \"Embedded\" , \"description\" : \"If '1', 'p' is a Data URL\" , \"$ref\" : \"#/$defs/values/int-boolean\" } }, \"if\" : { \"properties\" : { \"e\" : { \"const\" : 1 } }, \"required\" : [ \"e\" ] }, \"then\" : { \"properties\" : { \"p\" : { \"$ref\" : \"#/$defs/values/data-url\" } } } } ] }, \"precomposition\" : { \"type\" : \"object\" , \"title\" : \"Precomposition\" , \"description\" : \"Asset containing a composition that can be referenced by layers.\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/assets/asset\" }, { \"$ref\" : \"#/$defs/composition/composition\" }, { \"type\" : \"object\" , \"properties\" : { \"fr\" : { \"title\" : \"Framerate\" , \"description\" : \"Framerate in frames per second\" , \"type\" : \"number\" }, \"xt\" : { \"title\" : \"Extra\" , \"description\" : \"Extra composition\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"default\" : 0 } } } ] }, \"sound\" : { \"type\" : \"object\" , \"title\" : \"Sound\" , \"description\" : \"External sound\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/assets/file-asset\" } ] } }, \"composition\" : { \"metadata\" : { \"type\" : \"object\" , \"title\" : \"Metadata\" , \"description\" : \"Document metadata\" , \"properties\" : { \"a\" : { \"title\" : \"Author\" , \"type\" : \"string\" }, \"d\" : { \"title\" : \"Description\" , \"type\" : \"string\" }, \"tc\" : { \"title\" : \"Theme Color\" , \"type\" : \"string\" }, \"g\" : { \"title\" : \"Generator\" , \"description\" : \"Software used to generate the file\" , \"type\" : \"string\" } }, \"anyOf\" : [ { \"properties\" : { \"k\" : { \"title\" : \"Keywords\" , \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" } } } }, { \"properties\" : { \"k\" : { \"title\" : \"Keywords\" , \"type\" : \"string\" } } } ] }, \"composition\" : { \"type\" : \"object\" , \"title\" : \"Composition\" , \"description\" : \"An object that contains a list of layers\" , \"properties\" : { \"layers\" : { \"title\" : \"Layers\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/layers/all-layers\" } } }, \"required\" : [ \"layers\" ] }, \"animation\" : { \"type\" : \"object\" , \"title\" : \"Animation\" , \"description\" : \"Top level object, describing the animation\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"v\" : { \"title\" : \"Bodymovin version, on very old versions some things might be slightly different from what is explained here\" , \"type\" : \"string\" }, \"ver\" : { \"title\" : \"Specification Version\" , \"description\" : \"Specification version this Lottie is targeting. This is a 6 digit number with version components encoded as MMmmpp , with MM being major version, mm being minor and pp being patch.\" , \"type\" : \"integer\" , \"minimum\" : 10000 }, \"fr\" : { \"title\" : \"Framerate\" , \"description\" : \"Framerate in frames per second\" , \"type\" : \"number\" , \"exclusiveMinimum\" : 0 }, \"ip\" : { \"title\" : \"In Point\" , \"description\" : \"Frame the animation starts at (usually 0)\" , \"type\" : \"number\" }, \"op\" : { \"title\" : \"Out Point\" , \"description\" : \"Frame the animation stops/loops at, which makes this the duration in frames when ip is 0\" , \"type\" : \"number\" }, \"w\" : { \"title\" : \"Width\" , \"description\" : \"Width of the animation\" , \"type\" : \"integer\" , \"minimum\" : 0 }, \"h\" : { \"title\" : \"Height\" , \"description\" : \"Height of the animation\" , \"type\" : \"integer\" , \"minimum\" : 0 }, \"ddd\" : { \"title\" : \"Threedimensional\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"default\" : 0 , \"description\" : \"Whether the animation has 3D layers\" }, \"assets\" : { \"title\" : \"Assets\" , \"type\" : \"array\" , \"description\" : \"List of assets that can be referenced by layers\" , \"items\" : { \"$ref\" : \"#/$defs/assets/all-assets\" } }, \"comps\" : { \"title\" : \"Extra Compositions\" , \"type\" : \"array\" , \"description\" : \"List of Extra compositions not referenced by anything\" , \"items\" : { \"$ref\" : \"#/$defs/assets/precomposition\" } }, \"fonts\" : { \"title\" : \"Fonts\" , \"$ref\" : \"#/$defs/text/font-list\" }, \"chars\" : { \"title\" : \"Characters\" , \"description\" : \"Data defining text characters as lottie shapes. If present a player might only render characters defined here and nothing else.\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/text/character-data\" } }, \"meta\" : { \"title\" : \"Metadata\" , \"description\" : \"Document metadata\" , \"$ref\" : \"#/$defs/composition/metadata\" }, \"metadata\" : { \"title\" : \"User Metadata\" , \"$ref\" : \"#/$defs/composition/user-metadata\" }, \"markers\" : { \"title\" : \"Markers\" , \"description\" : \"Markers defining named sections of the composition.\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/helpers/marker\" } }, \"mb\" : { \"title\" : \"Motion Blur\" , \"$ref\" : \"#/$defs/composition/motion-blur\" }, \"slots\" : { \"title\" : \"Slots\" , \"description\" : \"Dictionary of slot ids that will replace matching properties.\" , \"type\" : \"object\" , \"additionalProperties\" : { \"$ref\" : \"#/$defs/helpers/slot\" } } }, \"required\" : [ \"w\" , \"h\" , \"fr\" , \"op\" , \"ip\" ] }, { \"$ref\" : \"#/$defs/composition/composition\" } ] }, \"user-metadata\" : { \"type\" : \"object\" , \"title\" : \"User Metadata\" , \"description\" : \"User-defined metadata\" , \"properties\" : { \"filename\" : { \"title\" : \"Filename\" , \"type\" : \"string\" }, \"customProps\" : { \"title\" : \"Custom Properties\" , \"type\" : \"object\" } } }, \"motion-blur\" : { \"type\" : \"object\" , \"title\" : \"Motion Blur\" , \"description\" : \"Motion blur settings\" , \"properties\" : { \"sa\" : { \"title\" : \"Shutter Angle\" , \"description\" : \"Angle in degrees\" , \"type\" : \"number\" }, \"sp\" : { \"title\" : \"Shutter Phase\" , \"description\" : \"Angle in degrees\" , \"type\" : \"number\" }, \"spf\" : { \"title\" : \"Samples per Frame\" , \"type\" : \"number\" }, \"asl\" : { \"title\" : \"Adaptive Sample Limit\" , \"type\" : \"number\" } } } }, \"constants\" : { \"font-path-origin\" : { \"type\" : \"integer\" , \"title\" : \"Font Path Origin\" , \"description\" : \"\" , \"oneOf\" : [ { \"title\" : \"Local\" , \"const\" : 0 }, { \"title\" : \"Css Url\" , \"const\" : 1 }, { \"title\" : \"Script Url\" , \"const\" : 2 }, { \"title\" : \"Font Url\" , \"const\" : 3 } ] }, \"stroke-dash-type\" : { \"type\" : \"string\" , \"title\" : \"Stroke Dash Type\" , \"description\" : \"Type of a dash item in a stroked line\" , \"oneOf\" : [ { \"title\" : \"Dash\" , \"const\" : \"d\" }, { \"title\" : \"Gap\" , \"const\" : \"g\" }, { \"title\" : \"Offset\" , \"const\" : \"o\" } ] }, \"merge-mode\" : { \"type\" : \"integer\" , \"title\" : \"Merge Mode\" , \"description\" : \"Boolean operation on shapes\" , \"oneOf\" : [ { \"title\" : \"Normal\" , \"const\" : 1 }, { \"title\" : \"Add\" , \"const\" : 2 }, { \"title\" : \"Subtract\" , \"const\" : 3 }, { \"title\" : \"Intersect\" , \"const\" : 4 }, { \"title\" : \"Exclude Intersections\" , \"const\" : 5 } ] }, \"gradient-type\" : { \"type\" : \"integer\" , \"title\" : \"Gradient Type\" , \"description\" : \"Whether a Gradient is a linear or radial.\" , \"oneOf\" : [ { \"title\" : \"Linear\" , \"description\" : \"Colors transition in a single linear direction.\" , \"const\" : 1 }, { \"title\" : \"Radial\" , \"description\" : \"Colors transition outward from a center point.\" , \"const\" : 2 } ] }, \"text-range-units\" : { \"type\" : \"integer\" , \"title\" : \"Text Range Units\" , \"description\" : \"Unit type for a text selector\" , \"oneOf\" : [ { \"title\" : \"Percent\" , \"const\" : 1 }, { \"title\" : \"Index\" , \"const\" : 2 } ] }, \"blend-mode\" : { \"type\" : \"integer\" , \"title\" : \"Blend Mode\" , \"description\" : \"Layer and shape blend mode\" , \"oneOf\" : [ { \"title\" : \"Normal\" , \"const\" : 0 }, { \"title\" : \"Multiply\" , \"const\" : 1 }, { \"title\" : \"Screen\" , \"const\" : 2 }, { \"title\" : \"Overlay\" , \"const\" : 3 }, { \"title\" : \"Darken\" , \"const\" : 4 }, { \"title\" : \"Lighten\" , \"const\" : 5 }, { \"title\" : \"Color Dodge\" , \"const\" : 6 }, { \"title\" : \"Color Burn\" , \"const\" : 7 }, { \"title\" : \"Hard Light\" , \"const\" : 8 }, { \"title\" : \"Soft Light\" , \"const\" : 9 }, { \"title\" : \"Difference\" , \"const\" : 10 }, { \"title\" : \"Exclusion\" , \"const\" : 11 }, { \"title\" : \"Hue\" , \"const\" : 12 }, { \"title\" : \"Saturation\" , \"const\" : 13 }, { \"title\" : \"Color\" , \"const\" : 14 }, { \"title\" : \"Luminosity\" , \"const\" : 15 }, { \"title\" : \"Add\" , \"const\" : 16 }, { \"title\" : \"Hard Mix\" , \"const\" : 17 } ] }, \"trim-multiple-shapes\" : { \"type\" : \"integer\" , \"title\" : \"Trim Multiple Shapes\" , \"description\" : \"How to handle multiple shapes in trim path\" , \"oneOf\" : [ { \"title\" : \"Parallel\" , \"description\" : \"All shapes apply the trim at the same time\" , \"const\" : 1 }, { \"title\" : \"Sequential\" , \"description\" : \"Shapes are considered as a continuous sequence\" , \"const\" : 2 } ] }, \"composite\" : { \"type\" : \"integer\" , \"title\" : \"Composite\" , \"description\" : \"How to stack copies in a repeater\" , \"oneOf\" : [ { \"title\" : \"Below\" , \"description\" : \"Subsequent copies are added underneath the previous ones.\" , \"const\" : 1 }, { \"title\" : \"Above\" , \"description\" : \"Subsequent copies are added on top of the previous ones.\" , \"const\" : 2 } ] }, \"fill-rule\" : { \"type\" : \"integer\" , \"title\" : \"Fill Rule\" , \"description\" : \"Rule used to handle multiple shapes rendered with the same fill object\" , \"oneOf\" : [ { \"title\" : \"Non Zero\" , \"description\" : \"Everything is colored (You can think of this as an OR)\" , \"const\" : 1 }, { \"title\" : \"Even Odd\" , \"description\" : \"Colored based on intersections and path direction, can be used to create \\\"holes\\\"\" , \"const\" : 2 } ] }, \"text-grouping\" : { \"type\" : \"integer\" , \"title\" : \"Text Grouping\" , \"description\" : \"\" , \"oneOf\" : [ { \"title\" : \"Characters\" , \"const\" : 1 }, { \"title\" : \"Word\" , \"const\" : 2 }, { \"title\" : \"Line\" , \"const\" : 3 }, { \"title\" : \"All\" , \"const\" : 4 } ] }, \"star-type\" : { \"type\" : \"integer\" , \"title\" : \"Star Type\" , \"description\" : \"Whether a PolyStar is a star or a polygon\" , \"oneOf\" : [ { \"title\" : \"Star\" , \"const\" : 1 }, { \"title\" : \"Polygon\" , \"const\" : 2 } ] }, \"text-shape\" : { \"type\" : \"integer\" , \"title\" : \"Text Shape\" , \"description\" : \"Defines the function used to determine the interpolating factor on a text range selector.\" , \"oneOf\" : [ { \"title\" : \"Square\" , \"const\" : 1 }, { \"title\" : \"Ramp Up\" , \"const\" : 2 }, { \"title\" : \"Ramp Down\" , \"const\" : 3 }, { \"title\" : \"Triangle\" , \"const\" : 4 }, { \"title\" : \"Round\" , \"const\" : 5 }, { \"title\" : \"Smooth\" , \"const\" : 6 } ] }, \"shape-direction\" : { \"type\" : \"integer\" , \"title\" : \"Shape Direction\" , \"description\" : \"Drawing direction of the shape curve, useful for trim path\" , \"oneOf\" : [ { \"title\" : \"Normal\" , \"description\" : \"Usually clockwise\" , \"const\" : 1 }, { \"title\" : \"Reversed\" , \"description\" : \"Usually counter clockwise\" , \"const\" : 3 } ] }, \"mask-mode\" : { \"type\" : \"string\" , \"title\" : \"Mask Mode\" , \"description\" : \"Describes how a mask interacts (blends) with the preceding masks in the stack.\" , \"oneOf\" : [ { \"title\" : \"None\" , \"const\" : \"n\" , \"description\" : \"The mask is ignored.\" }, { \"title\" : \"Add\" , \"const\" : \"a\" , \"description\" : \"Mask coverage is added (Normal blending).\" }, { \"title\" : \"Subtract\" , \"const\" : \"s\" , \"description\" : \"Mask coverage is subtracted (Subtract blending).\" }, { \"title\" : \"Intersect\" , \"const\" : \"i\" , \"description\" : \"Mask coverage is intersected (Source-In blending).\" }, { \"title\" : \"Lighten\" , \"const\" : \"l\" }, { \"title\" : \"Darken\" , \"const\" : \"d\" }, { \"title\" : \"Difference\" , \"const\" : \"f\" } ] }, \"line-join\" : { \"type\" : \"integer\" , \"title\" : \"Line Join\" , \"description\" : \"Style at a sharp corner of a stoked line\" , \"oneOf\" : [ { \"title\" : \"Miter\" , \"const\" : 1 }, { \"title\" : \"Round\" , \"const\" : 2 }, { \"title\" : \"Bevel\" , \"const\" : 3 } ] }, \"matte-mode\" : { \"type\" : \"integer\" , \"title\" : \"Matte Mode\" , \"description\" : \"How a layer should mask another layer\" , \"oneOf\" : [ { \"title\" : \"Normal\" , \"description\" : \"The layer is not used as a track matte\" , \"const\" : 0 }, { \"title\" : \"Alpha\" , \"description\" : \"The masked layer opacity is modulated by the track matte layer opacity\" , \"const\" : 1 }, { \"title\" : \"Inverted Alpha\" , \"description\" : \"The masked layer opacity is modulated by the inverted track matte layer opacity\" , \"const\" : 2 }, { \"title\" : \"Luma\" , \"description\" : \"The masked layer opacity is modulated by the track matte layer luminance\" , \"const\" : 3 }, { \"title\" : \"Inverted Luma\" , \"description\" : \"The masked layer opacity is modulated by the inverted track matte layer luminance\" , \"const\" : 4 } ] }, \"text-caps\" : { \"type\" : \"integer\" , \"title\" : \"Text Caps\" , \"oneOf\" : [ { \"title\" : \"Regular\" , \"const\" : 0 }, { \"title\" : \"All Caps\" , \"const\" : 1 }, { \"title\" : \"Small Caps\" , \"const\" : 2 } ], \"default\" : 0 }, \"text-justify\" : { \"type\" : \"integer\" , \"title\" : \"Text Justify\" , \"description\" : \"Text alignment / justification\" , \"oneOf\" : [ { \"title\" : \"Left\" , \"const\" : 0 }, { \"title\" : \"Right\" , \"const\" : 1 }, { \"title\" : \"Center\" , \"const\" : 2 }, { \"title\" : \"Justify with Last Line Left\" , \"const\" : 3 }, { \"title\" : \"Justify with Last Line Right\" , \"const\" : 4 }, { \"title\" : \"Justify with Last Line Center\" , \"const\" : 5 }, { \"title\" : \"Justify with Last Line Full\" , \"const\" : 6 } ] }, \"line-cap\" : { \"type\" : \"integer\" , \"title\" : \"Line Cap\" , \"description\" : \"Style at the end of a stoked line\" , \"oneOf\" : [ { \"title\" : \"Butt\" , \"const\" : 1 }, { \"title\" : \"Round\" , \"const\" : 2 }, { \"title\" : \"Square\" , \"const\" : 3 } ] }, \"text-based\" : { \"type\" : \"integer\" , \"title\" : \"Text Based\" , \"description\" : \"\" , \"oneOf\" : [ { \"title\" : \"Characters\" , \"const\" : 1 }, { \"title\" : \"Character Excluding Spaces\" , \"const\" : 2 }, { \"title\" : \"Words\" , \"const\" : 3 }, { \"title\" : \"Lines\" , \"const\" : 4 } ] } }, \"effect-values\" : { \"ignored\" : { \"type\" : \"object\" , \"title\" : \"Ignored Value\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 6 }, \"v\" : { \"title\" : \"Value\" , \"type\" : \"number\" , \"default\" : 0 } }, \"required\" : [ \"ty\" ] } ] }, \"no-value\" : { \"type\" : \"object\" , \"title\" : \"Effect No Value\" , \"description\" : \"\" }, \"angle\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Angle\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 1 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"effect-value\" : { \"type\" : \"object\" , \"title\" : \"Effect Value\" , \"description\" : \"Value for an effect\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"ix\" : { \"title\" : \"Effect Index\" , \"type\" : \"integer\" }, \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" } }, \"required\" : [] } ] }, \"drop-down\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Drop Down\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 7 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"point\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Point\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 3 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/properties/vector-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"slider\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Slider\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 0 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"color\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Color\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 2 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/properties/color-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"layer\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Layer\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 10 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"all-effect-values\" : { \"oneOf\" : [ { \"$ref\" : \"#/$defs/effect-values/angle\" }, { \"$ref\" : \"#/$defs/effect-values/checkbox\" }, { \"$ref\" : \"#/$defs/effect-values/color\" }, { \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"$ref\" : \"#/$defs/effect-values/ignored\" }, { \"$ref\" : \"#/$defs/effect-values/layer\" }, { \"$ref\" : \"#/$defs/effect-values/no-value\" }, { \"$ref\" : \"#/$defs/effect-values/point\" }, { \"$ref\" : \"#/$defs/effect-values/slider\" } ] }, \"checkbox\" : { \"type\" : \"object\" , \"title\" : \"Effect Value Checkbox\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effect-values/effect-value\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 4 }, \"v\" : { \"title\" : \"Value\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] } }, \"effects\" : { \"spherize-effect\" : { \"type\" : \"object\" , \"title\" : \"Spherize Effect\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 33 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"radius\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"center\" , \"$ref\" : \"#/$defs/effect-values/point\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"puppet-effect\" : { \"type\" : \"object\" , \"title\" : \"Puppet Effect\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 34 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Puppet Engine\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Mesh Rotation Refinement\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"On Transparent\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"03\" , \"$ref\" : \"#/$defs/effect-values/no-value\" } ] } }, \"required\" : [ \"ty\" , \"ef\" ] } ] }, \"tritone-effect\" : { \"type\" : \"object\" , \"title\" : \"Tritone Effect\" , \"description\" : \"Maps layers colors based on bright/mid/dark colors\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 23 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"bright\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"mid\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"dark\" , \"$ref\" : \"#/$defs/effect-values/color\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"displacement-map-effect\" : { \"type\" : \"object\" , \"title\" : \"Displacement Map Effect\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 27 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Displacement Map Layer\" , \"$ref\" : \"#/$defs/effect-values/layer\" }, { \"title\" : \"Use For Horizontal Displacement\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Max Horizontal Displacement\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Use For Vertical Displacement\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Max Vertical Displacement\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Displacement Map Behavior\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Edge Behavior\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Expand Output\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" } ] } }, \"required\" : [ \"ty\" , \"ef\" ] } ] }, \"wavy-effect\" : { \"type\" : \"object\" , \"title\" : \"Wavy Effect\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 32 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Radius\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Center\" , \"$ref\" : \"#/$defs/effect-values/point\" }, { \"title\" : \"Conversion type\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Speed\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Width\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Height\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Phase\" , \"$ref\" : \"#/$defs/effect-values/slider\" } ] } }, \"required\" : [ \"ty\" , \"ef\" ] } ] }, \"gaussian-blur-effect\" : { \"type\" : \"object\" , \"title\" : \"Gaussian Blur Effect\" , \"description\" : \"Gaussian blur\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 29 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"sigma\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"direction\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"wrap\" , \"$ref\" : \"#/$defs/effect-values/checkbox\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"pro-levels-effect\" : { \"type\" : \"object\" , \"title\" : \"Pro Levels Effect\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 24 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"00\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"01\" , \"$ref\" : \"#/$defs/effect-values/no-value\" }, { \"title\" : \"02\" , \"$ref\" : \"#/$defs/effect-values/no-value\" }, { \"title\" : \"comp_inblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"comp_inwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"comp_gamma\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"comp_outblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"comp_outwhite\" , \"$ref\" : \"#/$defs/effect-values/no-value\" }, { \"title\" : \"08\" , \"$ref\" : \"#/$defs/effect-values/no-value\" }, { \"title\" : \"09\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"r_inblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"r_inwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"r_gamma\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"r_outblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"r_outwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"15\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"16\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"g_inblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"g_inwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"g_gamma\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"g_outblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"g_outwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"22\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"23\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"b_inblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"b_inwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"b_gamma\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"b_outblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"b_outwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"29\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"a_inblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"a_inwhite\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"a_gamma\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"a_outblack\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"a_outwhite\" , \"$ref\" : \"#/$defs/effect-values/no-value\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"all-effects\" : { \"oneOf\" : [ { \"$ref\" : \"#/$defs/effects/custom-effect\" }, { \"$ref\" : \"#/$defs/effects/displacement-map-effect\" }, { \"$ref\" : \"#/$defs/effects/drop-shadow-effect\" }, { \"$ref\" : \"#/$defs/effects/effect\" }, { \"$ref\" : \"#/$defs/effects/fill-effect\" }, { \"$ref\" : \"#/$defs/effects/gaussian-blur-effect\" }, { \"$ref\" : \"#/$defs/effects/matte3-effect\" }, { \"$ref\" : \"#/$defs/effects/mesh-warp-effect\" }, { \"$ref\" : \"#/$defs/effects/pro-levels-effect\" }, { \"$ref\" : \"#/$defs/effects/puppet-effect\" }, { \"$ref\" : \"#/$defs/effects/radial-wipe-effect\" }, { \"$ref\" : \"#/$defs/effects/spherize-effect\" }, { \"$ref\" : \"#/$defs/effects/stroke-effect\" }, { \"$ref\" : \"#/$defs/effects/tint-effect\" }, { \"$ref\" : \"#/$defs/effects/tritone-effect\" }, { \"$ref\" : \"#/$defs/effects/twirl-effect\" }, { \"$ref\" : \"#/$defs/effects/wavy-effect\" } ] }, \"tint-effect\" : { \"type\" : \"object\" , \"title\" : \"Tint Effect\" , \"description\" : \"Colorizes the layer\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 20 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Black Color\" , \"description\" : \"Tint of the darker parts of the layer\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"White Color\" , \"description\" : \"Tint of the lighter parts of the layer\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"Intensity\" , \"description\" : \"Intensity of the effect, 0 means the layer is unchanged. 100 means full effect\" , \"$ref\" : \"#/$defs/effect-values/slider\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"effect\" : { \"type\" : \"object\" , \"title\" : \"Effect\" , \"description\" : \"Layer effect\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"ef\" : { \"title\" : \"Effect Values\" , \"type\" : \"array\" , \"items\" : { \"oneOf\" : [ { \"$ref\" : \"#/$defs/effect-values/no-value\" }, { \"$ref\" : \"#/$defs/effect-values/angle\" }, { \"$ref\" : \"#/$defs/effect-values/checkbox\" }, { \"$ref\" : \"#/$defs/effect-values/color\" }, { \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"$ref\" : \"#/$defs/effect-values/ignored\" }, { \"$ref\" : \"#/$defs/effect-values/layer\" }, { \"$ref\" : \"#/$defs/effect-values/point\" }, { \"$ref\" : \"#/$defs/effect-values/slider\" } ] } }, \"np\" : { \"title\" : \"Property Count\" , \"description\" : \"Number of values in ef \" , \"type\" : \"integer\" }, \"ix\" : { \"title\" : \"Effect Index\" , \"type\" : \"integer\" }, \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Effect type\" , \"type\" : \"integer\" }, \"en\" : { \"title\" : \"Enabled\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"default\" : 1 } }, \"required\" : [ \"ty\" , \"ef\" ] } ] }, \"mesh-warp-effect\" : { \"type\" : \"object\" , \"title\" : \"Mesh Warp Effect\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 31 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Rows\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Columns\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Quality\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"03\" , \"$ref\" : \"#/$defs/effect-values/no-value\" } ] } }, \"required\" : [ \"ty\" , \"ef\" ] } ] }, \"matte3-effect\" : { \"type\" : \"object\" , \"title\" : \"Set Matte Effect\" , \"description\" : \"Uses a layer as a mask\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 28 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Layer\" , \"description\" : \"Use this layer as a mask\" , \"$ref\" : \"#/$defs/effect-values/layer\" }, { \"title\" : \"Channel\" , \"description\" : \"Channel to use as a mask:\\n1 - Red\\n2 - Green\\n3 - Blue\\n4 - Alpha\\n5 - Luminance\\n6 - Hue\\n7 - Lightness\\n8 - Saturation\\n9 - Full\\n10 - Off\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Invert\" , \"description\" : \"Use 0 as opaque value when true\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Stretch To Fit\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Show Mask\" , \"description\" : \"If false, the mask layer won't be shown\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"Premultiply Mask\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"fill-effect\" : { \"type\" : \"object\" , \"title\" : \"Fill Effect\" , \"description\" : \"Replaces the whole layer with the given color\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 21 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"10\" , \"$ref\" : \"#/$defs/effect-values/layer\" }, { \"title\" : \"01\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"color\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"03\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"04\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"05\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"opacity\" , \"description\" : \"Opacity in [0, 1]\" , \"$ref\" : \"#/$defs/effect-values/slider\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"drop-shadow-effect\" : { \"type\" : \"object\" , \"title\" : \"Drop Shadow Effect\" , \"description\" : \"Adds a shadow to the layer\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 25 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"color\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"opacity\" , \"description\" : \"Opacity between 0 and 255\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"angle\" , \"$ref\" : \"#/$defs/effect-values/angle\" }, { \"title\" : \"distance\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"blur\" , \"$ref\" : \"#/$defs/effect-values/slider\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"radial-wipe-effect\" : { \"type\" : \"object\" , \"title\" : \"Radial Wipe\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 26 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Completion\" , \"description\" : \"Between 0 and 100\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Start Angle\" , \"$ref\" : \"#/$defs/effect-values/angle\" }, { \"title\" : \"Wipe Center\" , \"$ref\" : \"#/$defs/effect-values/point\" }, { \"title\" : \"Wipe\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Feather\" , \"$ref\" : \"#/$defs/effect-values/slider\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"stroke-effect\" : { \"type\" : \"object\" , \"title\" : \"Stroke Effect\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 22 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"00\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"01\" , \"$ref\" : \"#/$defs/effect-values/checkbox\" }, { \"title\" : \"02\" , \"$ref\" : \"#/$defs/effect-values/checkbox\" }, { \"title\" : \"color\" , \"$ref\" : \"#/$defs/effect-values/color\" }, { \"title\" : \"04\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"05\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"06\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"07\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"08\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"09\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" }, { \"title\" : \"type\" , \"$ref\" : \"#/$defs/effect-values/drop-down\" } ] } }, \"required\" : [ \"ty\" ] } ] }, \"twirl-effect\" : { \"type\" : \"object\" , \"title\" : \"Twirl Effect\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 30 }, \"ef\" : { \"title\" : \"Effect values\" , \"type\" : \"array\" , \"prefixItems\" : [ { \"title\" : \"Angle\" , \"$ref\" : \"#/$defs/effect-values/angle\" }, { \"title\" : \"Radius\" , \"$ref\" : \"#/$defs/effect-values/slider\" }, { \"title\" : \"Center\" , \"$ref\" : \"#/$defs/effect-values/point\" } ] } }, \"required\" : [ \"ty\" , \"ef\" ] } ] }, \"custom-effect\" : { \"type\" : \"object\" , \"title\" : \"Custom Effect\" , \"description\" : \"Some lottie files use ty = 5 for many different effects\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/effects/effect\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"type\" : \"integer\" , \"const\" : 5 } }, \"required\" : [ \"ty\" ] } ] } }, \"helpers\" : { \"mask\" : { \"type\" : \"object\" , \"title\" : \"Mask\" , \"description\" : \"Mask for layer content.\" , \"allOf\" : [ { \"properties\" : { \"mode\" : { \"title\" : \"Mode\" , \"$ref\" : \"#/$defs/constants/mask-mode\" , \"default\" : \"i\" }, \"o\" : { \"title\" : \"Opacity\" , \"description\" : \"Mask opacity, as a percentage [0..100].\" , \"$ref\" : \"#/$defs/properties/scalar-property\" , \"default\" : 100 }, \"pt\" : { \"title\" : \"Shape\" , \"description\" : \"Mask shape\" , \"$ref\" : \"#/$defs/properties/bezier-property\" }, \"x\" : { \"title\" : \"Expand\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"inv\" : { \"title\" : \"Inverted\" , \"type\" : \"boolean\" , \"default\" : false } }, \"required\" : [ \"pt\" ] } ] }, \"slot\" : { \"type\" : \"object\" , \"title\" : \"Slot\" , \"description\" : \"Defines a property value that will be set to all matched properties\" , \"properties\" : { \"p\" : { \"title\" : \"Property Value\" , \"description\" : \"Property Value\" } }, \"required\" : [ \"p\" ] }, \"slottable-object\" : { \"type\" : \"object\" , \"title\" : \"Slottable Object\" , \"description\" : \"Object that may have its value replaced with a slot value\" , \"properties\" : { \"sid\" : { \"title\" : \"Slot Id\" , \"description\" : \"Identifier to look up the slot\" , \"type\" : \"string\" } } }, \"marker\" : { \"type\" : \"object\" , \"title\" : \"Marker\" , \"description\" : \"Defines named portions of the composition.\" , \"properties\" : { \"cm\" : { \"title\" : \"Comment\" , \"type\" : \"string\" }, \"tm\" : { \"title\" : \"Time\" , \"type\" : \"number\" }, \"dr\" : { \"title\" : \"Duration\" , \"type\" : \"number\" } } }, \"transform\" : { \"type\" : \"object\" , \"title\" : \"Transform\" , \"description\" : \"Layer transform\" , \"allOf\" : [ { \"properties\" : { \"a\" : { \"title\" : \"Anchor Point\" , \"description\" : \"Anchor point: a position (relative to its parent) around which transformations are applied (ie: center for rotation / scale)\" , \"$ref\" : \"#/$defs/properties/position-property\" }, \"p\" : { \"title\" : \"Position\" , \"description\" : \"Position / Translation\" , \"$ref\" : \"#/$defs/properties/splittable-position-property\" }, \"r\" : { \"title\" : \"Rotation\" , \"description\" : \"Rotation in degrees, clockwise\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"s\" : { \"title\" : \"Scale\" , \"description\" : \"Scale factor, [100, 100] for no scaling\" , \"$ref\" : \"#/$defs/properties/vector-property\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"sk\" : { \"title\" : \"Skew\" , \"description\" : \"Skew amount as an angle in degrees\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"sa\" : { \"title\" : \"Skew Axis\" , \"description\" : \"Direction along which skew is applied, in degrees ( 0 skews along the X axis, 90 along the Y axis)\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"rx\" : { \"title\" : \"X Rotation\" , \"description\" : \"Split rotation component\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"ry\" : { \"title\" : \"Y Rotation\" , \"description\" : \"Split rotation component\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"rz\" : { \"title\" : \"Z Rotation\" , \"description\" : \"Split rotation component, equivalent to r when not split\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"or\" : { \"title\" : \"Orientation\" , \"$ref\" : \"#/$defs/properties/vector-property\" } } } ] }, \"visual-object\" : { \"type\" : \"object\" , \"title\" : \"Visual Object\" , \"description\" : \"\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"nm\" : { \"title\" : \"Name\" , \"description\" : \"Human readable name, as seen from editors and the like\" , \"type\" : \"string\" }, \"mn\" : { \"title\" : \"Match Name\" , \"description\" : \"Match name, used in expressions\" , \"type\" : \"string\" } }, \"required\" : [] } ] } }, \"layers\" : { \"precomposition-layer\" : { \"type\" : \"object\" , \"title\" : \"Precomposition Layer\" , \"description\" : \"Layer that renders a Precomposition asset\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/visual-layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 0 }, \"refId\" : { \"title\" : \"Reference Id\" , \"description\" : \"ID of the precomp as specified in the assets\" , \"type\" : \"string\" }, \"w\" : { \"title\" : \"Width\" , \"description\" : \"Width of the clipping rect\" , \"type\" : \"integer\" }, \"h\" : { \"title\" : \"Height\" , \"description\" : \"Height of the clipping rect\" , \"type\" : \"integer\" }, \"st\" : { \"title\" : \"Start Time\" , \"type\" : \"number\" , \"default\" : 0 }, \"tm\" : { \"title\" : \"Time Remap\" , \"description\" : \"Timeline remap function (frame index -> time in seconds)\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" , \"refId\" ] } ] }, \"null-layer\" : { \"type\" : \"object\" , \"title\" : \"Null Layer\" , \"description\" : \"Layer with no data, useful to group layers together\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/visual-layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 3 } }, \"required\" : [ \"ty\" ] } ] }, \"data-layer\" : { \"type\" : \"object\" , \"title\" : \"Data Layer\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 15 }, \"refId\" : { \"title\" : \"Data source Id\" , \"description\" : \"ID of the data source in assets\" , \"type\" : \"string\" } }, \"required\" : [ \"ty\" ] } ] }, \"unknown-layer\" : { \"type\" : \"object\" , \"title\" : \"Unknown layer types\" , \"description\" : \"Unknown layer types. Types not defined by the specification are still allowed.\" , \"properties\" : { \"ty\" : { \"not\" : { \"$comment\" : \"enum list is dynamically generated\" , \"enum\" : [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 15 , 13 ] } } } }, \"image-layer\" : { \"type\" : \"object\" , \"title\" : \"Image Layer\" , \"description\" : \"Layer containing an image\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/visual-layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 2 }, \"refId\" : { \"title\" : \"Reference Id\" , \"description\" : \"ID of the image as specified in the assets\" , \"type\" : \"string\" } }, \"required\" : [ \"ty\" , \"refId\" ] } ] }, \"solid-layer\" : { \"type\" : \"object\" , \"title\" : \"Solid Layer\" , \"description\" : \"Solid color, rectangle-shaped layer\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/visual-layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 1 }, \"sw\" : { \"title\" : \"Width\" , \"description\" : \"Solid rectangle width\" , \"type\" : \"integer\" }, \"sh\" : { \"title\" : \"Height\" , \"description\" : \"Solid rectangle height\" , \"type\" : \"integer\" }, \"sc\" : { \"title\" : \"Color\" , \"description\" : \"Solid fill color\" , \"$ref\" : \"#/$defs/values/hexcolor\" } }, \"required\" : [ \"ty\" , \"sw\" , \"sh\" , \"sc\" ] } ] }, \"audio-layer\" : { \"type\" : \"object\" , \"title\" : \"Audio Layer\" , \"description\" : \"A layer playing sounds\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 6 }, \"au\" : { \"title\" : \"Audio Settings\" , \"$ref\" : \"#/$defs/layers/audio-settings\" }, \"refId\" : { \"title\" : \"Sound Id\" , \"description\" : \"ID of the sound as specified in the assets\" , \"type\" : \"string\" } }, \"required\" : [ \"ty\" , \"au\" ] } ] }, \"audio-settings\" : { \"type\" : \"object\" , \"title\" : \"Audio Settings\" , \"description\" : \"\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"lv\" : { \"title\" : \"Level\" , \"$ref\" : \"#/$defs/properties/vector-property\" } }, \"required\" : [ \"lv\" ] } ] }, \"text-layer\" : { \"type\" : \"object\" , \"title\" : \"Text Layer\" , \"description\" : \"Layer with some text\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/visual-layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 5 }, \"t\" : { \"title\" : \"Data\" , \"$ref\" : \"#/$defs/text/text-data\" } }, \"required\" : [ \"ty\" , \"t\" ] } ] }, \"shape-layer\" : { \"type\" : \"object\" , \"title\" : \"Shape Layer\" , \"description\" : \"Layer containing Shapes\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/visual-layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 4 }, \"shapes\" : { \"title\" : \"Shapes\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/shapes/all-graphic-elements\" } } }, \"required\" : [ \"ty\" , \"shapes\" ] } ] }, \"all-layers\" : { \"oneOf\" : [ { \"$ref\" : \"#/$defs/layers/precomposition-layer\" }, { \"$ref\" : \"#/$defs/layers/solid-layer\" }, { \"$ref\" : \"#/$defs/layers/image-layer\" }, { \"$ref\" : \"#/$defs/layers/null-layer\" }, { \"$ref\" : \"#/$defs/layers/shape-layer\" }, { \"$ref\" : \"#/$defs/layers/text-layer\" }, { \"$ref\" : \"#/$defs/layers/audio-layer\" }, { \"$ref\" : \"#/$defs/layers/data-layer\" }, { \"$ref\" : \"#/$defs/layers/camera-layer\" }, { \"$ref\" : \"#/$defs/layers/unknown-layer\" } ] }, \"camera-layer\" : { \"type\" : \"object\" , \"title\" : \"Camera Layer\" , \"description\" : \"3D Camera\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer type\" , \"type\" : \"integer\" , \"const\" : 13 }, \"ks\" : { \"title\" : \"Transform\" , \"description\" : \"Layer transform\" , \"$ref\" : \"#/$defs/helpers/transform\" }, \"pe\" : { \"title\" : \"Perspective\" , \"description\" : \"Distance from the Z=0 plane.\\nSmall values yield a higher perspective effect.\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" , \"ks\" , \"pe\" ] } ] }, \"visual-layer\" : { \"type\" : \"object\" , \"title\" : \"Visual Layer\" , \"description\" : \"Layer used to affect visual elements\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/layers/layer\" }, { \"type\" : \"object\" , \"properties\" : { \"ks\" : { \"title\" : \"Transform\" , \"description\" : \"Layer transform\" , \"$ref\" : \"#/$defs/helpers/transform\" }, \"ao\" : { \"title\" : \"Auto Orient\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"default\" : 0 , \"description\" : \"If 1, the layer will rotate itself to match its animated position path\" }, \"tt\" : { \"title\" : \"Matte Mode\" , \"$ref\" : \"#/$defs/constants/matte-mode\" , \"description\" : \"Defines the track matte mode for the layer\" }, \"tp\" : { \"title\" : \"Matte Parent\" , \"type\" : \"integer\" , \"description\" : \"Index of the layer used as matte, if omitted assume the layer above the current one\" }, \"td\" : { \"title\" : \"Matte Target\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"description\" : \"If set to 1, it means a layer is using this layer as a track matte\" }, \"hasMask\" : { \"title\" : \"Has Masks\" , \"description\" : \"Whether the layer has masks applied\" , \"type\" : \"boolean\" }, \"masksProperties\" : { \"title\" : \"Masks\" , \"description\" : \"Optional array of masks for the layer.\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/helpers/mask\" } }, \"ef\" : { \"title\" : \"Effects\" , \"description\" : \"List of layer effects\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/effects/all-effects\" } }, \"mb\" : { \"title\" : \"Motion Blur\" , \"description\" : \"Whether motion blur is enabled for the layer\" , \"type\" : \"boolean\" }, \"sy\" : { \"title\" : \"Layer style\" , \"description\" : \"Styling effects for this layer\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/styles/all-layer-styles\" } }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/constants/blend-mode\" , \"default\" : 0 }, \"cl\" : { \"title\" : \"CSS Class\" , \"description\" : \"CSS class used by the SVG renderer\" , \"type\" : \"string\" }, \"ln\" : { \"title\" : \"Layer XML ID\" , \"description\" : \" id attribute used by the SVG renderer\" , \"type\" : \"string\" }, \"tg\" : { \"title\" : \"Layer XML tag name\" , \"description\" : \"tag name used by the SVG renderer\" , \"type\" : \"string\" }, \"cp\" : { \"deprecated\" : true , \"title\" : \"Collapse Transform\" , \"description\" : \"This is deprecated in favour of ct \" , \"type\" : \"boolean\" }, \"ct\" : { \"title\" : \"Collapse Transform\" , \"description\" : \"Marks that transforms should be applied before masks\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"default\" : 0 } }, \"required\" : [ \"ks\" ] } ] }, \"layer\" : { \"type\" : \"object\" , \"title\" : \"Layer\" , \"description\" : \"Common properties for all layers\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"ddd\" : { \"title\" : \"Threedimensional\" , \"description\" : \"Whether the layer is threedimensional\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"default\" : 0 }, \"hd\" : { \"title\" : \"Hidden\" , \"description\" : \"Whether the layer is hidden\" , \"type\" : \"boolean\" }, \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" }, \"ind\" : { \"title\" : \"Index\" , \"type\" : \"integer\" , \"description\" : \"Index that can be used for parenting and referenced in expressions\" }, \"parent\" : { \"title\" : \"Parent Index\" , \"description\" : \"Must be the ind property of another layer\" , \"type\" : \"integer\" }, \"sr\" : { \"title\" : \"Time Stretch\" , \"type\" : \"number\" , \"default\" : 1 }, \"ip\" : { \"title\" : \"In Point\" , \"description\" : \"Frame when the layer becomes visible\" , \"type\" : \"number\" }, \"op\" : { \"title\" : \"Out Point\" , \"description\" : \"Frame when the layer becomes invisible\" , \"type\" : \"number\" }, \"st\" : { \"title\" : \"Start Time\" , \"type\" : \"number\" , \"default\" : 0 } }, \"required\" : [ \"ty\" , \"ip\" , \"op\" ] } ] } }, \"properties\" : { \"gradient-stops\" : { \"type\" : \"object\" , \"title\" : \"Gradient stops\" , \"description\" : \"Animatable vector representing the gradient stops\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/properties/property\" } ], \"oneOf\" : [ { \"$comment\" : \"Not animated\" , \"properties\" : { \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"const\" : 0 }, \"k\" : { \"title\" : \"Value\" , \"description\" : \"Static Value\" , \"$ref\" : \"#/$defs/values/gradient\" } } }, { \"$comment\" : \"Animated\" , \"properties\" : { \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"const\" : 1 }, \"k\" : { \"type\" : \"array\" , \"title\" : \"Keyframes\" , \"description\" : \"Array of keyframes\" , \"items\" : { \"$ref\" : \"#/$defs/properties/gradient-keyframe\" } } } } ], \"required\" : [ \"a\" , \"k\" ] }, \"easing-handle\" : { \"type\" : \"object\" , \"title\" : \"Keyframe Easing\" , \"description\" : \"Bezier handle for keyframe interpolation\" , \"properties\" : { \"x\" : { \"title\" : \"X\" , \"description\" : \"Time component:\\n0 means start time of the keyframe,\\n1 means time of the next keyframe.\" , \"oneOf\" : [ { \"type\" : \"array\" , \"$ref\" : \"#/$defs/values/vector\" , \"items\" : { \"type\" : \"number\" , \"default\" : 0 , \"minimum\" : 0 , \"maximum\" : 1 }, \"minItems\" : 1 }, { \"type\" : \"number\" , \"default\" : 0 , \"minimum\" : 0 , \"maximum\" : 1 } ] }, \"y\" : { \"title\" : \"Y\" , \"description\" : \"Value interpolation component:\\n0 means start value of the keyframe,\\n1 means value at the next keyframe.\" , \"oneOf\" : [ { \"type\" : \"array\" , \"$ref\" : \"#/$defs/values/vector\" , \"items\" : { \"type\" : \"number\" , \"default\" : 0 }, \"minItems\" : 1 }, { \"type\" : \"number\" , \"default\" : 0 } ] } }, \"required\" : [ \"x\" , \"y\" ] }, \"position-property\" : { \"type\" : \"object\" , \"title\" : \"Position Property\" , \"description\" : \"An animatable property to represent a position in space\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/properties/property\" }, { \"properties\" : { \"l\" : { \"title\" : \"Length\" , \"description\" : \"Number of components in the value arrays.\\nIf present values will be truncated or expanded to match this length when accessed from expressions.\" , \"type\" : \"integer\" } } } ], \"oneOf\" : [ { \"$comment\" : \"Not animated\" , \"properties\" : { \"ix\" : { \"title\" : \"Property Index\" , \"type\" : \"integer\" }, \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"const\" : 0 }, \"k\" : { \"title\" : \"Value\" , \"description\" : \"Static Value\" , \"$ref\" : \"#/$defs/values/vector\" } } }, { \"$comment\" : \"Animated\" , \"properties\" : { \"ix\" : { \"title\" : \"Property Index\" , \"type\" : \"integer\" }, \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"const\" : 1 }, \"k\" : { \"type\" : \"array\" , \"title\" : \"Keyframes\" , \"description\" : \"Array of keyframes\" , \"items\" : { \"$ref\" : \"#/$defs/properties/position-keyframe\" } } } } ], \"required\" : [ \"a\" , \"k\" ] }, \"position-keyframe\" : { \"type\" : \"object\" , \"title\" : \"Position Keyframe\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/properties/vector-keyframe\" }, { \"properties\" : { \"ti\" : { \"title\" : \"Value In Tangent\" , \"description\" : \"Tangent for values (eg: moving position around a curved path)\" , \"$ref\" : \"#/$defs/values/vector\" }, \"to\" : { \"title\" : \"Value Out Tangent\" , \"description\" : \"Tangent for values (eg: moving position around a curved path)\" , \"$ref\" : \"#/$defs/values/vector\" } } } ] }, \"vector-keyframe\" : { \"type\" : \"object\" , \"title\" : \"Vector Keyframe\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/properties/base-keyframe\" }, { \"properties\" : { \"s\" : { \"title\" : \"Value\" , \"description\" : \"Value at this keyframe.\" , \"$ref\" : \"#/$defs/values/vector\" }, \"e\" : { \"title\" : \"End value\" , \"description\" : \"Value at the end of the keyframe, note that this is deprecated and you should use s from the next keyframe to get this value\" , \"deprecated\" : true , \"$ref\" : \"#/$defs/values/vector\" } } } ], \"required\" : [ \"s\" ] }, \"color-keyframe\" : { \"type\" : \"object\" , \"title\" : \"Color Keyframe\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/properties/base-keyframe\" }, { \"properties\" : { \"s\" : { \"title\" : \"Value\" , \"description\" : \"Value at this keyframe.\" , \"$ref\" : \"#/$defs/values/color\" }, \"e\" : { \"title\" : \"End value\" , \"description\" : \"Value at the end of the keyframe, note that this is deprecated and you should use s from the next keyframe to get this value\" , \"deprecated\" : true , \"$ref\" : \"#/$defs/values/color\" } } } ], \"required\" : [ \"s\" ] }, \"vector-property\" : { \"type\" : \"object\" , \"title\" : \"Vector Property\" , \"description\" : \"An animatable property that holds an array of numbers\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/properties/property\" }, { \"properties\" : { \"l\" : { \"title\" : \"Length\" , \"description\" : \"Number of components in the value arrays.\\nIf present values will be truncated or expanded to match this length when accessed from expressions.\" , \"type\" : \"integer\" } } } ], \"oneOf\" : [ { \"$comment\" : \"Not animated\" , \"properties\" : { \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"const\" : 0 }, \"k\" : { \"title\" : \"Value\" , \"description\" : \"Static Value\" , \"$ref\" : \"#/$defs/values/vector\" } } }, { \"$comment\" : \"Animated\" , \"properties\" : { \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"const\" : 1 }, \"k\" : { \"type\" : \"array\" , \"title\" : \"Keyframes\" , \"description\" : \"Array of keyframes\" , \"items\" : { \"$ref\" : \"#/$defs/properties/vector-keyframe\" } } } } ] }, \"scalar-property\" : { \"type\" : \"object\" , \"title\" : \"Scalar Property\" , \"description\" : \"An animatable property that holds a float\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/properties/property\" } ], \"oneOf\" : [ { \"$comment\" : \"Not animated\" , \"properties\" : { \"ix\" : { \"title\" : \"Property Index\" , \"type\" : \"integer\" }, \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"const\" : 0 }, \"k\" : { \"title\" : \"Value\" , \"description\" : \"Static Value\" , \"type\" : \"number\" } } }, { \"$comment\" : \"Animated\" , \"properties\" : { \"ix\" : { \"title\" : \"Property Index\" , \"type\" : \"integer\" }, \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"const\" : 1 }, \"k\" : { \"type\" : \"array\" , \"title\" : \"Keyframes\" , \"description\" : \"Array of keyframes\" , \"items\" : { \"$ref\" : \"#/$defs/properties/vector-keyframe\" } } } } ] }, \"bezier-property\" : { \"type\" : \"object\" , \"title\" : \"Bezier Property\" , \"description\" : \"An animatable property that holds a Bezier shape\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/properties/property\" } ], \"oneOf\" : [ { \"$comment\" : \"Not animated\" , \"properties\" : { \"ix\" : { \"title\" : \"Property Index\" , \"type\" : \"integer\" }, \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"const\" : 0 }, \"k\" : { \"title\" : \"Value\" , \"description\" : \"Static Value\" , \"$ref\" : \"#/$defs/values/bezier\" } } }, { \"$comment\" : \"Animated\" , \"properties\" : { \"ix\" : { \"title\" : \"Property Index\" , \"type\" : \"integer\" }, \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"const\" : 1 }, \"k\" : { \"type\" : \"array\" , \"title\" : \"Keyframes\" , \"description\" : \"Array of keyframes\" , \"items\" : { \"$ref\" : \"#/$defs/properties/bezier-keyframe\" } } } } ], \"required\" : [ \"a\" , \"k\" ] }, \"color-property\" : { \"type\" : \"object\" , \"title\" : \"Color Property\" , \"description\" : \"An animatable property that holds a Color\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/properties/property\" } ], \"oneOf\" : [ { \"$comment\" : \"Not animated\" , \"properties\" : { \"ix\" : { \"title\" : \"Property Index\" , \"type\" : \"integer\" }, \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"const\" : 0 }, \"k\" : { \"title\" : \"Value\" , \"description\" : \"Static Value\" , \"$ref\" : \"#/$defs/values/color\" } } }, { \"$comment\" : \"Animated\" , \"properties\" : { \"ix\" : { \"title\" : \"Property Index\" , \"type\" : \"integer\" }, \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"const\" : 1 }, \"k\" : { \"type\" : \"array\" , \"title\" : \"Keyframes\" , \"description\" : \"Array of keyframes\" , \"items\" : { \"$ref\" : \"#/$defs/properties/color-keyframe\" } } } } ] }, \"bezier-keyframe\" : { \"type\" : \"object\" , \"title\" : \"Shape Keyframe\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/properties/base-keyframe\" }, { \"properties\" : { \"s\" : { \"title\" : \"Value\" , \"description\" : \"Value at this keyframe.\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/values/bezier\" }, \"minItems\" : 1 , \"maxItems\" : 1 }, \"e\" : { \"title\" : \"End value\" , \"description\" : \"Value at the end of the keyframe, note that this is deprecated and you should use s from the next keyframe to get this value\" , \"deprecated\" : true , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/values/bezier\" }, \"minItems\" : 1 , \"maxItems\" : 1 } } } ], \"required\" : [ \"s\" ] }, \"gradient-keyframe\" : { \"type\" : \"object\" , \"title\" : \"Gradient Keyframe\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/properties/base-keyframe\" }, { \"properties\" : { \"s\" : { \"title\" : \"Value\" , \"description\" : \"Value at this keyframe.\" , \"$ref\" : \"#/$defs/values/gradient\" }, \"e\" : { \"title\" : \"End value\" , \"description\" : \"Value at the end of the keyframe, note that this is deprecated and you should use s from the next keyframe to get this value\" , \"deprecated\" : true , \"type\" : \"array\" , \"$ref\" : \"#/$defs/values/gradient\" } } } ], \"required\" : [ \"s\" ] }, \"split-position\" : { \"type\" : \"object\" , \"title\" : \"Split Position\" , \"description\" : \"An animatable position where x and y are definied and animated separately.\" , \"properties\" : { \"s\" : { \"title\" : \"Split\" , \"description\" : \"Whether the position has split values\" , \"type\" : \"boolean\" , \"const\" : true }, \"x\" : { \"title\" : \"X Position\" , \"description\" : \"X Position\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"y\" : { \"title\" : \"Y Position\" , \"description\" : \"Y Position\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"s\" , \"x\" , \"y\" ] }, \"base-keyframe\" : { \"type\" : \"object\" , \"title\" : \"Base Keyframe\" , \"description\" : \"A Keyframes specifies the value at a specific time and the interpolation function to reach the next keyframe.\" , \"allOf\" : [ { \"properties\" : { \"t\" : { \"title\" : \"Time\" , \"description\" : \"Frame number\" , \"type\" : \"number\" , \"default\" : 0 }, \"h\" : { \"title\" : \"Hold\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"default\" : 0 }, \"i\" : { \"title\" : \"In Tangent\" , \"description\" : \"Easing tangent going into the next keyframe\" , \"$ref\" : \"#/$defs/properties/easing-handle\" }, \"o\" : { \"title\" : \"Out Tangent\" , \"description\" : \"Easing tangent leaving the current keyframe\" , \"$ref\" : \"#/$defs/properties/easing-handle\" } } } ], \"required\" : [ \"t\" ] }, \"splittable-position-property\" : { \"type\" : \"object\" , \"title\" : \"Splittable Position Property\" , \"description\" : \"An animatable position where position values may be defined and animated separately.\" , \"oneOf\" : [ { \"$comment\" : \"Grouped XY position coordinates\" , \"$ref\" : \"#/$defs/properties/position-property\" , \"properties\" : { \"s\" : { \"title\" : \"Split\" , \"description\" : \"Whether the position has split values\" , \"type\" : \"boolean\" , \"const\" : false } } }, { \"$comment\" : \"Split XY position coordinates\" , \"$ref\" : \"#/$defs/properties/split-position\" } ] }, \"gradient-property\" : { \"type\" : \"object\" , \"title\" : \"Gradient Property\" , \"description\" : \"An animatable property that holds a Gradient\" , \"properties\" : { \"p\" : { \"title\" : \"Color stop count\" , \"type\" : \"number\" }, \"k\" : { \"title\" : \"Gradient stops\" , \"$ref\" : \"#/$defs/properties/gradient-stops\" } } }, \"property\" : { \"type\" : \"object\" , \"title\" : \"Property\" , \"properties\" : { \"ix\" : { \"title\" : \"Property Index\" , \"type\" : \"integer\" }, \"x\" : { \"title\" : \"Expression\" , \"type\" : \"string\" }, \"sid\" : { \"title\" : \"Slot ID\" , \"description\" : \"One of the ID in the file's slots\" , \"type\" : \"string\" }, \"a\" : { \"title\" : \"Animated\" , \"description\" : \"Whether the property is animated\" , \"$ref\" : \"#/$defs/values/int-boolean\" , \"default\" : 0 } }, \"if\" : { \"required\" : [ \"sid\" ] }, \"else\" : { \"required\" : [ \"a\" , \"k\" ] } } }, \"shapes\" : { \"twist\" : { \"type\" : \"object\" , \"title\" : \"Twist\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/modifier\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"tw\" }, \"a\" : { \"title\" : \"Angle\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"c\" : { \"title\" : \"Center\" , \"$ref\" : \"#/$defs/properties/vector-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"shape\" : { \"type\" : \"object\" , \"title\" : \"Shape\" , \"description\" : \"Drawable shape, defines the actual shape but not the style\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/graphic-element\" }, { \"type\" : \"object\" , \"properties\" : { \"d\" : { \"title\" : \"Direction\" , \"description\" : \"Direction the shape is drawn as, mostly relevant when using trim path\" , \"$ref\" : \"#/$defs/constants/shape-direction\" } } } ] }, \"merge\" : { \"type\" : \"object\" , \"title\" : \"Merge\" , \"description\" : \"Boolean operator on shapes\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/graphic-element\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"mm\" }, \"mm\" : { \"title\" : \"Merge Mode\" , \"$ref\" : \"#/$defs/constants/merge-mode\" , \"default\" : 1 } }, \"required\" : [ \"ty\" ] } ] }, \"stroke-dash\" : { \"type\" : \"object\" , \"title\" : \"Stroke Dash\" , \"description\" : \"An item used to described the dash pattern in a stroked path\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"n\" : { \"title\" : \"Dash Type\" , \"$ref\" : \"#/$defs/constants/stroke-dash-type\" , \"default\" : \"d\" }, \"v\" : { \"title\" : \"Length\" , \"description\" : \"Length of the dash\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [] } ] }, \"rounded-corners\" : { \"type\" : \"object\" , \"title\" : \"Rounded Corners\" , \"description\" : \"Rounds corners of other shapes\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/modifier\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"rd\" }, \"r\" : { \"title\" : \"Radius\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" , \"r\" ] } ] }, \"offset-path\" : { \"type\" : \"object\" , \"title\" : \"Offset Path\" , \"description\" : \"Interpolates the shape with its center point and bezier tangents with the opposite direction\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/modifier\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"op\" }, \"a\" : { \"title\" : \"Amount\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"lj\" : { \"title\" : \"Line Join\" , \"$ref\" : \"#/$defs/constants/line-join\" , \"default\" : 2 }, \"ml\" : { \"title\" : \"Miter Limit\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"transform\" : { \"type\" : \"object\" , \"title\" : \"Transform Shape\" , \"description\" : \"Group transform\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/graphic-element\" }, { \"$ref\" : \"#/$defs/helpers/transform\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"tr\" } }, \"required\" : [ \"ty\" ] } ] }, \"graphic-element\" : { \"type\" : \"object\" , \"title\" : \"Graphic Element\" , \"description\" : \"Element used to display vector data in a shape layer\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"hd\" : { \"title\" : \"Hidden\" , \"description\" : \"Whether the shape is hidden\" , \"type\" : \"boolean\" }, \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/constants/blend-mode\" }, \"ix\" : { \"title\" : \"Property index\" , \"description\" : \"Index used in expressions\" , \"type\" : \"integer\" }, \"cl\" : { \"title\" : \"CSS Class\" , \"description\" : \"CSS class used by the SVG renderer\" , \"type\" : \"string\" }, \"ln\" : { \"title\" : \"Layer XML ID\" , \"description\" : \" id attribute used by the SVG renderer\" , \"type\" : \"string\" } }, \"required\" : [ \"ty\" ] } ] }, \"base-stroke\" : { \"type\" : \"object\" , \"title\" : \"Base Stroke\" , \"description\" : \"Common properties for stroke styles\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"lc\" : { \"title\" : \"Line Cap\" , \"$ref\" : \"#/$defs/constants/line-cap\" , \"default\" : 2 }, \"lj\" : { \"title\" : \"Line Join\" , \"$ref\" : \"#/$defs/constants/line-join\" , \"default\" : 2 }, \"ml\" : { \"title\" : \"Miter Limit\" , \"type\" : \"number\" , \"default\" : 0 }, \"ml2\" : { \"title\" : \"Miter Limit\" , \"description\" : \"Animatable alternative to ml\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"w\" : { \"title\" : \"Width\" , \"description\" : \"Stroke width\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"d\" : { \"title\" : \"Dashes\" , \"description\" : \"Dashed line definition\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/shapes/stroke-dash\" } } }, \"required\" : [ \"w\" ] } ] }, \"gradient-stroke\" : { \"type\" : \"object\" , \"title\" : \"Gradient Stroke\" , \"description\" : \"Gradient stroke\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-style\" }, { \"$ref\" : \"#/$defs/shapes/base-stroke\" }, { \"$ref\" : \"#/$defs/shapes/base-gradient\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"gs\" } }, \"required\" : [ \"ty\" ] } ] }, \"stroke\" : { \"type\" : \"object\" , \"title\" : \"Stroke\" , \"description\" : \"Solid stroke\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-style\" }, { \"$ref\" : \"#/$defs/shapes/base-stroke\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"st\" }, \"c\" : { \"title\" : \"Color\" , \"description\" : \"Stroke color\" , \"$ref\" : \"#/$defs/properties/color-property\" } }, \"required\" : [ \"ty\" , \"c\" ] } ] }, \"shape-style\" : { \"type\" : \"object\" , \"title\" : \"Shape Style\" , \"description\" : \"Describes the visual appearance (like fill and stroke) of neighbouring shapes\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/graphic-element\" }, { \"type\" : \"object\" , \"properties\" : { \"o\" : { \"title\" : \"Opacity\" , \"description\" : \"Opacity, 100 means fully opaque\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"o\" ] } ] }, \"all-graphic-elements\" : { \"$comment\" : \"List of valid shapes\" , \"oneOf\" : [ { \"$ref\" : \"#/$defs/shapes/ellipse\" }, { \"$ref\" : \"#/$defs/shapes/fill\" }, { \"$ref\" : \"#/$defs/shapes/gradient-fill\" }, { \"$ref\" : \"#/$defs/shapes/gradient-stroke\" }, { \"$ref\" : \"#/$defs/shapes/group\" }, { \"$ref\" : \"#/$defs/shapes/merge\" }, { \"$ref\" : \"#/$defs/shapes/no-style\" }, { \"$ref\" : \"#/$defs/shapes/offset-path\" }, { \"$ref\" : \"#/$defs/shapes/path\" }, { \"$ref\" : \"#/$defs/shapes/polystar\" }, { \"$ref\" : \"#/$defs/shapes/pucker-bloat\" }, { \"$ref\" : \"#/$defs/shapes/rectangle\" }, { \"$ref\" : \"#/$defs/shapes/repeater\" }, { \"$ref\" : \"#/$defs/shapes/rounded-corners\" }, { \"$ref\" : \"#/$defs/shapes/stroke\" }, { \"$ref\" : \"#/$defs/shapes/transform\" }, { \"$ref\" : \"#/$defs/shapes/trim-path\" }, { \"$ref\" : \"#/$defs/shapes/twist\" }, { \"$ref\" : \"#/$defs/shapes/zig-zag\" }, { \"$ref\" : \"#/$defs/shapes/unknown-shape\" } ] }, \"trim-path\" : { \"type\" : \"object\" , \"title\" : \"Trim Path\" , \"description\" : \"Trims shapes into a segment\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/modifier\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"tm\" }, \"s\" : { \"title\" : \"Start\" , \"description\" : \"Segment start\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"e\" : { \"title\" : \"End\" , \"description\" : \"Segment end\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"o\" : { \"title\" : \"Offset\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"m\" : { \"title\" : \"Multiple\" , \"description\" : \"How to treat multiple copies\" , \"$ref\" : \"#/$defs/constants/trim-multiple-shapes\" } }, \"required\" : [ \"ty\" , \"o\" , \"s\" , \"e\" ] } ] }, \"modifier\" : { \"type\" : \"object\" , \"title\" : \"Modifier\" , \"description\" : \"Modifiers change the bezier curves of neighbouring shapes\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/graphic-element\" } ] }, \"repeater-transform\" : { \"type\" : \"object\" , \"title\" : \"Repeater Transform\" , \"description\" : \"Transform used by a repeater, the transform is applied to each subsequent repeated object.\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/transform\" }, { \"type\" : \"object\" , \"properties\" : { \"so\" : { \"title\" : \"Start Opacity\" , \"description\" : \"Opacity of the first repeated object.\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"eo\" : { \"title\" : \"End Opacity\" , \"description\" : \"Opacity of the last repeated object.\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [] } ] }, \"zig-zag\" : { \"type\" : \"object\" , \"title\" : \"Zig Zag\" , \"description\" : \"Changes the edges of affected shapes into a series of peaks and valleys of uniform size\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/modifier\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"zz\" }, \"r\" : { \"title\" : \"Frequency\" , \"description\" : \"Number of ridges per segment\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"s\" : { \"title\" : \"Amplitude\" , \"description\" : \"Distance between peaks and troughs\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"pt\" : { \"title\" : \"Point Type\" , \"description\" : \"Point type (1 = corner, 2 = smooth)\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"rectangle\" : { \"type\" : \"object\" , \"title\" : \"Rectangle\" , \"description\" : \"A simple rectangle shape\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"rc\" }, \"p\" : { \"title\" : \"Position\" , \"description\" : \"Center of the rectangle\" , \"$ref\" : \"#/$defs/properties/position-property\" }, \"s\" : { \"title\" : \"Size\" , \"$ref\" : \"#/$defs/properties/vector-property\" }, \"r\" : { \"title\" : \"Rounded\" , \"description\" : \"Rounded corners radius\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" , \"s\" , \"p\" ] } ] }, \"base-gradient\" : { \"type\" : \"object\" , \"title\" : \"Base Gradient\" , \"description\" : \"Common properties for gradients\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"g\" : { \"title\" : \"Colors\" , \"description\" : \"Gradient colors\" , \"$ref\" : \"#/$defs/properties/gradient-property\" }, \"s\" : { \"title\" : \"Start Point\" , \"description\" : \"Starting point for the gradient\" , \"$ref\" : \"#/$defs/properties/position-property\" }, \"e\" : { \"title\" : \"End Point\" , \"description\" : \"End point for the gradient\" , \"$ref\" : \"#/$defs/properties/position-property\" }, \"t\" : { \"title\" : \"Gradient Type\" , \"description\" : \"Type of the gradient\" , \"$ref\" : \"#/$defs/constants/gradient-type\" }, \"h\" : { \"title\" : \"Highlight Length\" , \"description\" : \"Highlight Length, as a percentage between s and e \" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"a\" : { \"title\" : \"Highlight Angle\" , \"description\" : \"Highlight Angle in clockwise degrees, relative to the direction from s to e \" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"s\" , \"e\" , \"g\" , \"t\" ] } ] }, \"unknown-shape\" : { \"type\" : \"object\" , \"title\" : \"Unknown shape types\" , \"description\" : \"Unknown shape types. Types not defined by the specification are still allowed.\" , \"properties\" : { \"ty\" : { \"not\" : { \"$comment\" : \"enum list is dynamically generated\" , \"enum\" : [ \"el\" , \"fl\" , \"gf\" , \"gs\" , \"gr\" , \"mm\" , \"no\" , \"op\" , \"sh\" , \"sr\" , \"pb\" , \"rc\" , \"rp\" , \"rd\" , \"st\" , \"tr\" , \"tm\" , \"tw\" , \"zz\" ] } } } }, \"ellipse\" : { \"type\" : \"object\" , \"title\" : \"Ellipse\" , \"description\" : \"Ellipse shape\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"el\" }, \"p\" : { \"title\" : \"Position\" , \"$ref\" : \"#/$defs/properties/position-property\" }, \"s\" : { \"title\" : \"Size\" , \"$ref\" : \"#/$defs/properties/vector-property\" } }, \"required\" : [ \"ty\" , \"s\" , \"p\" ] } ] }, \"path\" : { \"type\" : \"object\" , \"title\" : \"Path\" , \"description\" : \"Custom Bezier shape\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"sh\" }, \"ks\" : { \"title\" : \"Shape\" , \"description\" : \"Bezier path\" , \"$ref\" : \"#/$defs/properties/bezier-property\" } }, \"required\" : [ \"ty\" , \"ks\" ] } ] }, \"polystar\" : { \"type\" : \"object\" , \"title\" : \"PolyStar\" , \"description\" : \"Star or regular polygon\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"sr\" }, \"p\" : { \"title\" : \"Position\" , \"$ref\" : \"#/$defs/properties/position-property\" }, \"or\" : { \"title\" : \"Outer Radius\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"os\" : { \"title\" : \"Outer Roundness\" , \"description\" : \"Outer Roundness as a percentage\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"r\" : { \"title\" : \"Rotation\" , \"description\" : \"Rotation, clockwise in degrees\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"pt\" : { \"title\" : \"Points\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"sy\" : { \"title\" : \"Star Type\" , \"$ref\" : \"#/$defs/constants/star-type\" , \"default\" : 1 }, \"ir\" : { \"title\" : \"Inner Radius\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"is\" : { \"title\" : \"Inner Roundness\" , \"description\" : \"Inner Roundness as a percentage\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" , \"or\" , \"os\" , \"pt\" , \"p\" , \"r\" ] }, { \"if\" : { \"properties\" : { \"sy\" : { \"const\" : 1 } } }, \"then\" : { \"required\" : [ \"ir\" , \"is\" ] } } ] }, \"no-style\" : { \"type\" : \"object\" , \"title\" : \"No Style\" , \"description\" : \"Represents a style for shapes without fill or stroke\" , \"deprecated\" : true , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"no\" } }, \"required\" : [ \"ty\" ] } ] }, \"repeater\" : { \"type\" : \"object\" , \"title\" : \"Repeater\" , \"description\" : \"Duplicates previous shapes in a group\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/modifier\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"rp\" }, \"c\" : { \"title\" : \"Copies\" , \"description\" : \"Number of copies\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"o\" : { \"title\" : \"Offset\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"m\" : { \"title\" : \"Composite\" , \"description\" : \"Stacking order\" , \"$ref\" : \"#/$defs/constants/composite\" , \"default\" : 1 }, \"tr\" : { \"title\" : \"Transform\" , \"description\" : \"Transform applied to each copy\" , \"$ref\" : \"#/$defs/shapes/repeater-transform\" } }, \"required\" : [ \"ty\" , \"c\" , \"tr\" ] } ] }, \"group\" : { \"type\" : \"object\" , \"title\" : \"Group\" , \"description\" : \"Shape Element that can contain other shapes\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/graphic-element\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"gr\" }, \"np\" : { \"title\" : \"Number Of Properties\" , \"type\" : \"number\" }, \"it\" : { \"title\" : \"Shapes\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/shapes/all-graphic-elements\" } }, \"cix\" : { \"title\" : \"Property index\" , \"description\" : \"Index used in expressions\" , \"type\" : \"integer\" } }, \"required\" : [ \"ty\" ] } ] }, \"pucker-bloat\" : { \"type\" : \"object\" , \"title\" : \"Pucker Bloat\" , \"description\" : \"Interpolates the shape with its center point and bezier tangents with the opposite direction\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/modifier\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"pb\" }, \"a\" : { \"title\" : \"Amount\" , \"description\" : \"Amount as a percentage\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"gradient-fill\" : { \"type\" : \"object\" , \"title\" : \"Gradient\" , \"description\" : \"Gradient fill color\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-style\" }, { \"$ref\" : \"#/$defs/shapes/base-gradient\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"gf\" }, \"r\" : { \"title\" : \"Fill Rule\" , \"$ref\" : \"#/$defs/constants/fill-rule\" } }, \"required\" : [ \"ty\" ] } ] }, \"fill\" : { \"type\" : \"object\" , \"title\" : \"Fill\" , \"description\" : \"Solid fill color\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/shapes/shape-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Shape Type\" , \"type\" : \"string\" , \"const\" : \"fl\" }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/properties/color-property\" }, \"r\" : { \"title\" : \"Fill Rule\" , \"$ref\" : \"#/$defs/constants/fill-rule\" } }, \"required\" : [ \"ty\" , \"c\" ] } ] } }, \"styles\" : { \"outer-glow-style\" : { \"type\" : \"object\" , \"title\" : \"Outer Glow\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 3 }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/properties/color-property\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"r\" : { \"title\" : \"Range\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"ch\" : { \"title\" : \"Choke Spread\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"no\" : { \"title\" : \"Noise\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"j\" : { \"title\" : \"Jitter\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"stroke-style\" : { \"type\" : \"object\" , \"title\" : \"Layer Stroke\" , \"description\" : \"Stroke / frame\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 0 }, \"s\" : { \"title\" : \"Size\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/properties/color-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"drop-shadow-style\" : { \"type\" : \"object\" , \"title\" : \"Drop Shadow\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 1 }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/properties/color-property\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"a\" : { \"title\" : \"Angle\" , \"description\" : \"Local light angle\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"s\" : { \"title\" : \"Size\" , \"description\" : \"Blur size\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"d\" : { \"title\" : \"Distance\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"ch\" : { \"title\" : \"Choke Spread\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"no\" : { \"title\" : \"Noise\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"lc\" : { \"title\" : \"Layer Conceal\" , \"description\" : \"Layer knowck out drop shadow\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"layer-style\" : { \"type\" : \"object\" , \"title\" : \"Layer Style\" , \"description\" : \"Style applied to a layer\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/visual-object\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Style Type\" , \"type\" : \"integer\" } }, \"required\" : [ \"ty\" ] } ] }, \"all-layer-styles\" : { \"oneOf\" : [ { \"$ref\" : \"#/$defs/styles/bevel-emboss-style\" }, { \"$ref\" : \"#/$defs/styles/color-overlay-style\" }, { \"$ref\" : \"#/$defs/styles/drop-shadow-style\" }, { \"$ref\" : \"#/$defs/styles/gradient-overlay-style\" }, { \"$ref\" : \"#/$defs/styles/inner-glow-style\" }, { \"$ref\" : \"#/$defs/styles/inner-shadow-style\" }, { \"$ref\" : \"#/$defs/styles/outer-glow-style\" }, { \"$ref\" : \"#/$defs/styles/satin-style\" }, { \"$ref\" : \"#/$defs/styles/stroke-style\" } ] }, \"inner-glow-style\" : { \"type\" : \"object\" , \"title\" : \"Inner Glow\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 4 }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/properties/color-property\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"r\" : { \"title\" : \"Range\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"sr\" : { \"title\" : \"Source\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"ch\" : { \"title\" : \"Choke Spread\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"no\" : { \"title\" : \"Noise\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"j\" : { \"title\" : \"Jitter\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"satin-style\" : { \"type\" : \"object\" , \"title\" : \"Satin\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 6 }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/properties/color-property\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"a\" : { \"title\" : \"Angle\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"d\" : { \"title\" : \"Distance\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"s\" : { \"title\" : \"Size\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"in\" : { \"title\" : \"Invert\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"color-overlay-style\" : { \"type\" : \"object\" , \"title\" : \"Color Overlay\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 7 }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/properties/color-property\" }, \"so\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"inner-shadow-style\" : { \"type\" : \"object\" , \"title\" : \"Inner Shadow\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 2 }, \"c\" : { \"title\" : \"Color\" , \"$ref\" : \"#/$defs/properties/color-property\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"a\" : { \"title\" : \"Angle\" , \"description\" : \"Local light angle\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"s\" : { \"title\" : \"Size\" , \"description\" : \"Blur size\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"d\" : { \"title\" : \"Distance\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"ch\" : { \"title\" : \"Choke Spread\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"no\" : { \"title\" : \"Noise\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"gradient-overlay-style\" : { \"type\" : \"object\" , \"title\" : \"Gradient Overlay\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 8 }, \"bm\" : { \"title\" : \"Blend Mode\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"o\" : { \"title\" : \"Opacity\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"gf\" : { \"title\" : \"Gradient\" , \"$ref\" : \"#/$defs/properties/gradient-property\" }, \"gs\" : { \"title\" : \"Smoothness\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"a\" : { \"title\" : \"Angle\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"gt\" : { \"title\" : \"Gradient Type\" , \"$ref\" : \"#/$defs/constants/gradient-type\" }, \"re\" : { \"title\" : \"Reverse\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"al\" : { \"title\" : \"Align\" , \"description\" : \"Align with layer\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"s\" : { \"title\" : \"Scale\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"of\" : { \"title\" : \"Offset\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] }, \"bevel-emboss-style\" : { \"type\" : \"object\" , \"title\" : \"Bevel Emboss\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/styles/layer-style\" }, { \"type\" : \"object\" , \"properties\" : { \"ty\" : { \"title\" : \"Type\" , \"description\" : \"Layer Type\" , \"type\" : \"integer\" , \"const\" : 5 }, \"bs\" : { \"title\" : \"Bevel Style\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"bt\" : { \"title\" : \"Technique\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"sr\" : { \"title\" : \"Strength\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"s\" : { \"title\" : \"Size\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"sf\" : { \"title\" : \"Soften\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"ga\" : { \"title\" : \"Global Angle\" , \"description\" : \"Use global light\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"a\" : { \"title\" : \"Angle\" , \"description\" : \"Local lighting angle\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"ll\" : { \"title\" : \"Altitude\" , \"description\" : \"Local lighting altitude\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"hm\" : { \"title\" : \"Highlight Mode\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"hc\" : { \"title\" : \"Highlight Color\" , \"$ref\" : \"#/$defs/properties/color-property\" }, \"ho\" : { \"title\" : \"Highlight Opacity\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"sm\" : { \"title\" : \"Shadow Mode\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"sc\" : { \"title\" : \"Shadow Color\" , \"$ref\" : \"#/$defs/properties/color-property\" }, \"so\" : { \"title\" : \"Shadow Opacity\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"ty\" ] } ] } }, \"text\" : { \"text-document-keyframe\" : { \"type\" : \"object\" , \"title\" : \"Text Document Keyframe\" , \"description\" : \"A keyframe containing a text document\" , \"properties\" : { \"s\" : { \"title\" : \"Start\" , \"$ref\" : \"#/$defs/text/text-document\" }, \"t\" : { \"title\" : \"Time\" , \"type\" : \"number\" , \"default\" : 0 } }, \"required\" : [ \"s\" , \"t\" ] }, \"character-shapes\" : { \"type\" : \"object\" , \"title\" : \"Character Shape\" , \"description\" : \"Defines a character as shapes\" , \"properties\" : { \"shapes\" : { \"title\" : \"Shapes\" , \"description\" : \"Shapes forming the character\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/shapes/all-graphic-elements\" } } }, \"required\" : [ \"shapes\" ] }, \"font\" : { \"type\" : \"object\" , \"title\" : \"Font\" , \"description\" : \"Describes how a font with given settings should be loaded\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"ascent\" : { \"title\" : \"Ascent\" , \"type\" : \"number\" , \"description\" : \"Text will be moved down based on this value\" }, \"fFamily\" : { \"title\" : \"Font Family\" , \"type\" : \"string\" , \"default\" : \"sans\" }, \"fName\" : { \"title\" : \"Name\" , \"description\" : \"Name used by text documents to reference this font, usually it's fFamily followed by fStyle \" , \"type\" : \"string\" , \"default\" : \"sans-Regular\" }, \"fStyle\" : { \"title\" : \"Font Style\" , \"examples\" : [ \"Regular\" , \"Bold\" , \"Bold Italic\" ], \"type\" : \"string\" , \"default\" : \"Regular\" }, \"fPath\" : { \"title\" : \"Path\" , \"type\" : \"string\" }, \"fWeight\" : { \"title\" : \"Weight\" , \"type\" : \"string\" }, \"origin\" : { \"title\" : \"Origin\" , \"$ref\" : \"#/$defs/constants/font-path-origin\" }, \"fClass\" : { \"type\" : \"string\" , \"title\" : \"CSS Class\" , \"description\" : \"CSS Class applied to text objects using this font\" } }, \"required\" : [ \"fFamily\" , \"fName\" , \"fStyle\" ] } ] }, \"text-data\" : { \"type\" : \"object\" , \"title\" : \"Text Data\" , \"description\" : \"Contains all the text data and animation\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"a\" : { \"title\" : \"Ranges\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/text/text-range\" } }, \"d\" : { \"title\" : \"Document\" , \"$ref\" : \"#/$defs/text/animated-text-document\" }, \"m\" : { \"title\" : \"Alignment\" , \"$ref\" : \"#/$defs/text/text-alignment-options\" }, \"p\" : { \"title\" : \"Follow Path\" , \"$ref\" : \"#/$defs/text/text-follow-path\" } }, \"required\" : [ \"a\" , \"d\" , \"m\" , \"p\" ] } ] }, \"text-follow-path\" : { \"type\" : \"object\" , \"title\" : \"Text Follow Path\" , \"description\" : \"Uses the path described by a layer mask to put the text on said path.\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"m\" : { \"title\" : \"Mask\" , \"type\" : \"integer\" , \"description\" : \"Index of the mask to use\" }, \"f\" : { \"title\" : \"First Margin\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"l\" : { \"title\" : \"Last Margin\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"r\" : { \"title\" : \"Reverse Path\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"a\" : { \"title\" : \"Force Alignment\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"p\" : { \"title\" : \"Perpendicular To Path\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [] } ] }, \"text-range\" : { \"type\" : \"object\" , \"title\" : \"Text Range\" , \"description\" : \"Range of text with custom animations and style\" , \"properties\" : { \"nm\" : { \"title\" : \"Name\" , \"type\" : \"string\" }, \"s\" : { \"title\" : \"Selector\" , \"$ref\" : \"#/$defs/text/text-range-selector\" }, \"a\" : { \"title\" : \"Style\" , \"$ref\" : \"#/$defs/text/text-style\" } } }, \"text-document\" : { \"type\" : \"object\" , \"title\" : \"Text Document\" , \"description\" : \"\" , \"properties\" : { \"f\" : { \"title\" : \"Font Family\" , \"type\" : \"string\" , \"default\" : \"\" }, \"fc\" : { \"title\" : \"Fill Color\" , \"$ref\" : \"#/$defs/values/color\" , \"default\" : [ 0 , 0 , 0 ] }, \"sc\" : { \"title\" : \"Stroke Color\" , \"$ref\" : \"#/$defs/values/color\" }, \"sw\" : { \"title\" : \"Stroke Width\" , \"type\" : \"number\" , \"default\" : 0 }, \"of\" : { \"title\" : \"Stroke Over Fill\" , \"description\" : \"Render stroke above the fill\" , \"type\" : \"boolean\" }, \"s\" : { \"title\" : \"Font Size\" , \"type\" : \"number\" , \"default\" : 10 }, \"lh\" : { \"title\" : \"Line Height\" , \"description\" : \"Distance between lines on multiline or wrapped text\" , \"type\" : \"number\" }, \"sz\" : { \"title\" : \"Wrap Size\" , \"description\" : \"Size of the box containing the text\" , \"type\" : \"array\" , \"minItems\" : 2 , \"maxItems\" : 2 , \"items\" : { \"type\" : \"number\" } }, \"ps\" : { \"title\" : \"Wrap Position\" , \"description\" : \"Position of the box containing the text\" , \"type\" : \"array\" , \"minItems\" : 2 , \"maxItems\" : 2 , \"items\" : { \"type\" : \"number\" } }, \"t\" : { \"title\" : \"Text\" , \"type\" : \"string\" , \"description\" : \"Text, note that newlines are encoded with \\r\" , \"default\" : \"\" }, \"j\" : { \"title\" : \"Justify\" , \"$ref\" : \"#/$defs/constants/text-justify\" , \"default\" : 0 }, \"ca\" : { \"title\" : \"Text Caps\" , \"$ref\" : \"#/$defs/constants/text-caps\" }, \"tr\" : { \"title\" : \"Tracking\" , \"description\" : \"Text Tracking\" , \"type\" : \"number\" }, \"ls\" : { \"title\" : \"Baseline Shift\" , \"type\" : \"number\" , \"default\" : 0 } }, \"required\" : [ \"f\" , \"fc\" , \"s\" , \"t\" ] }, \"text-style\" : { \"type\" : \"object\" , \"title\" : \"Text Style\" , \"description\" : \"\" , \"allOf\" : [ { \"$ref\" : \"#/$defs/helpers/transform\" }, { \"type\" : \"object\" , \"properties\" : { \"sw\" : { \"title\" : \"Stroke Width\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"sc\" : { \"title\" : \"Stroke Color\" , \"$ref\" : \"#/$defs/properties/color-property\" }, \"sh\" : { \"title\" : \"Stroke Hue\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"ss\" : { \"title\" : \"Stroke Saturation\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"sb\" : { \"title\" : \"Stroke Brightness\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"so\" : { \"title\" : \"Stroke Opacity\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"fc\" : { \"title\" : \"Fill Color\" , \"$ref\" : \"#/$defs/properties/color-property\" }, \"fh\" : { \"title\" : \"Fill Hue\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"fs\" : { \"title\" : \"Fill Saturation\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"fb\" : { \"title\" : \"Fill Brightness\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"fo\" : { \"title\" : \"Fill Opacity\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"t\" : { \"title\" : \"Letter Spacing\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"bl\" : { \"title\" : \"Blur\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"ls\" : { \"title\" : \"Line Spacing\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [] } ] }, \"font-list\" : { \"type\" : \"object\" , \"title\" : \"Font List\" , \"description\" : \"List of fonts\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"list\" : { \"title\" : \"List\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/text/font\" } } }, \"required\" : [] } ] }, \"text-range-selector\" : { \"type\" : \"object\" , \"title\" : \"Text Range Selector\" , \"properties\" : { \"t\" : { \"title\" : \"Expressible\" , \"$ref\" : \"#/$defs/values/int-boolean\" }, \"xe\" : { \"title\" : \"Max Ease\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"ne\" : { \"title\" : \"Min Ease\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"a\" : { \"title\" : \"Max Amount\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"b\" : { \"title\" : \"Based On\" , \"$ref\" : \"#/$defs/constants/text-based\" }, \"rn\" : { \"title\" : \"Randomize\" , \"$ref\" : \"#/$defs/values/int-boolean\" }, \"sh\" : { \"title\" : \"Shape\" , \"$ref\" : \"#/$defs/constants/text-shape\" }, \"o\" : { \"title\" : \"Offset\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"r\" : { \"title\" : \"Range Units\" , \"$ref\" : \"#/$defs/constants/text-range-units\" }, \"sm\" : { \"title\" : \"Selector Smoothness\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"s\" : { \"title\" : \"Start\" , \"$ref\" : \"#/$defs/properties/scalar-property\" }, \"e\" : { \"title\" : \"End\" , \"$ref\" : \"#/$defs/properties/scalar-property\" } }, \"required\" : [ \"t\" , \"a\" , \"b\" , \"sh\" ] }, \"animated-text-document\" : { \"type\" : \"object\" , \"title\" : \"Animated Text Document\" , \"description\" : \"Animated property representing the text contents\" , \"properties\" : { \"k\" : { \"title\" : \"Keyframes\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/text/text-document-keyframe\" } }, \"x\" : { \"title\" : \"Expression\" , \"type\" : \"string\" }, \"sid\" : { \"title\" : \"Slot ID\" , \"description\" : \"One of the ID in the file's slots\" , \"type\" : \"string\" } }, \"required\" : [ \"k\" ] }, \"text-alignment-options\" : { \"type\" : \"object\" , \"title\" : \"Text Alignment Options\" , \"description\" : \"\" , \"allOf\" : [ { \"type\" : \"object\" , \"properties\" : { \"a\" : { \"title\" : \"Alignment\" , \"description\" : \"Group alignment\" , \"$ref\" : \"#/$defs/properties/vector-property\" }, \"g\" : { \"title\" : \"Grouping\" , \"description\" : \"Anchor point grouping\" , \"$ref\" : \"#/$defs/constants/text-grouping\" } }, \"required\" : [] } ] }, \"character-precomp\" : { \"type\" : \"object\" , \"title\" : \"Character Precomp\" , \"description\" : \"Defines a character as a precomp layer\" , \"properties\" : { \"refId\" : { \"title\" : \"Reference Id\" , \"description\" : \"ID of the precomp as specified in the assets\" , \"type\" : \"string\" }, \"ks\" : { \"title\" : \"Transform\" , \"description\" : \"Layer transform\" , \"$ref\" : \"#/$defs/helpers/transform\" }, \"ip\" : { \"title\" : \"In Point\" , \"description\" : \"Frame when the layer becomes visible\" , \"type\" : \"number\" , \"default\" : 0 }, \"op\" : { \"title\" : \"Out Point\" , \"description\" : \"Frame when the layer becomes invisible\" , \"type\" : \"number\" , \"default\" : 99999 }, \"sr\" : { \"title\" : \"Time Stretch\" , \"type\" : \"number\" , \"default\" : 1 }, \"st\" : { \"title\" : \"Start Time\" , \"type\" : \"number\" , \"default\" : 0 } }, \"required\" : [ \"refId\" ] }, \"character-data\" : { \"type\" : \"object\" , \"title\" : \"Character Data\" , \"description\" : \"Defines character shapes\" , \"properties\" : { \"ch\" : { \"title\" : \"Character\" , \"type\" : \"string\" , \"default\" : \"\" }, \"fFamily\" : { \"title\" : \"Font Family\" , \"type\" : \"string\" , \"default\" : \"\" }, \"size\" : { \"title\" : \"Font Size\" , \"type\" : \"number\" , \"default\" : 0 }, \"style\" : { \"title\" : \"Font Style\" , \"type\" : \"string\" , \"default\" : \"\" }, \"w\" : { \"title\" : \"Width\" , \"type\" : \"number\" , \"default\" : 0 }, \"data\" : { \"title\" : \"Data\" , \"oneOf\" : [ { \"$ref\" : \"#/$defs/text/character-shapes\" }, { \"$ref\" : \"#/$defs/text/character-precomp\" } ] } }, \"required\" : [ \"data\" , \"ch\" , \"fFamily\" , \"size\" , \"style\" , \"w\" ] } }, \"values\" : { \"hexcolor\" : { \"type\" : \"string\" , \"title\" : \"Hex Color\" , \"description\" : \"Color value in hexadecimal format, with two digits per component ('#RRGGBB')\" , \"pattern\" : \"^#([a-fA-F0-9]{6})$\" , \"examples\" : [ \"#FF00AA\" ] }, \"int-boolean\" : { \"type\" : \"integer\" , \"title\" : \"Integer Boolean\" , \"description\" : \"Represents boolean values as an integer. 0 is false, 1 is true.\" , \"default\" : 0 , \"examples\" : [ 0 ], \"enum\" : [ 0 , 1 ], \"oneOf\" : [ { \"title\" : \"True\" , \"const\" : 1 }, { \"title\" : \"False\" , \"const\" : 0 } ] }, \"gradient\" : { \"type\" : \"array\" , \"title\" : \"Gradient\" , \"description\" : \"A flat list of color stops followed by optional transparency stops. A color stop is [offset, red, green, blue]. A transparency stop is [offset, transparency]. All values are between 0 and 1\" , \"items\" : { \"type\" : \"number\" , \"minimum\" : 0 , \"maximum\" : 1 } }, \"bezier\" : { \"type\" : \"object\" , \"title\" : \"Bezier\" , \"description\" : \"Cubic polybezier\" , \"properties\" : { \"c\" : { \"title\" : \"Closed\" , \"type\" : \"boolean\" , \"default\" : false }, \"i\" : { \"title\" : \"In Tangents\" , \"type\" : \"array\" , \"description\" : \"Array of points, each point is an array of coordinates.\\nThese points are along the in tangents relative to the corresponding v .\" , \"items\" : { \"$ref\" : \"#/$defs/values/vector\" , \"default\" : [] } }, \"o\" : { \"title\" : \"Out Tangents\" , \"type\" : \"array\" , \"description\" : \"Array of points, each point is an array of coordinates.\\nThese points are along the out tangents relative to the corresponding v .\" , \"items\" : { \"$ref\" : \"#/$defs/values/vector\" , \"default\" : [] } }, \"v\" : { \"title\" : \"Vertices\" , \"description\" : \"Array of points, each point is an array of coordinates.\\nThese points are along the bezier path\" , \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/$defs/values/vector\" , \"default\" : [] } } }, \"required\" : [ \"i\" , \"v\" , \"o\" ] }, \"color\" : { \"type\" : \"array\" , \"title\" : \"Color\" , \"description\" : \"Color as a [r, g, b] array with values in [0, 1]\" , \"items\" : { \"type\" : \"number\" , \"minimum\" : 0 , \"maximum\" : 1 }, \"minItems\" : 3 , \"maxItems\" : 4 }, \"data-url\" : { \"type\" : \"string\" , \"title\" : \"Data URL\" , \"description\" : \"An embedded data object\" , \"pattern\" : \"^data:([\\w/]+)(;base64)?,(.+)$\" }, \"vector\" : { \"type\" : \"array\" , \"title\" : \"Vector\" , \"description\" : \"An array of numbers\" , \"items\" : { \"type\" : \"number\" } } } } }","title":"JSON Schema"},{"location":"shapes/","text":"Shape Elements Lottie considers everything related to vector data as a \"shape\" but I think it's worth distinguishing across a few categories: Shapes These provide only the shape information, but no styling Style These provide styling info (like fill and stroke) Group This is a shape that contains other shape Modifier These change other shapes Transform Special shape that defines the transforms in a group shape Graphic Element Element used to display vector data in a shape layer Composition Diagram for Graphic Element Graphic Element Visual Object Shape Rectangle Ellipse Path PolyStar Merge Transform Shape Shape Style Gradient Stroke Stroke No Style Gradient Fill Modifier Twist Rounded Corners Offset Path Trim Path Zig Zag Repeater Pucker Bloat Group Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer The ty property defines the specific element type based on the following values: ty Type 'el' Ellipse 'fl' Fill 'gf' Gradient 'gs' Gradient Stroke 'gr' Group 'mm' Merge 'no' No Style 'op' Offset Path 'sh' Path 'sr' PolyStar 'pb' Pucker Bloat 'rc' Rectangle 'rp' Repeater 'rd' Rounded Corners 'st' Stroke 'tr' Transform Shape 'tm' Trim Path 'tw' Twist 'zz' Zig Zag Shapes These shapes only define path data, to actually show something, they must be followed by some style shape . They have a d attribute which specifies the drawing direction, which can be seen when using Trim Path . Composition Diagram for Shape Shape Graphic Element Visual Object Rectangle Ellipse Path PolyStar Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer d Shape Direction Direction Direction the shape is drawn as, mostly relevant when using trim path Ellipse Ellipse shape Composition Diagram for Ellipse Ellipse Shape Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'el' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer d Shape Direction Direction Direction the shape is drawn as, mostly relevant when using trim path p Position Position Position s Vector Size Size Example Position x 256 Position y 256 Width 256 Height 256 var lottie_player_52 = new PlaygroundPlayer( 52, 'playground_52_5', 'lottie_target_52', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [256, 256]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[0].shapes[0].it[0].p.k = [ data[\"Position x\"], data[\"Position y\"] ]; lottie.layers[0].shapes[0].it[0].s.k = [ data[\"Width\"], data[\"Height\"] ]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[0]; }, {} ); Rectangle A simple rectangle shape Composition Diagram for Rectangle Rectangle Shape Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'rc' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer d Shape Direction Direction Direction the shape is drawn as, mostly relevant when using trim path p Position Position Center of the rectangle s Vector Size Size r Scalar Rounded Rounded corners radius Example Position x 256 Position y 256 Width 256 Height 256 Roundness 0 var lottie_player_53 = new PlaygroundPlayer( 53, 'playground_53_6', 'lottie_target_53', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[0].shapes[0].it[0].p.k = [ data[\"Position x\"], data[\"Position y\"] ]; lottie.layers[0].shapes[0].it[0].s.k = [ data[\"Width\"], data[\"Height\"] ]; lottie.layers[0].shapes[0].it[0].r.k = data[\"Roundness\"]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[0]; }, {} ); PolyStar PolyStar Star or regular polygon Composition Diagram for PolyStar PolyStar Shape Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'sr' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer d Shape Direction Direction Direction the shape is drawn as, mostly relevant when using trim path p Position Position Position or Scalar Outer Radius Outer Radius os Scalar Outer Roundness Outer Roundness as a percentage r Scalar Rotation Rotation, clockwise in degrees pt Scalar Points Points sy Star Type Star Type Star Type ir Scalar Inner Radius Inner Radius is Scalar Inner Roundness Inner Roundness as a percentage Example Position x 256 Position y 256 Points 5 Rotation 0 Outer Radius 200 Inner Radius 100 Outer Roundness 0 Inner Roundness 0 Star Type Star Polygon var lottie_player_54 = new PlaygroundPlayer( 54, 'playground_54_10', 'lottie_target_54', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [{\"ty\": 4, \"ddd\": 0, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ip\": 0, \"op\": 180, \"ind\": 0, \"st\": 0, \"sr\": 1, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.979995422293431, 0.28000305180437934]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var star = { \"ty\": \"sr\", \"nm\": \"PolyStar\", \"sy\": Number(data[\"Star Type\"]), \"p\": { \"a\": 0, \"k\": [data[\"Position x\"], data[\"Position y\"]] }, \"r\": { \"a\": 0, \"k\": data[\"Rotation\"] }, \"pt\": { \"a\": 0, \"k\": data[\"Points\"] }, \"or\": { \"a\": 0, \"k\": data[\"Outer Radius\"] }, \"os\": { \"a\": 0, \"k\": data[\"Outer Roundness\"] }, }; if ( data[\"Star Type\"] == \"1\" ) { star = { ...star, \"ir\": { \"a\": 0, \"k\": data[\"Inner Radius\"] }, \"is\": { \"a\": 0, \"k\": data[\"Inner Roundness\"] }, }; } lottie.layers[0].shapes[0].it[0] = star; this.json_viewer_contents = lottie.layers[0].shapes[0].it[0]; }, {} ); Path Custom Bezier shape Composition Diagram for Path Path Shape Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'sh' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer d Shape Direction Direction Direction the shape is drawn as, mostly relevant when using trim path ks Bezier Shape Bezier path Example Shape var lottie_player_55 = new PlaygroundPlayer( 55, 'playground_55_2', 'lottie_target_55', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { var shape = lottie.layers[0].shapes[0].it[0]; if ( data[\"Shape\"] ) shape.ks.k = data[\"Shape\"]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[0]; }, {} ); var playground_55_1_playground = document.getElementById(\"playground_55_1_playground\"); playground_55_1_playground.name = playground_55_1_playground.getAttribute(\"name\"); var playground_55_1_playground_editor = BezierPreviewEditor.stand_alone( playground_55_1_playground, (lottie) => { playground_55_1_playground.value = lottie; lottie_player_55.reload(); }, null, 512, 512 ); Style These apply a style (such as fill stroke) to the paths defined by the shapes . Each style is applied to all preceding shapes in the same group / layer. In most formats the style is usually defined as a property of a shape, in lottie they are separate and allows for more flexibility. Some examples of the added flexibility would be a shape with multiple strokes, or a gradient fading into a solid color. Composition Diagram for Shape Style Shape Style Graphic Element Visual Object Gradient Stroke Stroke No Style Gradient Fill Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer o Scalar Opacity Opacity, 100 means fully opaque Fill Solid fill color Composition Diagram for Fill Fill Shape Style Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'fl' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer o Scalar Opacity Opacity, 100 means fully opaque c Color Color Color r Fill Rule Fill Rule Fill Rule Example Red 1 Green 0.98 Blue 0.28 Opacity 100 Fill Rule Non Zero Even Odd var lottie_player_56 = new PlaygroundPlayer( 56, 'playground_56_6', 'lottie_target_56', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{f5d94f54-bb8f-4f07-be45-232ebd4b9eb1}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{4b0993ed-e35b-48a5-ab12-687dbc147c7c}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Path\", \"mn\": \"{29196ff2-0a65-48b4-a450-f9fbc3a3640d}\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Path\", \"mn\": \"{bb7e6c60-755e-4a21-a7ba-bd054feab5c7}\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [[125.51641791044776, 452.20298507462684], [240.71641791044777, 38.6865671641791], [435.8686567164179, 447.9044776119403], [42.125373134328356, 173.65970149253732], [460.8, 156.46567164179103]], \"i\": [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]], \"o\": [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]]}}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{3af40b83-15f6-4f69-aa2a-96acd03eb3b6}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.98, 0.28]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [251.46268656716418, 245.4447761194029]}, \"p\": {\"a\": 0, \"k\": [251.46268656716418, 245.4447761194029]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var shape = lottie.layers[0].shapes[0].it[1]; shape.c.k = [data[\"Red\"], data[\"Green\"], data[\"Blue\"]]; shape.o.k = data[\"Opacity\"]; shape.r = Number(data[\"Fill Rule\"]); this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; }, {} ); Stroke Solid stroke Composition Diagram for Stroke Stroke Shape Style Base Stroke Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'st' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer o Scalar Opacity Opacity, 100 means fully opaque lc Line Cap Line Cap Line Cap lj Line Join Line Join Line Join ml number Miter Limit Miter Limit ml2 Scalar Miter Limit Animatable alternative to ml w Scalar Width Stroke width d array of Stroke Dash Dashes Dashed line definition c Color Color Stroke color Example Red 1 Green 0.98 Blue 0.28 Width 32 Opacity 100 Line Cap Butt Round Square Line Join Miter Round Bevel Miter Limit 3 var lottie_player_57 = new PlaygroundPlayer( 57, 'playground_57_9', 'lottie_target_57', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"tm\", \"nm\": \"Trim Path\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"s\": {\"a\": 0, \"k\": 0}, \"e\": {\"a\": 0, \"k\": 100}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.98, 0.28]}, \"lc\": 2, \"lj\": 2, \"ml\": 3, \"w\": {\"a\": 0, \"k\": 20}, \"d\": [{\"n\": \"o\", \"nm\": \"offset\", \"v\": {\"a\": 0, \"k\": 0}}, {\"n\": \"d\", \"nm\": \"dash\", \"v\": {\"a\": 0, \"k\": 100}}, {\"n\": \"g\", \"nm\": \"gap\", \"v\": {\"a\": 0, \"k\": 0}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var shape = lottie.layers[0].shapes[2]; shape.c.k = [data[\"Red\"], data[\"Green\"], data[\"Blue\"]]; shape.o.k = data[\"Opacity\"]; shape.w.k = data[\"Width\"]; shape.lc = Number(data[\"Line Cap\"]); shape.lj = Number(data[\"Line Join\"]); shape.ml = data[\"Miter Limit\"]; shape.d = undefined; this.json_viewer_contents = lottie.layers[0].shapes[2]; }, {} ); Stroke Dashes An item used to described the dash pattern in a stroked path A stroke dash array consists of n dash entries, [n-1,n] gap entries and [0-1] offset entries. Dash and gap entries MUST all be in a continuous order and alternate between dash and gap, starting with dash. If there are an odd number of dashes + gaps, the sequence will repeat with dashes and gaps reversed. For example a sequence of [4d, 8g, 16d] MUST be rendered as [4d, 8g, 16d, 4g, 8d, 16g] . Offset entry, if present, MUST be at the end of the array. Composition Diagram for Stroke Dash Stroke Dash Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions n Stroke Dash Type Dash Type Dash Type v Scalar Length Length of the dash Example Red 1 Green 0.98 Blue 0.28 Width 32 Opacity 100 Line Cap Butt Round Square Line Join Miter Round Bevel Miter Limit 3 Dash Offset 0 Dash Length 30 Dash Gap 50 var lottie_player_58 = new PlaygroundPlayer( 58, 'playground_58_12', 'lottie_target_58', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"tm\", \"nm\": \"Trim Path\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"s\": {\"a\": 0, \"k\": 0}, \"e\": {\"a\": 0, \"k\": 100}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.98, 0.28]}, \"lc\": 2, \"lj\": 2, \"ml\": 3, \"w\": {\"a\": 0, \"k\": 20}, \"d\": [{\"n\": \"o\", \"nm\": \"offset\", \"v\": {\"a\": 0, \"k\": 0}}, {\"n\": \"d\", \"nm\": \"dash\", \"v\": {\"a\": 0, \"k\": 100}}, {\"n\": \"g\", \"nm\": \"gap\", \"v\": {\"a\": 0, \"k\": 0}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var shape = lottie.layers[0].shapes[2]; shape.c.k = [data[\"Red\"], data[\"Green\"], data[\"Blue\"]]; shape.o.k = data[\"Opacity\"]; shape.w.k = data[\"Width\"]; shape.lc = Number(data[\"Line Cap\"]); shape.lj = Number(data[\"Line Join\"]); shape.ml = data[\"Miter Limit\"]; shape.d[0].v.k = data[\"Dash Offset\"]; shape.d[1].v.k = data[\"Dash Length\"]; shape.d[2].v.k = data[\"Dash Gap\"]; var trim = lottie.layers[0].shapes[1]; trim.e.k = 100; trim.o.k = 0; this.json_viewer_contents = lottie.layers[0].shapes[2]; }, {} ); Base Gradient Common properties for gradients Composition Diagram for Base Gradient Base Gradient Gradient Stroke Gradient Attribute Type Title Description g Gradient Colors Gradient colors s Position Start Point Starting point for the gradient e Position End Point End point for the gradient t Gradient Type Gradient Type Type of the gradient h Scalar Highlight Length Highlight Length, as a percentage between s and e a Scalar Highlight Angle Highlight Angle in clockwise degrees, relative to the direction from s to e Gradient Fill Gradient fill color Composition Diagram for Gradient Gradient Shape Style Base Gradient Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'gf' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer o Scalar Opacity Opacity, 100 means fully opaque g Gradient Colors Gradient colors s Position Start Point Starting point for the gradient e Position End Point End point for the gradient t Gradient Type Gradient Type Type of the gradient h Scalar Highlight Length Highlight Length, as a percentage between s and e a Scalar Highlight Angle Highlight Angle in clockwise degrees, relative to the direction from s to e r Fill Rule Fill Rule Fill Rule Example Start X 256 Start Y 496 End X 256 End Y 16 Type Linear Radial Highlight 0 Highlight Angle 0 var lottie_player_59 = new PlaygroundPlayer( 59, 'playground_59_8', 'lottie_target_59', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{3da63a46-0ec5-45b8-90fb-d31c5614d5be}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 1, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer 2\", \"mn\": \"{04a8ef87-75fd-451c-868b-7413969c8ad9}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"e\", \"mn\": \"{078a0bf7-08ce-49f7-9dca-c473ad9ff09d}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"e\", \"mn\": \"{efb1ff36-fe2b-4939-97a5-d75a167d003b}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"e\", \"mn\": \"{759da60a-0439-496c-89a9-66e1d721ceb7}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"\", \"mn\": \"{b56ba91b-5ef9-40d2-a1da-27265d105c7a}\", \"it\": [{\"ty\": \"sh\", \"nm\": \"\", \"mn\": \"{020e377d-646e-45f6-830f-756cfff57aa9}\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [[3.7994567051676293, -7.097994637365934], [5.33994951436286, -6.707992504500113], [6.327946284594615, -5.609490432573314], [6.672442201680043, -3.952002315682892], [6.672442201680043, -3.262995246756169], [1.901449879997, -3.262995246756169], [2.505949758118953, -1.4624984765244131], [4.124444517362934, -0.8449957342683567], [5.300948539338484, -0.968496282719568], [6.360449636240906, -1.326002681317033], [6.360449636240906, -0.32500304695117377], [5.307446162716568, 0.019500487512187806], [4.072448295582389, 0.12999817182929574], [2.3239477471311782, -0.2729992077926948], [1.1409537191554788, -1.4755013406585165], [0.7184558520213006, -3.4319943936098403], [1.1019527441311032, -5.395000304695118], [2.1809543285457136, -6.655996282719569], [3.7994567051676293, -7.097994637365934]], \"i\": [[0, 0], [-0.4290005687642191, -0.2600014219105473], [-0.22966394472361795, -0.4723332927073187], [0, -0.6326587852196304], [0, 0], [0, 0], [-0.3856627665691641, -0.411668494837371], [-0.69333373959349, 0], [-0.34233512087802254, 0.08233369896747422], [-0.3639989437235931, 0.15600390009750242], [0, 0], [0.34666686979674477, -0.07366512287807196], [0.47666504162604095, 0], [0.506997440561014, 0.2686649197479937], [0.281665244756119, 0.5330031688292207], [0, 0.7713255331383286], [-0.25566459473986836, 0.5459984155853892], [-0.4636697948698716, 0.29466556976424485], [-0.6153317895447388, 0]], \"o\": [[0.5979946373659342, 0], [0.4290005687642182, 0.2600014219105473], [0.22966394472361795, 0.47233329270731783], [0, 0], [0, 0], [0.017337152178804383, 0.7886626853171328], [0.3856627665691641, 0.411668494837371], [0.4420008937723443, 0], [0.34233512087802165, -0.08233369896747411], [0, 0], [-0.35533544588614685, 0.15600390009750242], [-0.34666686979674477, 0.07366512287807195], [-0.6586695917397929, 0], [-0.5069974405610138, -0.26866491974799367], [-0.28166524475611887, -0.5330031688292207], [0, -0.7626721918047954], [0.2556645947398686, -0.5459984155853901], [0.46366979486987203, -0.29466556976424396], [0, 0]]}}}, {\"ty\": \"sh\", \"nm\": \"\", \"mn\": \"{b3f5759c-30aa-4352-a4ea-23b71ead28ad}\", \"ks\": {\"a\": 0, \"k\": {\"c\": false, \"v\": [[3.7864462236555916, -6.162001706292657], [2.4929545113627842, -5.635496160841521], [1.9274556082652068, -4.172997684317108], [5.476452926948174, -4.172997684317108], [5.06045268319208, -5.609498049951249], [3.7864462236555916, -6.162001706292657]], \"i\": [[0, 0], [0.3163344708617717, -0.3510036969674246], [0.06066479786994661, -0.6239952873821846], [0, 0], [0.2686699979999494, 0.36833577089427205], [0.5806676416910426, 0]], \"o\": [[-0.5459933373334334, 0], [-0.3163344708617717, 0.3510036969674246], [0, 0], [-0.008663497837446243, -0.5893311395284879], [-0.2686699979999503, -0.36833577089427205], [0, 0]]}}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"fl\", \"nm\": \"Fill 1\", \"mn\": \"{2fcb588a-7de7-4cba-8508-46952f160940}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [-2.7166567164177735, 3.822454790113566]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [256, 16]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"s\", \"mn\": \"{e16b0057-203a-4dab-8e5b-495775987f85}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"s\", \"mn\": \"{07bcfe04-40c2-4636-807c-d64982f7a44d}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"s\", \"mn\": \"{0de90988-3e53-4e7a-8a7d-cb147d0c42b5}\", \"it\": [{\"ty\": \"sh\", \"nm\": \"\", \"mn\": \"{22460e65-f67b-48b8-844b-e361867d003b}\", \"ks\": {\"a\": 0, \"k\": {\"c\": false, \"v\": [[5.645452073801845, -1.923997318682967], [4.891453536338409, -0.39000213286582164], [2.8634485393384836, 0.12999817182929574], [1.608957802070052, 0.013002864134103353], [0.679454876996925, -0.311992565439136], [0.679454876996925, -1.3519931748293708], [1.6869521347408687, -0.968496282719568], [2.8894542676066903, -0.7929995124878122], [4.150450245631141, -1.0724963436585915], [4.540444761119028, -1.820004875121878], [4.3974513425335635, -2.2880013406585165], [3.8839562785944652, -2.7040015844146104], [2.824447564314108, -3.171998049951249], [1.6674516472286809, -3.6919983546463664], [0.9264559738993475, -4.315998720280507], [0.666459630240756, -5.251999268731718], [1.3879548160579016, -6.616995307695193], [3.2794487830945775, -7.097994637365934], [4.468948051826296, -6.9744940889147236], [5.502443420460512, -6.629998171829296], [5.1124489049726245, -5.719995734268357], [4.189443603277582, -6.031995917085427], [3.2014468330458263, -6.162001706292657], [2.128950489387235, -5.934501096902423], [1.7584564614115354, -5.316990737268432], [1.9274556082652068, -4.82950140159754], [2.4929545113627842, -4.439499268731718], [3.552455608265207, -3.9910032907072677], [4.683453414460362, -3.4839982327683194], [5.398450976899423, -2.853500243756094], [5.645452073801845, -1.923997318682967]], \"i\": [[0, 0], [0.5026656916422914, -0.346666869796745], [0.8493376396909924, 0], [0.35099861871546767, 0.07799687179679493], [0.26866999799995006, 0.13866674791869799], [0, 0], [-0.3943313426585666, -0.11699784682117054], [-0.4073367459186481, 0], [-0.2599963436585919, 0.18633122078051945], [0, 0.31200780019500485], [0.09532894572364281, 0.13866674791869782], [0.2470010969024221, 0.13866674791869782], [0.45933804595114847, 0.17333089577239447], [0.32066621978049437, 0.17333597402435075], [0.17333089577239413, 0.24266426973174227], [0, 0.38133609590239725], [-0.48099679054476374, 0.32066621978049437], [-0.779999187479687, 0], [-0.36833577089427294, -0.08233369896747345], [-0.32066114152853853, -0.14733024575614362], [0, 0], [0.32066621978049437, 0.08667052613815329], [0.3379982937073427, 0], [0.24699601865046583, -0.15166707292682258], [0, -0.2600065001625049], [-0.11266609790244764, -0.13433499899997603], [-0.26433317082927044, -0.12566642291057306], [-0.4420008937723443, -0.17333089577239447], [-0.3119976436910923, -0.1733359740243503], [-0.16466739793494867, -0.24699601865046628], [0, -0.3726725980649519]], \"o\": [[0, 0.6759965874146854], [-0.5026656916422914, 0.3466668697967449], [-0.4853285394634863, 0], [-0.3509986187154679, -0.07799687179679493], [0, 0], [0.27733349583739597, 0.13866674791869804], [0.3943313426585664, 0.11699784682117043], [0.5806676416910421, 0], [0.2599963436585915, -0.18633122078051967], [0, -0.17333089577239424], [-0.09532894572364281, -0.13866674791869826], [-0.24700109690242256, -0.13866674791869826], [-0.45066439160979055, -0.17333089577239447], [-0.3206662197804946, -0.1733359740243503], [-0.17333089577239436, -0.24266426973174315], [0, -0.5893311395284879], [0.4809967905447634, -0.3206662197804935], [0.4246637415935397, 0], [0.36833577089427205, 0.08233369896747433], [0, 0], [-0.2946706480162007, -0.12132959573989321], [-0.3206662197804948, -0.08667052613815329], [-0.4680015437885947, 0], [-0.2469960186504665, 0.15166707292682347], [0, 0.1906578914472865], [0.11266609790244786, 0.13433499899997514], [0.26433317082927044, 0.12566642291057306], [0.44200089377234475, 0.16466739793494822], [0.3119976436910914, 0.17333597402435075], [0.16466739793494867, 0.24699601865046583], [0, 0]]}}}, {\"ty\": \"fl\", \"nm\": \"Fill 1\", \"mn\": \"{2fcb588a-7de7-4cba-8508-46952f160940}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [-2.7166567164177735, 3.822454790113566]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [256, 496]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}, {\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{a5276bb6-4d7c-4b4f-b371-a0e14a279176}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Gradient\", \"mn\": \"{9df3ba96-24a3-412e-abd4-e64e2e76e6df}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{20934ad0-1c22-4752-a5b1-be99889ea79a}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [512, 512]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"gf\", \"nm\": \"Gradient Fill\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"s\": {\"a\": 0, \"k\": [256, 496]}, \"e\": {\"a\": 0, \"k\": [256, 16]}, \"t\": 1, \"h\": {\"a\": 0, \"k\": 0}, \"a\": {\"a\": 0, \"k\": 0}, \"g\": {\"p\": 3, \"k\": {\"a\": 0, \"k\": [0, 0.7686274509803922, 0.8509803921568627, 0.9607843137254902, 0.5, 0.19600213626306554, 0.31400015259021896, 0.6899977111467155, 1, 0.16099794003204396, 0.18399328603036547, 0.45900663767452504, 0, 1, 0.5, 1, 1, 1]}}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [257.4805970149254, 255.76119402985074]}, \"p\": {\"a\": 0, \"k\": [257.4805970149254, 255.76119402985074]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var gradient = lottie.layers[1].shapes[0].it[1]; var start_marker = lottie.layers[0].shapes[1].it[1]; var end_marker = lottie.layers[0].shapes[0].it[1]; gradient.s.k = start_marker.p.k = [data[\"Start X\"], data[\"Start Y\"]]; gradient.e.k = end_marker.p.k = [data[\"End X\"], data[\"End Y\"]]; gradient.t = Number(data[\"Type\"]); if (gradient.t === 2) { gradient.h = { a: 0, k: data[\"Highlight\"] }; gradient.a = { a: 0, k: data[\"Highlight Angle\"] }; } else { delete gradient.h; delete gradient.a; } this.json_viewer_contents = lottie.layers[1].shapes[0].it[1]; }, {} ); Gradient Stroke Gradient stroke Composition Diagram for Gradient Stroke Gradient Stroke Shape Style Base Stroke Base Gradient Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'gs' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer o Scalar Opacity Opacity, 100 means fully opaque lc Line Cap Line Cap Line Cap lj Line Join Line Join Line Join ml number Miter Limit Miter Limit ml2 Scalar Miter Limit Animatable alternative to ml w Scalar Width Stroke width d array of Stroke Dash Dashes Dashed line definition g Gradient Colors Gradient colors s Position Start Point Starting point for the gradient e Position End Point End point for the gradient t Gradient Type Gradient Type Type of the gradient h Scalar Highlight Length Highlight Length, as a percentage between s and e a Scalar Highlight Angle Highlight Angle in clockwise degrees, relative to the direction from s to e Example Start X 256 Start Y 496 End X 256 End Y 16 Type Linear Radial Highlight 0 Highlight Angle 0 var lottie_player_60 = new PlaygroundPlayer( 60, 'playground_60_8', 'lottie_target_60', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 1, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Start/End markers\", \"mn\": \"{04a8ef87-75fd-451c-868b-7413969c8ad9}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"e\", \"mn\": \"{078a0bf7-08ce-49f7-9dca-c473ad9ff09d}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"e\", \"mn\": \"{efb1ff36-fe2b-4939-97a5-d75a167d003b}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"e\", \"mn\": \"{759da60a-0439-496c-89a9-66e1d721ceb7}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"\", \"mn\": \"{b56ba91b-5ef9-40d2-a1da-27265d105c7a}\", \"it\": [{\"ty\": \"sh\", \"nm\": \"\", \"mn\": \"{020e377d-646e-45f6-830f-756cfff57aa9}\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [[3.7994567051676293, -7.097994637365934], [5.33994951436286, -6.707992504500113], [6.327946284594615, -5.609490432573314], [6.672442201680043, -3.952002315682892], [6.672442201680043, -3.262995246756169], [1.901449879997, -3.262995246756169], [2.505949758118953, -1.4624984765244131], [4.124444517362934, -0.8449957342683567], [5.300948539338484, -0.968496282719568], [6.360449636240906, -1.326002681317033], [6.360449636240906, -0.32500304695117377], [5.307446162716568, 0.019500487512187806], [4.072448295582389, 0.12999817182929574], [2.3239477471311782, -0.2729992077926948], [1.1409537191554788, -1.4755013406585165], [0.7184558520213006, -3.4319943936098403], [1.1019527441311032, -5.395000304695118], [2.1809543285457136, -6.655996282719569], [3.7994567051676293, -7.097994637365934]], \"i\": [[0, 0], [-0.4290005687642191, -0.2600014219105473], [-0.22966394472361795, -0.4723332927073187], [0, -0.6326587852196304], [0, 0], [0, 0], [-0.3856627665691641, -0.411668494837371], [-0.69333373959349, 0], [-0.34233512087802254, 0.08233369896747422], [-0.3639989437235931, 0.15600390009750242], [0, 0], [0.34666686979674477, -0.07366512287807196], [0.47666504162604095, 0], [0.506997440561014, 0.2686649197479937], [0.281665244756119, 0.5330031688292207], [0, 0.7713255331383286], [-0.25566459473986836, 0.5459984155853892], [-0.4636697948698716, 0.29466556976424485], [-0.6153317895447388, 0]], \"o\": [[0.5979946373659342, 0], [0.4290005687642182, 0.2600014219105473], [0.22966394472361795, 0.47233329270731783], [0, 0], [0, 0], [0.017337152178804383, 0.7886626853171328], [0.3856627665691641, 0.411668494837371], [0.4420008937723443, 0], [0.34233512087802165, -0.08233369896747411], [0, 0], [-0.35533544588614685, 0.15600390009750242], [-0.34666686979674477, 0.07366512287807195], [-0.6586695917397929, 0], [-0.5069974405610138, -0.26866491974799367], [-0.28166524475611887, -0.5330031688292207], [0, -0.7626721918047954], [0.2556645947398686, -0.5459984155853901], [0.46366979486987203, -0.29466556976424396], [0, 0]]}}}, {\"ty\": \"sh\", \"nm\": \"\", \"mn\": \"{b3f5759c-30aa-4352-a4ea-23b71ead28ad}\", \"ks\": {\"a\": 0, \"k\": {\"c\": false, \"v\": [[3.7864462236555916, -6.162001706292657], [2.4929545113627842, -5.635496160841521], [1.9274556082652068, -4.172997684317108], [5.476452926948174, -4.172997684317108], [5.06045268319208, -5.609498049951249], [3.7864462236555916, -6.162001706292657]], \"i\": [[0, 0], [0.3163344708617717, -0.3510036969674246], [0.06066479786994661, -0.6239952873821846], [0, 0], [0.2686699979999494, 0.36833577089427205], [0.5806676416910426, 0]], \"o\": [[-0.5459933373334334, 0], [-0.3163344708617717, 0.3510036969674246], [0, 0], [-0.008663497837446243, -0.5893311395284879], [-0.2686699979999503, -0.36833577089427205], [0, 0]]}}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"fl\", \"nm\": \"Fill 1\", \"mn\": \"{2fcb588a-7de7-4cba-8508-46952f160940}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [-2.7166567164177735, 3.822454790113566]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [256, 16]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"s\", \"mn\": \"{e16b0057-203a-4dab-8e5b-495775987f85}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"s\", \"mn\": \"{07bcfe04-40c2-4636-807c-d64982f7a44d}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"s\", \"mn\": \"{0de90988-3e53-4e7a-8a7d-cb147d0c42b5}\", \"it\": [{\"ty\": \"sh\", \"nm\": \"\", \"mn\": \"{22460e65-f67b-48b8-844b-e361867d003b}\", \"ks\": {\"a\": 0, \"k\": {\"c\": false, \"v\": [[5.645452073801845, -1.923997318682967], [4.891453536338409, -0.39000213286582164], [2.8634485393384836, 0.12999817182929574], [1.608957802070052, 0.013002864134103353], [0.679454876996925, -0.311992565439136], [0.679454876996925, -1.3519931748293708], [1.6869521347408687, -0.968496282719568], [2.8894542676066903, -0.7929995124878122], [4.150450245631141, -1.0724963436585915], [4.540444761119028, -1.820004875121878], [4.3974513425335635, -2.2880013406585165], [3.8839562785944652, -2.7040015844146104], [2.824447564314108, -3.171998049951249], [1.6674516472286809, -3.6919983546463664], [0.9264559738993475, -4.315998720280507], [0.666459630240756, -5.251999268731718], [1.3879548160579016, -6.616995307695193], [3.2794487830945775, -7.097994637365934], [4.468948051826296, -6.9744940889147236], [5.502443420460512, -6.629998171829296], [5.1124489049726245, -5.719995734268357], [4.189443603277582, -6.031995917085427], [3.2014468330458263, -6.162001706292657], [2.128950489387235, -5.934501096902423], [1.7584564614115354, -5.316990737268432], [1.9274556082652068, -4.82950140159754], [2.4929545113627842, -4.439499268731718], [3.552455608265207, -3.9910032907072677], [4.683453414460362, -3.4839982327683194], [5.398450976899423, -2.853500243756094], [5.645452073801845, -1.923997318682967]], \"i\": [[0, 0], [0.5026656916422914, -0.346666869796745], [0.8493376396909924, 0], [0.35099861871546767, 0.07799687179679493], [0.26866999799995006, 0.13866674791869799], [0, 0], [-0.3943313426585666, -0.11699784682117054], [-0.4073367459186481, 0], [-0.2599963436585919, 0.18633122078051945], [0, 0.31200780019500485], [0.09532894572364281, 0.13866674791869782], [0.2470010969024221, 0.13866674791869782], [0.45933804595114847, 0.17333089577239447], [0.32066621978049437, 0.17333597402435075], [0.17333089577239413, 0.24266426973174227], [0, 0.38133609590239725], [-0.48099679054476374, 0.32066621978049437], [-0.779999187479687, 0], [-0.36833577089427294, -0.08233369896747345], [-0.32066114152853853, -0.14733024575614362], [0, 0], [0.32066621978049437, 0.08667052613815329], [0.3379982937073427, 0], [0.24699601865046583, -0.15166707292682258], [0, -0.2600065001625049], [-0.11266609790244764, -0.13433499899997603], [-0.26433317082927044, -0.12566642291057306], [-0.4420008937723443, -0.17333089577239447], [-0.3119976436910923, -0.1733359740243503], [-0.16466739793494867, -0.24699601865046628], [0, -0.3726725980649519]], \"o\": [[0, 0.6759965874146854], [-0.5026656916422914, 0.3466668697967449], [-0.4853285394634863, 0], [-0.3509986187154679, -0.07799687179679493], [0, 0], [0.27733349583739597, 0.13866674791869804], [0.3943313426585664, 0.11699784682117043], [0.5806676416910421, 0], [0.2599963436585915, -0.18633122078051967], [0, -0.17333089577239424], [-0.09532894572364281, -0.13866674791869826], [-0.24700109690242256, -0.13866674791869826], [-0.45066439160979055, -0.17333089577239447], [-0.3206662197804946, -0.1733359740243503], [-0.17333089577239436, -0.24266426973174315], [0, -0.5893311395284879], [0.4809967905447634, -0.3206662197804935], [0.4246637415935397, 0], [0.36833577089427205, 0.08233369896747433], [0, 0], [-0.2946706480162007, -0.12132959573989321], [-0.3206662197804948, -0.08667052613815329], [-0.4680015437885947, 0], [-0.2469960186504665, 0.15166707292682347], [0, 0.1906578914472865], [0.11266609790244786, 0.13433499899997514], [0.26433317082927044, 0.12566642291057306], [0.44200089377234475, 0.16466739793494822], [0.3119976436910914, 0.17333597402435075], [0.16466739793494867, 0.24699601865046583], [0, 0]]}}}, {\"ty\": \"fl\", \"nm\": \"Fill 1\", \"mn\": \"{2fcb588a-7de7-4cba-8508-46952f160940}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [-2.7166567164177735, 3.822454790113566]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [256, 496]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}, {\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"gs\", \"nm\": \"Stroke\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.98, 0.28]}, \"lc\": 2, \"lj\": 2, \"ml\": 3, \"w\": {\"a\": 0, \"k\": 30}, \"d\": [{\"n\": \"d\", \"nm\": \"dash\", \"v\": {\"a\": 0, \"k\": 100}}, {\"n\": \"g\", \"nm\": \"gap\", \"v\": {\"a\": 0, \"k\": 0}}, {\"n\": \"o\", \"nm\": \"offset\", \"v\": {\"a\": 0, \"k\": 0}}], \"r\": 1, \"s\": {\"a\": 0, \"k\": [256, 496]}, \"e\": {\"a\": 0, \"k\": [256, 16]}, \"t\": 1, \"h\": {\"a\": 0, \"k\": 0}, \"a\": {\"a\": 0, \"k\": 0}, \"g\": {\"p\": 3, \"k\": {\"a\": 0, \"k\": [0, 0.7686274509803922, 0.8509803921568627, 0.9607843137254902, 0.5, 0.19600213626306554, 0.31400015259021896, 0.6899977111467155, 1, 0.16099794003204396, 0.18399328603036547, 0.45900663767452504, 0, 1, 0.5, 1, 1, 1]}}}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var gradient = lottie.layers[1].shapes[1]; var start_marker = lottie.layers[0].shapes[1].it[1]; var end_marker = lottie.layers[0].shapes[0].it[1]; gradient.s.k = start_marker.p.k = [data[\"Start X\"], data[\"Start Y\"]]; gradient.e.k = end_marker.p.k = [data[\"End X\"], data[\"End Y\"]]; gradient.t = Number(data[\"Type\"]); if (gradient.t === 2) { gradient.h = { a: 0, k: data[\"Highlight\"] }; gradient.a = { a: 0, k: data[\"Highlight Angle\"] }; } else { delete gradient.h; delete gradient.a; } this.json_viewer_contents = lottie.layers[1].shapes[1]; }, {} ); No Style Represents a style for shapes without fill or stroke. Composition Diagram for No Style No Style Shape Style Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'no' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer o Scalar Opacity Opacity, 100 means fully opaque Grouping Group A group is a shape that can contain other shapes (including other groups). The usual contents of a group are: Shapes Style Transform For example, if you want to have a red rectangle with a black outline, its group will contain A Rectangle defining the actual shape of the rectangle A Fill for the color red A Stroke for the black outline A Transform for the group transform While the contents may vary, a group must always end with a Transform shape . The attributes of a Group are: Composition Diagram for Group Group Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'gr' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer np number Number Of Properties Number Of Properties it array of Graphic Element Shapes Shapes cix integer Property index Index used in expressions Transform Basically the same as Transform but with the ty attribute. Composition Diagram for Transform Shape Transform Shape Graphic Element Transform Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'tr' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer a Position Anchor Point Anchor point: a position (relative to its parent) around which transformations are applied (ie: center for rotation / scale) p Splittable Position Position Position / Translation r Scalar Rotation Rotation in degrees, clockwise s Vector Scale Scale factor, [100, 100] for no scaling o Scalar Opacity Opacity sk Scalar Skew Skew amount as an angle in degrees sa Scalar Skew Axis Direction along which skew is applied, in degrees ( 0 skews along the X axis, 90 along the Y axis) rx Scalar X Rotation Split rotation component ry Scalar Y Rotation Split rotation component rz Scalar Z Rotation Split rotation component, equivalent to r when not split or Vector Orientation Orientation Transform shapes MUST always be present in the group and they MUST be the last item in the it array. Modifiers Modifiers process their siblings and alter the path defined by shapes . Repeater This is a bit different compared from other modifiers, since it will take into account style as well. The effect of a Repeater is to duplicate the other shapes a number of times applying a transform for each copy. Composition Diagram for Repeater Repeater Modifier Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'rp' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer c Scalar Copies Number of copies o Scalar Offset Offset m Composite Composite Stacking order tr Repeater Transform Transform Transform applied to each copy The transform is multiplied by o + 1 (where o is the Offset property above). So if o is 0 , the first instance shown by the Repeater is at its starting location. If it's 1 , the first instance has the matrix applied to it. Other values multiply the initial transform accordingly. Repeater Transform Same as a regular Transform but instead of a single opacity value ( o ), it has two: Composition Diagram for Repeater Transform Repeater Transform Transform Attribute Type Title Description a Position Anchor Point Anchor point: a position (relative to its parent) around which transformations are applied (ie: center for rotation / scale) p Splittable Position Position Position / Translation r Scalar Rotation Rotation in degrees, clockwise s Vector Scale Scale factor, [100, 100] for no scaling o Scalar Opacity Opacity sk Scalar Skew Skew amount as an angle in degrees sa Scalar Skew Axis Direction along which skew is applied, in degrees ( 0 skews along the X axis, 90 along the Y axis) rx Scalar X Rotation Split rotation component ry Scalar Y Rotation Split rotation component rz Scalar Z Rotation Split rotation component, equivalent to r when not split or Vector Orientation Orientation so Scalar Start Opacity Opacity of the first repeated object. eo Scalar End Opacity Opacity of the last repeated object. Attribute Type Description so Animated number Start Opacity eo Animated number End Opacity The first copy will use so , the last eo , and copies between them will have an interpolated value. Copies 4 Start Opacity 100 End Opacity 50 Position x 130 Position y 0 Rotation 137 Offset 0 Composite Below Above var lottie_player_61 = new PlaygroundPlayer( 61, 'playground_61_9', 'lottie_target_61', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{33a02914-c5a9-4c4e-a0bd-0ec07f05b204}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{9eb62fdc-6d5b-4771-94c0-ebdafbd7a54e}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{bfbf6254-ff78-4d00-9d09-eafe4e34b732}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{5a453691-6b60-4bd3-bc43-e28b7a0ebc48}\", \"p\": {\"a\": 0, \"k\": [80, 120]}, \"or\": {\"a\": 0, \"k\": 80}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{b0ba4cf0-3a1b-45a3-8912-d0ed2bdd2082}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{0c2313ae-ccff-4e71-9e00-81649390d850}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"rp\", \"nm\": \"Repeater\", \"mn\": \"{a9e13270-7dd8-4520-b5a1-c1c9cf96286b}\", \"c\": {\"a\": 0, \"k\": 4}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1, \"tr\": {\"a\": {\"a\": 0, \"k\": [80, 120]}, \"p\": {\"a\": 0, \"k\": [130, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 137.508}, \"so\": {\"a\": 0, \"k\": 100}, \"eo\": {\"a\": 0, \"k\": 50}}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [65.33731343283583, 117.77910447761194]}, \"p\": {\"a\": 0, \"k\": [73.93432835820896, 93.70746268656717]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[0].shapes[0].it[3].c.k = data[\"Copies\"]; lottie.layers[0].shapes[0].it[3].tr.so.k = data[\"Start Opacity\"]; lottie.layers[0].shapes[0].it[3].tr.eo.k = data[\"End Opacity\"]; lottie.layers[0].shapes[0].it[3].tr.p.k[0] = data[\"Position x\"]; lottie.layers[0].shapes[0].it[3].tr.p.k[1] = data[\"Position y\"]; lottie.layers[0].shapes[0].it[3].tr.r.k = data[\"Rotation\"]; lottie.layers[0].shapes[0].it[3].o.k = data[\"Offset\"]; lottie.layers[0].shapes[0].it[3].m = Number(data[\"Composite\"]); this.json_viewer_contents = lottie.layers[0].shapes[0].it[3]; }, {} ); Trim Path This is mostly useful for shapes with a stroke and not a fill. It takes the path defined by shapes and only shows a segment of the resulting bezier data. Composition Diagram for Trim Path Trim Path Modifier Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'tm' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer s Scalar Start Segment start e Scalar End Segment end o Scalar Offset Offset m Trim Multiple Shapes Multiple How to treat multiple copies s and e go from 0 to 100 , 0 being at the beginning of the path and 100 at the end. The displayed segment is what lays between the two. o is an offset from the start, to allow values to wrap around. Its value goes from 0 (start of the path) to 360 (end of the path). It looks like an angle but it isn't really, the difference between o and s is that with o you can go over 360 or below 0 to shift the whole segment along the path. Here is an interactive example: Start 0 End 50 Offset 0 Multiple Shapes Parallel Sequential var lottie_player_62 = new PlaygroundPlayer( 62, 'playground_62_5', 'lottie_target_62', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [128, 128]}, \"or\": {\"a\": 0, \"k\": 100}, \"ir\": {\"a\": 0, \"k\": 50}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{74587b40-1ef1-445d-b9ab-02b8a42a96aa}\", \"p\": {\"a\": 0, \"k\": [384, 128]}, \"s\": {\"a\": 0, \"k\": [200, 200]}}, {\"ty\": \"rc\", \"nm\": \"Rect\", \"mn\": \"{0776f2df-2619-415c-b10d-f648f2edfa0f}\", \"d\": 1, \"p\": {\"a\": 0, \"k\": [128, 384]}, \"s\": {\"a\": 0, \"k\": [200, 200]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"sr\", \"nm\": \"Triangle\", \"mn\": \"{db373594-d0ae-44ff-9295-30ff72616af2}\", \"p\": {\"a\": 0, \"k\": [384, 384]}, \"or\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 3}, \"sy\": 2, \"os\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"tm\", \"nm\": \"Trim Path\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"s\": {\"a\": 0, \"k\": 0}, \"e\": {\"a\": 0, \"k\": 50}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 20}}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { lottie.layers[0].shapes[4].s.k = data[\"Start\"]; lottie.layers[0].shapes[4].e.k = data[\"End\"]; lottie.layers[0].shapes[4].o.k = data[\"Offset\"]; lottie.layers[0].shapes[4].m = Number(data[\"Multiple Shapes\"]); this.json_viewer_contents = lottie.layers[0].shapes[4]; }, {} ); Rounded Corners Rounds corners of other shapes Composition Diagram for Rounded Corners Rounded Corners Modifier Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'rd' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer r Scalar Radius Radius Radius 50 var lottie_player_63 = new PlaygroundPlayer( 63, 'playground_63_2', 'lottie_target_63', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 222.72242736816406}, \"ir\": {\"a\": 0, \"k\": 111.36121368408203}, \"r\": {\"a\": 0, \"k\": 358.67291259765625}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"rd\", \"nm\": \"Rounded Corners\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"r\": {\"a\": 0, \"k\": 50}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"hd\": true, \"nm\": \"Fill\", \"mn\": \"{a1bcc159-6916-4718-841d-a99140c0e74b}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[0].shapes[0].it[1].r.k = data[\"Radius\"]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; }, {} ); Pucker / Bloat Interpolates the shape with its center point and bezier tangents with the opposite direction Composition Diagram for Pucker Bloat Pucker Bloat Modifier Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'pb' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer a Scalar Amount Amount as a percentage When a is 0 , nothing changes. When a is positive, the vertices are pulled towards the center, with 100 being at the center. And the tangents are pushed away. When a is negative the vertices are pushed away from the center with 100 being twice far away from the center. And the tangents are pulled towards the center. The center is defined as the mean of the bezier vertices. Amount 50 var lottie_player_64 = new PlaygroundPlayer( 64, 'playground_64_2', 'lottie_target_64', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 160}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 2, \"os\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"pb\", \"nm\": \"Inflate and Deflate\", \"mn\": \"{b4af429a-546e-4728-a869-711a404c55ae}\", \"a\": {\"a\": 0, \"k\": 50}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"hd\": true, \"nm\": \"Fill\", \"mn\": \"{a1bcc159-6916-4718-841d-a99140c0e74b}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[0].shapes[0].it[1].a.k = data[\"Amount\"]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; }, {} ); Twist Composition Diagram for Twist Twist Modifier Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'tw' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer a Scalar Angle Angle c Vector Center Center Merge Boolean operator on shapes Composition Diagram for Merge Merge Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'mm' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer mm Merge Mode Merge Mode Merge Mode Offset Path Interpolates the shape with its center point and bezier tangents with the opposite direction Composition Diagram for Offset Path Offset Path Modifier Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'op' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer a Scalar Amount Amount lj Line Join Line Join Line Join ml Scalar Miter Limit Miter Limit Zig Zag Changes the edges of affected shapes into a series of peaks and valleys of uniform size Composition Diagram for Zig Zag Zig Zag Modifier Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'zz' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer r Scalar Frequency Number of ridges per segment s Scalar Amplitude Distance between peaks and troughs pt Scalar Point Type Point type (1 = corner, 2 = smooth)","title":"Shapes"},{"location":"shapes/#shape-elements","text":"Lottie considers everything related to vector data as a \"shape\" but I think it's worth distinguishing across a few categories: Shapes These provide only the shape information, but no styling Style These provide styling info (like fill and stroke) Group This is a shape that contains other shape Modifier These change other shapes Transform Special shape that defines the transforms in a group shape","title":"Shape Elements"},{"location":"shapes/#graphic-element","text":"Element used to display vector data in a shape layer Composition Diagram for Graphic Element Graphic Element Visual Object Shape Rectangle Ellipse Path PolyStar Merge Transform Shape Shape Style Gradient Stroke Stroke No Style Gradient Fill Modifier Twist Rounded Corners Offset Path Trim Path Zig Zag Repeater Pucker Bloat Group Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer The ty property defines the specific element type based on the following values: ty Type 'el' Ellipse 'fl' Fill 'gf' Gradient 'gs' Gradient Stroke 'gr' Group 'mm' Merge 'no' No Style 'op' Offset Path 'sh' Path 'sr' PolyStar 'pb' Pucker Bloat 'rc' Rectangle 'rp' Repeater 'rd' Rounded Corners 'st' Stroke 'tr' Transform Shape 'tm' Trim Path 'tw' Twist 'zz' Zig Zag","title":"Graphic Element"},{"location":"shapes/#shape","text":"These shapes only define path data, to actually show something, they must be followed by some style shape . They have a d attribute which specifies the drawing direction, which can be seen when using Trim Path . Composition Diagram for Shape Shape Graphic Element Visual Object Rectangle Ellipse Path PolyStar Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer d Shape Direction Direction Direction the shape is drawn as, mostly relevant when using trim path","title":"Shapes"},{"location":"shapes/#ellipse","text":"Ellipse shape Composition Diagram for Ellipse Ellipse Shape Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'el' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer d Shape Direction Direction Direction the shape is drawn as, mostly relevant when using trim path p Position Position Position s Vector Size Size Example Position x 256 Position y 256 Width 256 Height 256 var lottie_player_52 = new PlaygroundPlayer( 52, 'playground_52_5', 'lottie_target_52', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [256, 256]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[0].shapes[0].it[0].p.k = [ data[\"Position x\"], data[\"Position y\"] ]; lottie.layers[0].shapes[0].it[0].s.k = [ data[\"Width\"], data[\"Height\"] ]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[0]; }, {} );","title":"Ellipse"},{"location":"shapes/#rectangle","text":"A simple rectangle shape Composition Diagram for Rectangle Rectangle Shape Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'rc' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer d Shape Direction Direction Direction the shape is drawn as, mostly relevant when using trim path p Position Position Center of the rectangle s Vector Size Size r Scalar Rounded Rounded corners radius Example Position x 256 Position y 256 Width 256 Height 256 Roundness 0 var lottie_player_53 = new PlaygroundPlayer( 53, 'playground_53_6', 'lottie_target_53', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[0].shapes[0].it[0].p.k = [ data[\"Position x\"], data[\"Position y\"] ]; lottie.layers[0].shapes[0].it[0].s.k = [ data[\"Width\"], data[\"Height\"] ]; lottie.layers[0].shapes[0].it[0].r.k = data[\"Roundness\"]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[0]; }, {} );","title":"Rectangle"},{"location":"shapes/#polystar_1","text":"","title":"PolyStar"},{"location":"shapes/#polystar","text":"Star or regular polygon Composition Diagram for PolyStar PolyStar Shape Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'sr' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer d Shape Direction Direction Direction the shape is drawn as, mostly relevant when using trim path p Position Position Position or Scalar Outer Radius Outer Radius os Scalar Outer Roundness Outer Roundness as a percentage r Scalar Rotation Rotation, clockwise in degrees pt Scalar Points Points sy Star Type Star Type Star Type ir Scalar Inner Radius Inner Radius is Scalar Inner Roundness Inner Roundness as a percentage Example Position x 256 Position y 256 Points 5 Rotation 0 Outer Radius 200 Inner Radius 100 Outer Roundness 0 Inner Roundness 0 Star Type Star Polygon var lottie_player_54 = new PlaygroundPlayer( 54, 'playground_54_10', 'lottie_target_54', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [{\"ty\": 4, \"ddd\": 0, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ip\": 0, \"op\": 180, \"ind\": 0, \"st\": 0, \"sr\": 1, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.979995422293431, 0.28000305180437934]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var star = { \"ty\": \"sr\", \"nm\": \"PolyStar\", \"sy\": Number(data[\"Star Type\"]), \"p\": { \"a\": 0, \"k\": [data[\"Position x\"], data[\"Position y\"]] }, \"r\": { \"a\": 0, \"k\": data[\"Rotation\"] }, \"pt\": { \"a\": 0, \"k\": data[\"Points\"] }, \"or\": { \"a\": 0, \"k\": data[\"Outer Radius\"] }, \"os\": { \"a\": 0, \"k\": data[\"Outer Roundness\"] }, }; if ( data[\"Star Type\"] == \"1\" ) { star = { ...star, \"ir\": { \"a\": 0, \"k\": data[\"Inner Radius\"] }, \"is\": { \"a\": 0, \"k\": data[\"Inner Roundness\"] }, }; } lottie.layers[0].shapes[0].it[0] = star; this.json_viewer_contents = lottie.layers[0].shapes[0].it[0]; }, {} );","title":"PolyStar"},{"location":"shapes/#path","text":"Custom Bezier shape Composition Diagram for Path Path Shape Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'sh' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer d Shape Direction Direction Direction the shape is drawn as, mostly relevant when using trim path ks Bezier Shape Bezier path Example Shape var lottie_player_55 = new PlaygroundPlayer( 55, 'playground_55_2', 'lottie_target_55', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Group\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Shape\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [], \"i\": [], \"o\": []}}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { var shape = lottie.layers[0].shapes[0].it[0]; if ( data[\"Shape\"] ) shape.ks.k = data[\"Shape\"]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[0]; }, {} ); var playground_55_1_playground = document.getElementById(\"playground_55_1_playground\"); playground_55_1_playground.name = playground_55_1_playground.getAttribute(\"name\"); var playground_55_1_playground_editor = BezierPreviewEditor.stand_alone( playground_55_1_playground, (lottie) => { playground_55_1_playground.value = lottie; lottie_player_55.reload(); }, null, 512, 512 );","title":"Path"},{"location":"shapes/#shape-style","text":"These apply a style (such as fill stroke) to the paths defined by the shapes . Each style is applied to all preceding shapes in the same group / layer. In most formats the style is usually defined as a property of a shape, in lottie they are separate and allows for more flexibility. Some examples of the added flexibility would be a shape with multiple strokes, or a gradient fading into a solid color. Composition Diagram for Shape Style Shape Style Graphic Element Visual Object Gradient Stroke Stroke No Style Gradient Fill Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer o Scalar Opacity Opacity, 100 means fully opaque","title":"Style"},{"location":"shapes/#fill","text":"Solid fill color Composition Diagram for Fill Fill Shape Style Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'fl' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer o Scalar Opacity Opacity, 100 means fully opaque c Color Color Color r Fill Rule Fill Rule Fill Rule Example Red 1 Green 0.98 Blue 0.28 Opacity 100 Fill Rule Non Zero Even Odd var lottie_player_56 = new PlaygroundPlayer( 56, 'playground_56_6', 'lottie_target_56', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{f5d94f54-bb8f-4f07-be45-232ebd4b9eb1}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{4b0993ed-e35b-48a5-ab12-687dbc147c7c}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Path\", \"mn\": \"{29196ff2-0a65-48b4-a450-f9fbc3a3640d}\", \"it\": [{\"ty\": \"sh\", \"nm\": \"Path\", \"mn\": \"{bb7e6c60-755e-4a21-a7ba-bd054feab5c7}\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [[125.51641791044776, 452.20298507462684], [240.71641791044777, 38.6865671641791], [435.8686567164179, 447.9044776119403], [42.125373134328356, 173.65970149253732], [460.8, 156.46567164179103]], \"i\": [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]], \"o\": [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]]}}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{3af40b83-15f6-4f69-aa2a-96acd03eb3b6}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.98, 0.28]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [251.46268656716418, 245.4447761194029]}, \"p\": {\"a\": 0, \"k\": [251.46268656716418, 245.4447761194029]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var shape = lottie.layers[0].shapes[0].it[1]; shape.c.k = [data[\"Red\"], data[\"Green\"], data[\"Blue\"]]; shape.o.k = data[\"Opacity\"]; shape.r = Number(data[\"Fill Rule\"]); this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; }, {} );","title":"Fill"},{"location":"shapes/#stroke","text":"Solid stroke Composition Diagram for Stroke Stroke Shape Style Base Stroke Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'st' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer o Scalar Opacity Opacity, 100 means fully opaque lc Line Cap Line Cap Line Cap lj Line Join Line Join Line Join ml number Miter Limit Miter Limit ml2 Scalar Miter Limit Animatable alternative to ml w Scalar Width Stroke width d array of Stroke Dash Dashes Dashed line definition c Color Color Stroke color Example Red 1 Green 0.98 Blue 0.28 Width 32 Opacity 100 Line Cap Butt Round Square Line Join Miter Round Bevel Miter Limit 3 var lottie_player_57 = new PlaygroundPlayer( 57, 'playground_57_9', 'lottie_target_57', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"tm\", \"nm\": \"Trim Path\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"s\": {\"a\": 0, \"k\": 0}, \"e\": {\"a\": 0, \"k\": 100}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.98, 0.28]}, \"lc\": 2, \"lj\": 2, \"ml\": 3, \"w\": {\"a\": 0, \"k\": 20}, \"d\": [{\"n\": \"o\", \"nm\": \"offset\", \"v\": {\"a\": 0, \"k\": 0}}, {\"n\": \"d\", \"nm\": \"dash\", \"v\": {\"a\": 0, \"k\": 100}}, {\"n\": \"g\", \"nm\": \"gap\", \"v\": {\"a\": 0, \"k\": 0}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var shape = lottie.layers[0].shapes[2]; shape.c.k = [data[\"Red\"], data[\"Green\"], data[\"Blue\"]]; shape.o.k = data[\"Opacity\"]; shape.w.k = data[\"Width\"]; shape.lc = Number(data[\"Line Cap\"]); shape.lj = Number(data[\"Line Join\"]); shape.ml = data[\"Miter Limit\"]; shape.d = undefined; this.json_viewer_contents = lottie.layers[0].shapes[2]; }, {} );","title":"Stroke"},{"location":"shapes/#stroke-dash","text":"An item used to described the dash pattern in a stroked path A stroke dash array consists of n dash entries, [n-1,n] gap entries and [0-1] offset entries. Dash and gap entries MUST all be in a continuous order and alternate between dash and gap, starting with dash. If there are an odd number of dashes + gaps, the sequence will repeat with dashes and gaps reversed. For example a sequence of [4d, 8g, 16d] MUST be rendered as [4d, 8g, 16d, 4g, 8d, 16g] . Offset entry, if present, MUST be at the end of the array. Composition Diagram for Stroke Dash Stroke Dash Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions n Stroke Dash Type Dash Type Dash Type v Scalar Length Length of the dash Example Red 1 Green 0.98 Blue 0.28 Width 32 Opacity 100 Line Cap Butt Round Square Line Join Miter Round Bevel Miter Limit 3 Dash Offset 0 Dash Length 30 Dash Gap 50 var lottie_player_58 = new PlaygroundPlayer( 58, 'playground_58_12', 'lottie_target_58', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"tm\", \"nm\": \"Trim Path\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"s\": {\"a\": 0, \"k\": 0}, \"e\": {\"a\": 0, \"k\": 100}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.98, 0.28]}, \"lc\": 2, \"lj\": 2, \"ml\": 3, \"w\": {\"a\": 0, \"k\": 20}, \"d\": [{\"n\": \"o\", \"nm\": \"offset\", \"v\": {\"a\": 0, \"k\": 0}}, {\"n\": \"d\", \"nm\": \"dash\", \"v\": {\"a\": 0, \"k\": 100}}, {\"n\": \"g\", \"nm\": \"gap\", \"v\": {\"a\": 0, \"k\": 0}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var shape = lottie.layers[0].shapes[2]; shape.c.k = [data[\"Red\"], data[\"Green\"], data[\"Blue\"]]; shape.o.k = data[\"Opacity\"]; shape.w.k = data[\"Width\"]; shape.lc = Number(data[\"Line Cap\"]); shape.lj = Number(data[\"Line Join\"]); shape.ml = data[\"Miter Limit\"]; shape.d[0].v.k = data[\"Dash Offset\"]; shape.d[1].v.k = data[\"Dash Length\"]; shape.d[2].v.k = data[\"Dash Gap\"]; var trim = lottie.layers[0].shapes[1]; trim.e.k = 100; trim.o.k = 0; this.json_viewer_contents = lottie.layers[0].shapes[2]; }, {} );","title":"Stroke Dashes"},{"location":"shapes/#base-gradient","text":"Common properties for gradients Composition Diagram for Base Gradient Base Gradient Gradient Stroke Gradient Attribute Type Title Description g Gradient Colors Gradient colors s Position Start Point Starting point for the gradient e Position End Point End point for the gradient t Gradient Type Gradient Type Type of the gradient h Scalar Highlight Length Highlight Length, as a percentage between s and e a Scalar Highlight Angle Highlight Angle in clockwise degrees, relative to the direction from s to e","title":"Base Gradient"},{"location":"shapes/#gradient-fill","text":"Gradient fill color Composition Diagram for Gradient Gradient Shape Style Base Gradient Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'gf' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer o Scalar Opacity Opacity, 100 means fully opaque g Gradient Colors Gradient colors s Position Start Point Starting point for the gradient e Position End Point End point for the gradient t Gradient Type Gradient Type Type of the gradient h Scalar Highlight Length Highlight Length, as a percentage between s and e a Scalar Highlight Angle Highlight Angle in clockwise degrees, relative to the direction from s to e r Fill Rule Fill Rule Fill Rule Example Start X 256 Start Y 496 End X 256 End Y 16 Type Linear Radial Highlight 0 Highlight Angle 0 var lottie_player_59 = new PlaygroundPlayer( 59, 'playground_59_8', 'lottie_target_59', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{3da63a46-0ec5-45b8-90fb-d31c5614d5be}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 1, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer 2\", \"mn\": \"{04a8ef87-75fd-451c-868b-7413969c8ad9}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"e\", \"mn\": \"{078a0bf7-08ce-49f7-9dca-c473ad9ff09d}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"e\", \"mn\": \"{efb1ff36-fe2b-4939-97a5-d75a167d003b}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"e\", \"mn\": \"{759da60a-0439-496c-89a9-66e1d721ceb7}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"\", \"mn\": \"{b56ba91b-5ef9-40d2-a1da-27265d105c7a}\", \"it\": [{\"ty\": \"sh\", \"nm\": \"\", \"mn\": \"{020e377d-646e-45f6-830f-756cfff57aa9}\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [[3.7994567051676293, -7.097994637365934], [5.33994951436286, -6.707992504500113], [6.327946284594615, -5.609490432573314], [6.672442201680043, -3.952002315682892], [6.672442201680043, -3.262995246756169], [1.901449879997, -3.262995246756169], [2.505949758118953, -1.4624984765244131], [4.124444517362934, -0.8449957342683567], [5.300948539338484, -0.968496282719568], [6.360449636240906, -1.326002681317033], [6.360449636240906, -0.32500304695117377], [5.307446162716568, 0.019500487512187806], [4.072448295582389, 0.12999817182929574], [2.3239477471311782, -0.2729992077926948], [1.1409537191554788, -1.4755013406585165], [0.7184558520213006, -3.4319943936098403], [1.1019527441311032, -5.395000304695118], [2.1809543285457136, -6.655996282719569], [3.7994567051676293, -7.097994637365934]], \"i\": [[0, 0], [-0.4290005687642191, -0.2600014219105473], [-0.22966394472361795, -0.4723332927073187], [0, -0.6326587852196304], [0, 0], [0, 0], [-0.3856627665691641, -0.411668494837371], [-0.69333373959349, 0], [-0.34233512087802254, 0.08233369896747422], [-0.3639989437235931, 0.15600390009750242], [0, 0], [0.34666686979674477, -0.07366512287807196], [0.47666504162604095, 0], [0.506997440561014, 0.2686649197479937], [0.281665244756119, 0.5330031688292207], [0, 0.7713255331383286], [-0.25566459473986836, 0.5459984155853892], [-0.4636697948698716, 0.29466556976424485], [-0.6153317895447388, 0]], \"o\": [[0.5979946373659342, 0], [0.4290005687642182, 0.2600014219105473], [0.22966394472361795, 0.47233329270731783], [0, 0], [0, 0], [0.017337152178804383, 0.7886626853171328], [0.3856627665691641, 0.411668494837371], [0.4420008937723443, 0], [0.34233512087802165, -0.08233369896747411], [0, 0], [-0.35533544588614685, 0.15600390009750242], [-0.34666686979674477, 0.07366512287807195], [-0.6586695917397929, 0], [-0.5069974405610138, -0.26866491974799367], [-0.28166524475611887, -0.5330031688292207], [0, -0.7626721918047954], [0.2556645947398686, -0.5459984155853901], [0.46366979486987203, -0.29466556976424396], [0, 0]]}}}, {\"ty\": \"sh\", \"nm\": \"\", \"mn\": \"{b3f5759c-30aa-4352-a4ea-23b71ead28ad}\", \"ks\": {\"a\": 0, \"k\": {\"c\": false, \"v\": [[3.7864462236555916, -6.162001706292657], [2.4929545113627842, -5.635496160841521], [1.9274556082652068, -4.172997684317108], [5.476452926948174, -4.172997684317108], [5.06045268319208, -5.609498049951249], [3.7864462236555916, -6.162001706292657]], \"i\": [[0, 0], [0.3163344708617717, -0.3510036969674246], [0.06066479786994661, -0.6239952873821846], [0, 0], [0.2686699979999494, 0.36833577089427205], [0.5806676416910426, 0]], \"o\": [[-0.5459933373334334, 0], [-0.3163344708617717, 0.3510036969674246], [0, 0], [-0.008663497837446243, -0.5893311395284879], [-0.2686699979999503, -0.36833577089427205], [0, 0]]}}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"fl\", \"nm\": \"Fill 1\", \"mn\": \"{2fcb588a-7de7-4cba-8508-46952f160940}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [-2.7166567164177735, 3.822454790113566]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [256, 16]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"s\", \"mn\": \"{e16b0057-203a-4dab-8e5b-495775987f85}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"s\", \"mn\": \"{07bcfe04-40c2-4636-807c-d64982f7a44d}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"s\", \"mn\": \"{0de90988-3e53-4e7a-8a7d-cb147d0c42b5}\", \"it\": [{\"ty\": \"sh\", \"nm\": \"\", \"mn\": \"{22460e65-f67b-48b8-844b-e361867d003b}\", \"ks\": {\"a\": 0, \"k\": {\"c\": false, \"v\": [[5.645452073801845, -1.923997318682967], [4.891453536338409, -0.39000213286582164], [2.8634485393384836, 0.12999817182929574], [1.608957802070052, 0.013002864134103353], [0.679454876996925, -0.311992565439136], [0.679454876996925, -1.3519931748293708], [1.6869521347408687, -0.968496282719568], [2.8894542676066903, -0.7929995124878122], [4.150450245631141, -1.0724963436585915], [4.540444761119028, -1.820004875121878], [4.3974513425335635, -2.2880013406585165], [3.8839562785944652, -2.7040015844146104], [2.824447564314108, -3.171998049951249], [1.6674516472286809, -3.6919983546463664], [0.9264559738993475, -4.315998720280507], [0.666459630240756, -5.251999268731718], [1.3879548160579016, -6.616995307695193], [3.2794487830945775, -7.097994637365934], [4.468948051826296, -6.9744940889147236], [5.502443420460512, -6.629998171829296], [5.1124489049726245, -5.719995734268357], [4.189443603277582, -6.031995917085427], [3.2014468330458263, -6.162001706292657], [2.128950489387235, -5.934501096902423], [1.7584564614115354, -5.316990737268432], [1.9274556082652068, -4.82950140159754], [2.4929545113627842, -4.439499268731718], [3.552455608265207, -3.9910032907072677], [4.683453414460362, -3.4839982327683194], [5.398450976899423, -2.853500243756094], [5.645452073801845, -1.923997318682967]], \"i\": [[0, 0], [0.5026656916422914, -0.346666869796745], [0.8493376396909924, 0], [0.35099861871546767, 0.07799687179679493], [0.26866999799995006, 0.13866674791869799], [0, 0], [-0.3943313426585666, -0.11699784682117054], [-0.4073367459186481, 0], [-0.2599963436585919, 0.18633122078051945], [0, 0.31200780019500485], [0.09532894572364281, 0.13866674791869782], [0.2470010969024221, 0.13866674791869782], [0.45933804595114847, 0.17333089577239447], [0.32066621978049437, 0.17333597402435075], [0.17333089577239413, 0.24266426973174227], [0, 0.38133609590239725], [-0.48099679054476374, 0.32066621978049437], [-0.779999187479687, 0], [-0.36833577089427294, -0.08233369896747345], [-0.32066114152853853, -0.14733024575614362], [0, 0], [0.32066621978049437, 0.08667052613815329], [0.3379982937073427, 0], [0.24699601865046583, -0.15166707292682258], [0, -0.2600065001625049], [-0.11266609790244764, -0.13433499899997603], [-0.26433317082927044, -0.12566642291057306], [-0.4420008937723443, -0.17333089577239447], [-0.3119976436910923, -0.1733359740243503], [-0.16466739793494867, -0.24699601865046628], [0, -0.3726725980649519]], \"o\": [[0, 0.6759965874146854], [-0.5026656916422914, 0.3466668697967449], [-0.4853285394634863, 0], [-0.3509986187154679, -0.07799687179679493], [0, 0], [0.27733349583739597, 0.13866674791869804], [0.3943313426585664, 0.11699784682117043], [0.5806676416910421, 0], [0.2599963436585915, -0.18633122078051967], [0, -0.17333089577239424], [-0.09532894572364281, -0.13866674791869826], [-0.24700109690242256, -0.13866674791869826], [-0.45066439160979055, -0.17333089577239447], [-0.3206662197804946, -0.1733359740243503], [-0.17333089577239436, -0.24266426973174315], [0, -0.5893311395284879], [0.4809967905447634, -0.3206662197804935], [0.4246637415935397, 0], [0.36833577089427205, 0.08233369896747433], [0, 0], [-0.2946706480162007, -0.12132959573989321], [-0.3206662197804948, -0.08667052613815329], [-0.4680015437885947, 0], [-0.2469960186504665, 0.15166707292682347], [0, 0.1906578914472865], [0.11266609790244786, 0.13433499899997514], [0.26433317082927044, 0.12566642291057306], [0.44200089377234475, 0.16466739793494822], [0.3119976436910914, 0.17333597402435075], [0.16466739793494867, 0.24699601865046583], [0, 0]]}}}, {\"ty\": \"fl\", \"nm\": \"Fill 1\", \"mn\": \"{2fcb588a-7de7-4cba-8508-46952f160940}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [-2.7166567164177735, 3.822454790113566]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [256, 496]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}, {\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{a5276bb6-4d7c-4b4f-b371-a0e14a279176}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"Gradient\", \"mn\": \"{9df3ba96-24a3-412e-abd4-e64e2e76e6df}\", \"it\": [{\"ty\": \"rc\", \"nm\": \"Rectangle\", \"mn\": \"{20934ad0-1c22-4752-a5b1-be99889ea79a}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [512, 512]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"gf\", \"nm\": \"Gradient Fill\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"s\": {\"a\": 0, \"k\": [256, 496]}, \"e\": {\"a\": 0, \"k\": [256, 16]}, \"t\": 1, \"h\": {\"a\": 0, \"k\": 0}, \"a\": {\"a\": 0, \"k\": 0}, \"g\": {\"p\": 3, \"k\": {\"a\": 0, \"k\": [0, 0.7686274509803922, 0.8509803921568627, 0.9607843137254902, 0.5, 0.19600213626306554, 0.31400015259021896, 0.6899977111467155, 1, 0.16099794003204396, 0.18399328603036547, 0.45900663767452504, 0, 1, 0.5, 1, 1, 1]}}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [257.4805970149254, 255.76119402985074]}, \"p\": {\"a\": 0, \"k\": [257.4805970149254, 255.76119402985074]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var gradient = lottie.layers[1].shapes[0].it[1]; var start_marker = lottie.layers[0].shapes[1].it[1]; var end_marker = lottie.layers[0].shapes[0].it[1]; gradient.s.k = start_marker.p.k = [data[\"Start X\"], data[\"Start Y\"]]; gradient.e.k = end_marker.p.k = [data[\"End X\"], data[\"End Y\"]]; gradient.t = Number(data[\"Type\"]); if (gradient.t === 2) { gradient.h = { a: 0, k: data[\"Highlight\"] }; gradient.a = { a: 0, k: data[\"Highlight Angle\"] }; } else { delete gradient.h; delete gradient.a; } this.json_viewer_contents = lottie.layers[1].shapes[0].it[1]; }, {} );","title":"Gradient Fill"},{"location":"shapes/#gradient-stroke","text":"Gradient stroke Composition Diagram for Gradient Stroke Gradient Stroke Shape Style Base Stroke Base Gradient Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'gs' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer o Scalar Opacity Opacity, 100 means fully opaque lc Line Cap Line Cap Line Cap lj Line Join Line Join Line Join ml number Miter Limit Miter Limit ml2 Scalar Miter Limit Animatable alternative to ml w Scalar Width Stroke width d array of Stroke Dash Dashes Dashed line definition g Gradient Colors Gradient colors s Position Start Point Starting point for the gradient e Position End Point End point for the gradient t Gradient Type Gradient Type Type of the gradient h Scalar Highlight Length Highlight Length, as a percentage between s and e a Scalar Highlight Angle Highlight Angle in clockwise degrees, relative to the direction from s to e Example Start X 256 Start Y 496 End X 256 End Y 16 Type Linear Radial Highlight 0 Highlight Angle 0 var lottie_player_60 = new PlaygroundPlayer( 60, 'playground_60_8', 'lottie_target_60', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 1, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Start/End markers\", \"mn\": \"{04a8ef87-75fd-451c-868b-7413969c8ad9}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"e\", \"mn\": \"{078a0bf7-08ce-49f7-9dca-c473ad9ff09d}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"e\", \"mn\": \"{efb1ff36-fe2b-4939-97a5-d75a167d003b}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"e\", \"mn\": \"{759da60a-0439-496c-89a9-66e1d721ceb7}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"\", \"mn\": \"{b56ba91b-5ef9-40d2-a1da-27265d105c7a}\", \"it\": [{\"ty\": \"sh\", \"nm\": \"\", \"mn\": \"{020e377d-646e-45f6-830f-756cfff57aa9}\", \"ks\": {\"a\": 0, \"k\": {\"c\": true, \"v\": [[3.7994567051676293, -7.097994637365934], [5.33994951436286, -6.707992504500113], [6.327946284594615, -5.609490432573314], [6.672442201680043, -3.952002315682892], [6.672442201680043, -3.262995246756169], [1.901449879997, -3.262995246756169], [2.505949758118953, -1.4624984765244131], [4.124444517362934, -0.8449957342683567], [5.300948539338484, -0.968496282719568], [6.360449636240906, -1.326002681317033], [6.360449636240906, -0.32500304695117377], [5.307446162716568, 0.019500487512187806], [4.072448295582389, 0.12999817182929574], [2.3239477471311782, -0.2729992077926948], [1.1409537191554788, -1.4755013406585165], [0.7184558520213006, -3.4319943936098403], [1.1019527441311032, -5.395000304695118], [2.1809543285457136, -6.655996282719569], [3.7994567051676293, -7.097994637365934]], \"i\": [[0, 0], [-0.4290005687642191, -0.2600014219105473], [-0.22966394472361795, -0.4723332927073187], [0, -0.6326587852196304], [0, 0], [0, 0], [-0.3856627665691641, -0.411668494837371], [-0.69333373959349, 0], [-0.34233512087802254, 0.08233369896747422], [-0.3639989437235931, 0.15600390009750242], [0, 0], [0.34666686979674477, -0.07366512287807196], [0.47666504162604095, 0], [0.506997440561014, 0.2686649197479937], [0.281665244756119, 0.5330031688292207], [0, 0.7713255331383286], [-0.25566459473986836, 0.5459984155853892], [-0.4636697948698716, 0.29466556976424485], [-0.6153317895447388, 0]], \"o\": [[0.5979946373659342, 0], [0.4290005687642182, 0.2600014219105473], [0.22966394472361795, 0.47233329270731783], [0, 0], [0, 0], [0.017337152178804383, 0.7886626853171328], [0.3856627665691641, 0.411668494837371], [0.4420008937723443, 0], [0.34233512087802165, -0.08233369896747411], [0, 0], [-0.35533544588614685, 0.15600390009750242], [-0.34666686979674477, 0.07366512287807195], [-0.6586695917397929, 0], [-0.5069974405610138, -0.26866491974799367], [-0.28166524475611887, -0.5330031688292207], [0, -0.7626721918047954], [0.2556645947398686, -0.5459984155853901], [0.46366979486987203, -0.29466556976424396], [0, 0]]}}}, {\"ty\": \"sh\", \"nm\": \"\", \"mn\": \"{b3f5759c-30aa-4352-a4ea-23b71ead28ad}\", \"ks\": {\"a\": 0, \"k\": {\"c\": false, \"v\": [[3.7864462236555916, -6.162001706292657], [2.4929545113627842, -5.635496160841521], [1.9274556082652068, -4.172997684317108], [5.476452926948174, -4.172997684317108], [5.06045268319208, -5.609498049951249], [3.7864462236555916, -6.162001706292657]], \"i\": [[0, 0], [0.3163344708617717, -0.3510036969674246], [0.06066479786994661, -0.6239952873821846], [0, 0], [0.2686699979999494, 0.36833577089427205], [0.5806676416910426, 0]], \"o\": [[-0.5459933373334334, 0], [-0.3163344708617717, 0.3510036969674246], [0, 0], [-0.008663497837446243, -0.5893311395284879], [-0.2686699979999503, -0.36833577089427205], [0, 0]]}}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"fl\", \"nm\": \"Fill 1\", \"mn\": \"{2fcb588a-7de7-4cba-8508-46952f160940}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [-2.7166567164177735, 3.822454790113566]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [256, 16]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"gr\", \"nm\": \"s\", \"mn\": \"{e16b0057-203a-4dab-8e5b-495775987f85}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"s\", \"mn\": \"{07bcfe04-40c2-4636-807c-d64982f7a44d}\", \"it\": [{\"ty\": \"gr\", \"nm\": \"s\", \"mn\": \"{0de90988-3e53-4e7a-8a7d-cb147d0c42b5}\", \"it\": [{\"ty\": \"sh\", \"nm\": \"\", \"mn\": \"{22460e65-f67b-48b8-844b-e361867d003b}\", \"ks\": {\"a\": 0, \"k\": {\"c\": false, \"v\": [[5.645452073801845, -1.923997318682967], [4.891453536338409, -0.39000213286582164], [2.8634485393384836, 0.12999817182929574], [1.608957802070052, 0.013002864134103353], [0.679454876996925, -0.311992565439136], [0.679454876996925, -1.3519931748293708], [1.6869521347408687, -0.968496282719568], [2.8894542676066903, -0.7929995124878122], [4.150450245631141, -1.0724963436585915], [4.540444761119028, -1.820004875121878], [4.3974513425335635, -2.2880013406585165], [3.8839562785944652, -2.7040015844146104], [2.824447564314108, -3.171998049951249], [1.6674516472286809, -3.6919983546463664], [0.9264559738993475, -4.315998720280507], [0.666459630240756, -5.251999268731718], [1.3879548160579016, -6.616995307695193], [3.2794487830945775, -7.097994637365934], [4.468948051826296, -6.9744940889147236], [5.502443420460512, -6.629998171829296], [5.1124489049726245, -5.719995734268357], [4.189443603277582, -6.031995917085427], [3.2014468330458263, -6.162001706292657], [2.128950489387235, -5.934501096902423], [1.7584564614115354, -5.316990737268432], [1.9274556082652068, -4.82950140159754], [2.4929545113627842, -4.439499268731718], [3.552455608265207, -3.9910032907072677], [4.683453414460362, -3.4839982327683194], [5.398450976899423, -2.853500243756094], [5.645452073801845, -1.923997318682967]], \"i\": [[0, 0], [0.5026656916422914, -0.346666869796745], [0.8493376396909924, 0], [0.35099861871546767, 0.07799687179679493], [0.26866999799995006, 0.13866674791869799], [0, 0], [-0.3943313426585666, -0.11699784682117054], [-0.4073367459186481, 0], [-0.2599963436585919, 0.18633122078051945], [0, 0.31200780019500485], [0.09532894572364281, 0.13866674791869782], [0.2470010969024221, 0.13866674791869782], [0.45933804595114847, 0.17333089577239447], [0.32066621978049437, 0.17333597402435075], [0.17333089577239413, 0.24266426973174227], [0, 0.38133609590239725], [-0.48099679054476374, 0.32066621978049437], [-0.779999187479687, 0], [-0.36833577089427294, -0.08233369896747345], [-0.32066114152853853, -0.14733024575614362], [0, 0], [0.32066621978049437, 0.08667052613815329], [0.3379982937073427, 0], [0.24699601865046583, -0.15166707292682258], [0, -0.2600065001625049], [-0.11266609790244764, -0.13433499899997603], [-0.26433317082927044, -0.12566642291057306], [-0.4420008937723443, -0.17333089577239447], [-0.3119976436910923, -0.1733359740243503], [-0.16466739793494867, -0.24699601865046628], [0, -0.3726725980649519]], \"o\": [[0, 0.6759965874146854], [-0.5026656916422914, 0.3466668697967449], [-0.4853285394634863, 0], [-0.3509986187154679, -0.07799687179679493], [0, 0], [0.27733349583739597, 0.13866674791869804], [0.3943313426585664, 0.11699784682117043], [0.5806676416910421, 0], [0.2599963436585915, -0.18633122078051967], [0, -0.17333089577239424], [-0.09532894572364281, -0.13866674791869826], [-0.24700109690242256, -0.13866674791869826], [-0.45066439160979055, -0.17333089577239447], [-0.3206662197804946, -0.1733359740243503], [-0.17333089577239436, -0.24266426973174315], [0, -0.5893311395284879], [0.4809967905447634, -0.3206662197804935], [0.4246637415935397, 0], [0.36833577089427205, 0.08233369896747433], [0, 0], [-0.2946706480162007, -0.12132959573989321], [-0.3206662197804948, -0.08667052613815329], [-0.4680015437885947, 0], [-0.2469960186504665, 0.15166707292682347], [0, 0.1906578914472865], [0.11266609790244786, 0.13433499899997514], [0.26433317082927044, 0.12566642291057306], [0.44200089377234475, 0.16466739793494822], [0.3119976436910914, 0.17333597402435075], [0.16466739793494867, 0.24699601865046583], [0, 0]]}}}, {\"ty\": \"fl\", \"nm\": \"Fill 1\", \"mn\": \"{2fcb588a-7de7-4cba-8508-46952f160940}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.9411764705882353, 0.11372549019607843, 0.0392156862745098]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [0, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [-2.7166567164177735, 3.822454790113566]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [0, 0]}, \"p\": {\"a\": 0, \"k\": [256, 496]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}, {\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"or\": {\"a\": 0, \"k\": 200}, \"ir\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"gs\", \"nm\": \"Stroke\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.98, 0.28]}, \"lc\": 2, \"lj\": 2, \"ml\": 3, \"w\": {\"a\": 0, \"k\": 30}, \"d\": [{\"n\": \"d\", \"nm\": \"dash\", \"v\": {\"a\": 0, \"k\": 100}}, {\"n\": \"g\", \"nm\": \"gap\", \"v\": {\"a\": 0, \"k\": 0}}, {\"n\": \"o\", \"nm\": \"offset\", \"v\": {\"a\": 0, \"k\": 0}}], \"r\": 1, \"s\": {\"a\": 0, \"k\": [256, 496]}, \"e\": {\"a\": 0, \"k\": [256, 16]}, \"t\": 1, \"h\": {\"a\": 0, \"k\": 0}, \"a\": {\"a\": 0, \"k\": 0}, \"g\": {\"p\": 3, \"k\": {\"a\": 0, \"k\": [0, 0.7686274509803922, 0.8509803921568627, 0.9607843137254902, 0.5, 0.19600213626306554, 0.31400015259021896, 0.6899977111467155, 1, 0.16099794003204396, 0.18399328603036547, 0.45900663767452504, 0, 1, 0.5, 1, 1, 1]}}}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { var gradient = lottie.layers[1].shapes[1]; var start_marker = lottie.layers[0].shapes[1].it[1]; var end_marker = lottie.layers[0].shapes[0].it[1]; gradient.s.k = start_marker.p.k = [data[\"Start X\"], data[\"Start Y\"]]; gradient.e.k = end_marker.p.k = [data[\"End X\"], data[\"End Y\"]]; gradient.t = Number(data[\"Type\"]); if (gradient.t === 2) { gradient.h = { a: 0, k: data[\"Highlight\"] }; gradient.a = { a: 0, k: data[\"Highlight Angle\"] }; } else { delete gradient.h; delete gradient.a; } this.json_viewer_contents = lottie.layers[1].shapes[1]; }, {} );","title":"Gradient Stroke"},{"location":"shapes/#no-style","text":"Represents a style for shapes without fill or stroke. Composition Diagram for No Style No Style Shape Style Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'no' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer o Scalar Opacity Opacity, 100 means fully opaque","title":"No Style"},{"location":"shapes/#grouping","text":"","title":"Grouping"},{"location":"shapes/#group","text":"A group is a shape that can contain other shapes (including other groups). The usual contents of a group are: Shapes Style Transform For example, if you want to have a red rectangle with a black outline, its group will contain A Rectangle defining the actual shape of the rectangle A Fill for the color red A Stroke for the black outline A Transform for the group transform While the contents may vary, a group must always end with a Transform shape . The attributes of a Group are: Composition Diagram for Group Group Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'gr' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer np number Number Of Properties Number Of Properties it array of Graphic Element Shapes Shapes cix integer Property index Index used in expressions","title":"Group"},{"location":"shapes/#transform","text":"Basically the same as Transform but with the ty attribute. Composition Diagram for Transform Shape Transform Shape Graphic Element Transform Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'tr' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer a Position Anchor Point Anchor point: a position (relative to its parent) around which transformations are applied (ie: center for rotation / scale) p Splittable Position Position Position / Translation r Scalar Rotation Rotation in degrees, clockwise s Vector Scale Scale factor, [100, 100] for no scaling o Scalar Opacity Opacity sk Scalar Skew Skew amount as an angle in degrees sa Scalar Skew Axis Direction along which skew is applied, in degrees ( 0 skews along the X axis, 90 along the Y axis) rx Scalar X Rotation Split rotation component ry Scalar Y Rotation Split rotation component rz Scalar Z Rotation Split rotation component, equivalent to r when not split or Vector Orientation Orientation Transform shapes MUST always be present in the group and they MUST be the last item in the it array.","title":"Transform"},{"location":"shapes/#modifier","text":"Modifiers process their siblings and alter the path defined by shapes .","title":"Modifiers"},{"location":"shapes/#repeater","text":"This is a bit different compared from other modifiers, since it will take into account style as well. The effect of a Repeater is to duplicate the other shapes a number of times applying a transform for each copy. Composition Diagram for Repeater Repeater Modifier Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'rp' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer c Scalar Copies Number of copies o Scalar Offset Offset m Composite Composite Stacking order tr Repeater Transform Transform Transform applied to each copy The transform is multiplied by o + 1 (where o is the Offset property above). So if o is 0 , the first instance shown by the Repeater is at its starting location. If it's 1 , the first instance has the matrix applied to it. Other values multiply the initial transform accordingly.","title":"Repeater"},{"location":"shapes/#repeater-transform","text":"Same as a regular Transform but instead of a single opacity value ( o ), it has two: Composition Diagram for Repeater Transform Repeater Transform Transform Attribute Type Title Description a Position Anchor Point Anchor point: a position (relative to its parent) around which transformations are applied (ie: center for rotation / scale) p Splittable Position Position Position / Translation r Scalar Rotation Rotation in degrees, clockwise s Vector Scale Scale factor, [100, 100] for no scaling o Scalar Opacity Opacity sk Scalar Skew Skew amount as an angle in degrees sa Scalar Skew Axis Direction along which skew is applied, in degrees ( 0 skews along the X axis, 90 along the Y axis) rx Scalar X Rotation Split rotation component ry Scalar Y Rotation Split rotation component rz Scalar Z Rotation Split rotation component, equivalent to r when not split or Vector Orientation Orientation so Scalar Start Opacity Opacity of the first repeated object. eo Scalar End Opacity Opacity of the last repeated object. Attribute Type Description so Animated number Start Opacity eo Animated number End Opacity The first copy will use so , the last eo , and copies between them will have an interpolated value. Copies 4 Start Opacity 100 End Opacity 50 Position x 130 Position y 0 Rotation 137 Offset 0 Composite Below Above var lottie_player_61 = new PlaygroundPlayer( 61, 'playground_61_9', 'lottie_target_61', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{33a02914-c5a9-4c4e-a0bd-0ec07f05b204}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{9eb62fdc-6d5b-4771-94c0-ebdafbd7a54e}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{bfbf6254-ff78-4d00-9d09-eafe4e34b732}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{5a453691-6b60-4bd3-bc43-e28b7a0ebc48}\", \"p\": {\"a\": 0, \"k\": [80, 120]}, \"or\": {\"a\": 0, \"k\": 80}, \"ir\": {\"a\": 0, \"k\": 40}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{b0ba4cf0-3a1b-45a3-8912-d0ed2bdd2082}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.5, 1]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 1}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{0c2313ae-ccff-4e71-9e00-81649390d850}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"rp\", \"nm\": \"Repeater\", \"mn\": \"{a9e13270-7dd8-4520-b5a1-c1c9cf96286b}\", \"c\": {\"a\": 0, \"k\": 4}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1, \"tr\": {\"a\": {\"a\": 0, \"k\": [80, 120]}, \"p\": {\"a\": 0, \"k\": [130, 0]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 137.508}, \"so\": {\"a\": 0, \"k\": 100}, \"eo\": {\"a\": 0, \"k\": 50}}}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [65.33731343283583, 117.77910447761194]}, \"p\": {\"a\": 0, \"k\": [73.93432835820896, 93.70746268656717]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[0].shapes[0].it[3].c.k = data[\"Copies\"]; lottie.layers[0].shapes[0].it[3].tr.so.k = data[\"Start Opacity\"]; lottie.layers[0].shapes[0].it[3].tr.eo.k = data[\"End Opacity\"]; lottie.layers[0].shapes[0].it[3].tr.p.k[0] = data[\"Position x\"]; lottie.layers[0].shapes[0].it[3].tr.p.k[1] = data[\"Position y\"]; lottie.layers[0].shapes[0].it[3].tr.r.k = data[\"Rotation\"]; lottie.layers[0].shapes[0].it[3].o.k = data[\"Offset\"]; lottie.layers[0].shapes[0].it[3].m = Number(data[\"Composite\"]); this.json_viewer_contents = lottie.layers[0].shapes[0].it[3]; }, {} );","title":"Repeater Transform"},{"location":"shapes/#trim-path","text":"This is mostly useful for shapes with a stroke and not a fill. It takes the path defined by shapes and only shows a segment of the resulting bezier data. Composition Diagram for Trim Path Trim Path Modifier Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'tm' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer s Scalar Start Segment start e Scalar End Segment end o Scalar Offset Offset m Trim Multiple Shapes Multiple How to treat multiple copies s and e go from 0 to 100 , 0 being at the beginning of the path and 100 at the end. The displayed segment is what lays between the two. o is an offset from the start, to allow values to wrap around. Its value goes from 0 (start of the path) to 360 (end of the path). It looks like an angle but it isn't really, the difference between o and s is that with o you can go over 360 or below 0 to shift the whole segment along the path. Here is an interactive example: Start 0 End 50 Offset 0 Multiple Shapes Parallel Sequential var lottie_player_62 = new PlaygroundPlayer( 62, 'playground_62_5', 'lottie_target_62', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [128, 128]}, \"or\": {\"a\": 0, \"k\": 100}, \"ir\": {\"a\": 0, \"k\": 50}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{74587b40-1ef1-445d-b9ab-02b8a42a96aa}\", \"p\": {\"a\": 0, \"k\": [384, 128]}, \"s\": {\"a\": 0, \"k\": [200, 200]}}, {\"ty\": \"rc\", \"nm\": \"Rect\", \"mn\": \"{0776f2df-2619-415c-b10d-f648f2edfa0f}\", \"d\": 1, \"p\": {\"a\": 0, \"k\": [128, 384]}, \"s\": {\"a\": 0, \"k\": [200, 200]}, \"r\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"sr\", \"nm\": \"Triangle\", \"mn\": \"{db373594-d0ae-44ff-9295-30ff72616af2}\", \"p\": {\"a\": 0, \"k\": [384, 384]}, \"or\": {\"a\": 0, \"k\": 100}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 3}, \"sy\": 2, \"os\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"tm\", \"nm\": \"Trim Path\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"s\": {\"a\": 0, \"k\": 0}, \"e\": {\"a\": 0, \"k\": 50}, \"o\": {\"a\": 0, \"k\": 0}, \"m\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 20}}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-32-gb62899be\"}}, function (lottie, data) { lottie.layers[0].shapes[4].s.k = data[\"Start\"]; lottie.layers[0].shapes[4].e.k = data[\"End\"]; lottie.layers[0].shapes[4].o.k = data[\"Offset\"]; lottie.layers[0].shapes[4].m = Number(data[\"Multiple Shapes\"]); this.json_viewer_contents = lottie.layers[0].shapes[4]; }, {} );","title":"Trim Path"},{"location":"shapes/#rounded-corners","text":"Rounds corners of other shapes Composition Diagram for Rounded Corners Rounded Corners Modifier Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'rd' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer r Scalar Radius Radius Radius 50 var lottie_player_63 = new PlaygroundPlayer( 63, 'playground_63_2', 'lottie_target_63', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 222.72242736816406}, \"ir\": {\"a\": 0, \"k\": 111.36121368408203}, \"r\": {\"a\": 0, \"k\": 358.67291259765625}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1, \"os\": {\"a\": 0, \"k\": 0}, \"is\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"rd\", \"nm\": \"Rounded Corners\", \"mn\": \"{dcd7570f-5105-485b-bd43-42ad990b01e8}\", \"r\": {\"a\": 0, \"k\": 50}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"hd\": true, \"nm\": \"Fill\", \"mn\": \"{a1bcc159-6916-4718-841d-a99140c0e74b}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[0].shapes[0].it[1].r.k = data[\"Radius\"]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; }, {} );","title":"Rounded Corners"},{"location":"shapes/#pucker-bloat","text":"Interpolates the shape with its center point and bezier tangents with the opposite direction Composition Diagram for Pucker Bloat Pucker Bloat Modifier Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'pb' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer a Scalar Amount Amount as a percentage When a is 0 , nothing changes. When a is positive, the vertices are pulled towards the center, with 100 being at the center. And the tangents are pushed away. When a is negative the vertices are pushed away from the center with 100 being twice far away from the center. And the tangents are pulled towards the center. The center is defined as the mean of the bezier vertices. Amount 50 var lottie_player_64 = new PlaygroundPlayer( 64, 'playground_64_2', 'lottie_target_64', {\"v\": \"5.5.7\", \"ip\": 0, \"op\": 180, \"nm\": \"Animation\", \"mn\": \"{8f1618e3-6f83-4531-8f65-07dd4b68ee2e}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 180, \"nm\": \"Layer\", \"mn\": \"{85f37d8b-1792-4a4f-82d2-1b3b6d829c07}\", \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}, \"shapes\": [{\"ty\": \"gr\", \"nm\": \"PolyStar\", \"mn\": \"{9199543e-3552-4e51-a802-623f2a4a2ca1}\", \"it\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{57cff206-c227-4a14-a679-195157be886b}\", \"p\": {\"a\": 0, \"k\": [256, 256]}, \"or\": {\"a\": 0, \"k\": 160}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 2, \"os\": {\"a\": 0, \"k\": 0}}, {\"ty\": \"pb\", \"nm\": \"Inflate and Deflate\", \"mn\": \"{b4af429a-546e-4728-a869-711a404c55ae}\", \"a\": {\"a\": 0, \"k\": 50}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{0930ce27-c8f9-4371-b0cf-111a859abfaf}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 30}}, {\"ty\": \"fl\", \"hd\": true, \"nm\": \"Fill\", \"mn\": \"{a1bcc159-6916-4718-841d-a99140c0e74b}\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}, \"r\": 1}, {\"ty\": \"tr\", \"a\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"p\": {\"a\": 0, \"k\": [249.3134328358209, 254.47164179104476]}, \"s\": {\"a\": 0, \"k\": [100, 100]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}}]}]}], \"meta\": {\"g\": \"Glaxnimate 0.4.6-26-g7b05e75c\"}}, function (lottie, data) { lottie.layers[0].shapes[0].it[1].a.k = data[\"Amount\"]; this.json_viewer_contents = lottie.layers[0].shapes[0].it[1]; }, {} );","title":"Pucker / Bloat"},{"location":"shapes/#twist","text":"Composition Diagram for Twist Twist Modifier Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'tw' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer a Scalar Angle Angle c Vector Center Center","title":"Twist"},{"location":"shapes/#merge","text":"Boolean operator on shapes Composition Diagram for Merge Merge Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'mm' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer mm Merge Mode Merge Mode Merge Mode","title":"Merge"},{"location":"shapes/#offset-path","text":"Interpolates the shape with its center point and bezier tangents with the opposite direction Composition Diagram for Offset Path Offset Path Modifier Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'op' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer a Scalar Amount Amount lj Line Join Line Join Line Join ml Scalar Miter Limit Miter Limit","title":"Offset Path"},{"location":"shapes/#zig-zag","text":"Changes the edges of affected shapes into a series of peaks and valleys of uniform size Composition Diagram for Zig Zag Zig Zag Modifier Graphic Element Visual Object Attribute Type Title Description nm string Name Human readable name, as seen from editors and the like mn string Match Name Match name, used in expressions hd boolean Hidden Whether the shape is hidden ty string = 'zz' Shape Type Shape Type bm Blend Mode Blend Mode Blend Mode ix integer Property index Index used in expressions cl string CSS Class CSS class used by the SVG renderer ln string Layer XML ID id attribute used by the SVG renderer r Scalar Frequency Number of ridges per segment s Scalar Amplitude Distance between peaks and troughs pt Scalar Point Type Point type (1 = corner, 2 = smooth)","title":"Zig Zag"},{"location":"text/","text":"Text Font List Fonts are defined in the animation object, under fonts . When fonts is present in the Animation object, it has a single attribute called list , which is an array of font objects: Attribute Type Title Description ascent number Ascent Text will be moved down based on this value fFamily string Font Family Font Family fName string Name Name used by text documents to reference this font, usually it's fFamily followed by fStyle fStyle string Font Style Font Style fPath string Path Path fWeight string Weight Weight origin Font Path Origin Origin Origin fClass string CSS Class CSS Class applied to text objects using this font To understand how to load fonts it's better to look at some examples so here follow various ways of adding a font into lottie. The tables show the JSON, its resulting output, then an equivalent font definition using CSS. @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@700&display=swap'); @font-face { font-family: 'Ubuntu'; font-style: italic; font-weight: 300; font-display: swap; src: url(https://fonts.gstatic.com/s/ubuntu/v15/4iCp6KVjbNBYlgoKejZftWyI.ttf) format('truetype'); } Using a system font Here we use origin 0 (and we can omit it). fFamily needs to be an available font family. JSON Lottie Output { \"fFamily\": \"monospace\", \"fName\": \"MyFont\", \"fStyle\": \"Regular\" } var lottie_player_65 = new LottiePlayer( 'lottie_target_65', '../static/examples/font-local.json', true, {} ); CSS Output { font-family: monospace; } Hello Font from CSS URL Here we use origin 1. JSON Lottie Output { \"fPath\": \"https://fonts.googleapis.com/css2?family=Montserrat:wght@800&display=swap\", \"fFamily\": \"Poppins\", \"fStyle\": \"Bold\", \"fName\": \"Poppins Bold\", \"origin\": 1 } var lottie_player_66 = new LottiePlayer( 'lottie_target_66', '../static/examples/font-css.json', true, {} ); CSS Output @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@700&display=swap'); or <link href=\"https://fonts.googleapis.com/css2?family=Poppins:wght@700&amp;display=swap\" rel=\"stylesheet\"> Hello Font from URL Here we use origin 3. JSON Lottie Output { \"fPath\": \"https://fonts.gstatic.com/s/ubuntu/v15/4iCp6KVjbNBYlgoKejZftWyI.ttf\", \"fFamily\": \"Ubuntu\", \"fStyle\": \"Light Italic\", \"fName\": \"Ubuntu Light Italic\", \"origin\": 3 } var lottie_player_67 = new LottiePlayer( 'lottie_target_67', '../static/examples/font-url.json', true, {} ); CSS Output @font-face { font-family: 'Ubuntu'; font-style: italic; font-weight: 300; font-display: swap; src: url(https://fonts.gstatic.com/s/ubuntu/v15/4iCp6KVjbNBYlgoKejZftWyI.ttf) format('truetype'); } Hello Character Data You can also have font data directly into the lottie, this is done by having an array of character data objects in the chars attribute of the Animation . Attribute Type Title Description ch string Character Character fFamily string Font Family Font Family size number Font Size Font Size style string Font Style Font Style w number Width Width data Character Shape or Character Precomp Data Data Character Shapes Defines a character as shapes Attribute Type Title Description shapes array of Graphic Element Shapes Shapes forming the character Character Precomp Defines a character as a precomp layer Attribute Type Title Description refId string Reference Id ID of the precomp as specified in the assets ks Transform Transform Layer transform ip number In Point Frame when the layer becomes visible op number Out Point Frame when the layer becomes invisible sr number Time Stretch Time Stretch st number Start Time Start Time Text Layer The text layer has an attribute called t containing a Text Data object. Text Data Contains all the text data and animation Attribute Type Title Description a array of Text Range Ranges Ranges d Animated Text Document Document Document m Text Alignment Options Alignment Alignment p Text Follow Path Follow Path Follow Path Animated Text Document This object is similar to an animated property for text. The main difference is that it's always treated as animated (ie: you must use keyframes). Attribute Type Title Description k array of Text Document Keyframe Keyframes Keyframes x string Expression Expression sid string Slot ID One of the ID in the file's slots Text Document Keyframe This is similar to the keyframe object used by animated properties, but it doesn't have any attribute specifying interpolation as text is always animated in discrete steps. Attribute Type Title Description s Text Document Start Start t number Time Time Text Document This is where the actual text data is stored. Attribute Type Title Description f string Font Family Font Family fc Color Fill Color Fill Color sc Color Stroke Color Stroke Color sw number Stroke Width Stroke Width of boolean Stroke Over Fill Render stroke above the fill s number Font Size Font Size lh number Line Height Distance between lines on multiline or wrapped text sz array of number Wrap Size Size of the box containing the text ps array of number Wrap Position Position of the box containing the text t string Text Text, note that newlines are encoded with \\r j Text Justify Justify Justify ca Text Caps Text Caps Text Caps tr number Tracking Text Tracking ls number Baseline Shift Baseline Shift Text Color Red 0 Color Green 0 Color Blue 0 Stroke Width 0 Stroke Red 0 Stroke Green 0 Stroke Blue 0 Position X 5 Position Y 80 Font Size 100 Justify Left Right Center Justify with Last Line Left Justify with Last Line Right Justify with Last Line Center Justify with Last Line Full var lottie_player_68 = new PlaygroundPlayer( 68, 'playground_68_13', 'lottie_target_68', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 120, \"w\": 300, \"h\": 100, \"ddd\": 0, \"assets\": [], \"fonts\": {\"list\": [{\"fPath\": \"https://fonts.gstatic.com/s/ubuntu/v15/4iCp6KVjbNBYlgoKejZftWyI.ttf\", \"fFamily\": \"Ubuntu\", \"fStyle\": \"Light Italic\", \"fName\": \"Ubuntu Light Italic\", \"origin\": 3}]}, \"layers\": [{\"nm\": \"Text Layer\", \"ty\": 5, \"sr\": 1, \"ks\": {\"p\": {\"k\": [5, 80], \"a\": 0}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"t\": {\"a\": [], \"d\": {\"k\": [{\"s\": {\"f\": \"Ubuntu Light Italic\", \"fc\": [0, 0, 0], \"s\": 100, \"t\": \"Hello\", \"j\": 0}, \"t\": 0}]}, \"m\": {\"a\": {\"k\": [0, 0], \"a\": 0}}, \"p\": {}}}]}, function (lottie, data) { lottie.layers[0].t.d.k[0].s.t = data[\"Text\"]; lottie.layers[0].t.d.k[0].s.fc[0] = data[\"Color Red\"]; lottie.layers[0].t.d.k[0].s.fc[1] = data[\"Color Green\"]; lottie.layers[0].t.d.k[0].s.fc[2] = data[\"Color Blue\"]; lottie.layers[0].t.d.k[0].s.sc = [ data[\"Stroke Red\"], data[\"Stroke Green\"], data[\"Stroke Blue\"] ]; lottie.layers[0].t.d.k[0].s.sw = data[\"Stroke Width\"]; lottie.layers[0].ks.p.k[0] = data[\"Position X\"]; lottie.layers[0].ks.p.k[1] = data[\"Position Y\"]; lottie.layers[0].t.d.k[0].s.s = data[\"Font Size\"]; lottie.layers[0].t.d.k[0].s.j = Number(data[\"Justify\"]); this.json_viewer_contents = lottie.layers[0]; }, {} ); Text Alignment Options Used to change the origin point for transformations, such as Rotation, that may be applied to the text string. The origin point for each character, word, or line can be changed. Attribute Type Title Description a Vector Alignment Group alignment g Text Grouping Grouping Anchor point grouping Text Follow Path Uses the path described by a layer mask to put the text on said path. Attribute Type Title Description m integer Mask Index of the mask to use f Scalar First Margin First Margin l Scalar Last Margin Last Margin r Scalar Reverse Path Reverse Path a Scalar Force Alignment Force Alignment p Scalar Perpendicular To Path Perpendicular To Path Text Range Range of text with custom animations and style Attribute Type Title Description nm string Name Name s Text Range Selector Selector Selector a Text Style Style Style Text Hello World the quick brown fox jumps over the lazy dog Selector Start 60 End 75 Offset 0 Min Ease 0 Max Ease 0 Randomize Range Units Percent Index Based On Characters Character Excluding Spaces Words Lines Shape Square Ramp Up Ramp Down Triangle Round Smooth Position X 0 Position Y 0 Rotation 0 Opacity Style 100 Fill Fill Hue 0 Fill Saturation 0 Fill Brightness 0 Stroke Stroke Width 0 Letter Spacing 0 var lottie_player_69 = new PlaygroundPlayer( 69, 'playground_69_22', 'lottie_target_69', {\"v\": \"5.9.6\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 350, \"assets\": [], \"fonts\": {\"list\": [{\"origin\": 0, \"fPath\": \"\", \"fClass\": \"\", \"fFamily\": \"Sans\", \"fWeight\": \"\", \"fStyle\": \"Regular\", \"fName\": \"Sans\"}]}, \"layers\": [{\"ty\": 5, \"sr\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {\"p\": {\"a\": 0, \"k\": [256, 70, 0]}}, \"t\": {\"d\": {\"k\": [{\"s\": {\"s\": 70, \"f\": \"Sans\", \"t\": \"Hello World\\rthe quick brown\\rfox jumps over\\rthe lazy dog\", \"ls\": 0, \"j\": 2, \"fc\": [0, 0, 0], \"sc\": [0, 0, 0], \"sw\": 0, \"of\": true}, \"t\": 0}]}, \"p\": {}, \"m\": {\"g\": 1, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 2}}, \"a\": [{\"nm\": \"Text Range\", \"s\": {\"t\": 0, \"o\": {\"a\": 0, \"k\": 0}, \"s\": {\"a\": 0, \"k\": 60}, \"e\": {\"a\": 0, \"k\": 75}, \"a\": {\"a\": 0, \"k\": 100}, \"b\": 1, \"rn\": 0, \"sh\": 1, \"xe\": {\"a\": 0, \"k\": 0}, \"ne\": {\"a\": 0, \"k\": 0}, \"sm\": {\"a\": 0, \"k\": 100}, \"r\": 1}, \"a\": {\"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}, \"fc\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]}, \"fh\": {\"a\": 0, \"k\": 0}, \"fs\": {\"a\": 0, \"k\": 0}, \"fb\": {\"a\": 0, \"k\": 0}, \"sc\": {\"a\": 0, \"k\": [1, 0, 0]}, \"sw\": {\"a\": 0, \"k\": 0}, \"t\": {\"a\": 0, \"k\": 0}}}]}}, {\"ty\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {}, \"sc\": \"#ffffff\", \"sw\": 512, \"sh\": 350}]}, function (lottie, data) { var range = lottie.layers[0].t.a[0]; lottie.fonts.list[0].fFamily = \"monospace\"; lottie.layers[0].t.d.k[0].s.t = data[\"Text\"].replace(/\\n\\r?/g, \"\\r\") range.s.s.k = data[\"Start\"]; range.s.e.k = data[\"End\"]; range.s.o.k = data[\"Offset\"]; range.s.ne.k = data[\"Min Ease\"]; range.s.xe.k = data[\"Max Ease\"]; range.s.rn = Number(data[\"Randomize\"]); range.s.b = Number(data[\"Based On\"]); range.s.sh = Number(data[\"Shape\"]); range.s.r = Number(data[\"Range Units\"]); range.a.p.k = [data[\"Position X\"], data[\"Position Y\"]]; range.a.o.k = data[\"Opacity\"]; range.a.r.k = data[\"Rotation\"]; range.a.fc.k = data[\"Fill\"]; range.a.sc.k = data[\"Stroke\"]; range.a.sw.k = data[\"Stroke Width\"]; range.a.t.k = data[\"Letter Spacing\"]; range.a.fh.k = data[\"Fill Hue\"]; range.a.fs.k = data[\"Fill Saturation\"]; range.a.fb.k = data[\"Fill Brightness\"]; this.json_viewer_contents = lottie.layers[0].t.a[0]; }, {} ); Text Range Selector Defines the range of characters to apply a property value only to a specific subset of the text document. r Defines whether the values are defined as a percentage or indices. The range is defined by s , e , and o . ne and xe define what happes to text that is only partly inside the selected range. b changes whether selection is done on per character basis, per word, etc. It also changes the meaning of an index when r is set to Indices. Attribute Type Title Description t 0-1 integer Expressible Expressible xe Scalar Max Ease Max Ease ne Scalar Min Ease Min Ease a Scalar Max Amount Max Amount b Text Based Based On Based On rn 0-1 integer Randomize Randomize sh Text Shape Shape Shape o Scalar Offset Offset r Text Range Units Range Units Range Units sm Scalar Selector Smoothness Selector Smoothness s Scalar Start Start e Scalar End End Start 60 End 75 Offset 0 Min Ease 0 Max Ease 0 Randomize Range Units Percent Index Based On Characters Character Excluding Spaces Words Lines Shape Square Ramp Up Ramp Down Triangle Round Smooth var lottie_player_70 = new PlaygroundPlayer( 70, 'playground_70_10', 'lottie_target_70', {\"v\": \"5.9.6\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 350, \"assets\": [], \"fonts\": {\"list\": [{\"origin\": 0, \"fPath\": \"\", \"fClass\": \"\", \"fFamily\": \"Sans\", \"fWeight\": \"\", \"fStyle\": \"Regular\", \"fName\": \"Sans\"}]}, \"layers\": [{\"ty\": 5, \"sr\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {\"p\": {\"a\": 0, \"k\": [256, 70, 0]}}, \"t\": {\"d\": {\"k\": [{\"s\": {\"s\": 70, \"f\": \"Sans\", \"t\": \"Hello World\\rthe quick brown\\rfox jumps over\\rthe lazy dog\", \"ls\": 0, \"j\": 2, \"fc\": [0, 0, 0], \"sc\": [0, 0, 0], \"sw\": 0, \"of\": true}, \"t\": 0}]}, \"p\": {}, \"m\": {\"g\": 1, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 2}}, \"a\": [{\"nm\": \"Text Range\", \"s\": {\"t\": 0, \"o\": {\"a\": 0, \"k\": 0}, \"s\": {\"a\": 0, \"k\": 60}, \"e\": {\"a\": 0, \"k\": 75}, \"a\": {\"a\": 0, \"k\": 100}, \"b\": 1, \"rn\": 0, \"sh\": 1, \"xe\": {\"a\": 0, \"k\": 0}, \"ne\": {\"a\": 0, \"k\": 0}, \"sm\": {\"a\": 0, \"k\": 100}, \"r\": 1}, \"a\": {\"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}, \"fc\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]}, \"fh\": {\"a\": 0, \"k\": 0}, \"fs\": {\"a\": 0, \"k\": 0}, \"fb\": {\"a\": 0, \"k\": 0}, \"sc\": {\"a\": 0, \"k\": [1, 0, 0]}, \"sw\": {\"a\": 0, \"k\": 0}, \"t\": {\"a\": 0, \"k\": 0}}}]}}, {\"ty\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {}, \"sc\": \"#ffffff\", \"sw\": 512, \"sh\": 350}]}, function (lottie, data) { var selector = lottie.layers[0].t.a[0].s; selector.s.k = data[\"Start\"]; selector.e.k = data[\"End\"]; selector.o.k = data[\"Offset\"]; selector.ne.k = data[\"Min Ease\"]; selector.xe.k = data[\"Max Ease\"]; selector.rn = Number(data[\"Randomize\"]); selector.b = Number(data[\"Based On\"]); selector.sh = Number(data[\"Shape\"]); selector.r = Number(data[\"Range Units\"]); this.json_viewer_contents = lottie.layers[0].t.a[0].s; }, {} ); Text Style Has the properties of a transform and the style options of a text document. It applies such transform and style to the part of the text defined by the text selector property Composition Diagram for Text Style Text Style Transform Attribute Type Title Description a Position Anchor Point Anchor point: a position (relative to its parent) around which transformations are applied (ie: center for rotation / scale) p Splittable Position Position Position / Translation r Scalar Rotation Rotation in degrees, clockwise s Vector Scale Scale factor, [100, 100] for no scaling o Scalar Opacity Opacity sk Scalar Skew Skew amount as an angle in degrees sa Scalar Skew Axis Direction along which skew is applied, in degrees ( 0 skews along the X axis, 90 along the Y axis) rx Scalar X Rotation Split rotation component ry Scalar Y Rotation Split rotation component rz Scalar Z Rotation Split rotation component, equivalent to r when not split or Vector Orientation Orientation sw Scalar Stroke Width Stroke Width sc Color Stroke Color Stroke Color sh Scalar Stroke Hue Stroke Hue ss Scalar Stroke Saturation Stroke Saturation sb Scalar Stroke Brightness Stroke Brightness so Scalar Stroke Opacity Stroke Opacity fc Color Fill Color Fill Color fh Scalar Fill Hue Fill Hue fs Scalar Fill Saturation Fill Saturation fb Scalar Fill Brightness Fill Brightness fo Scalar Fill Opacity Fill Opacity t Scalar Letter Spacing Letter Spacing bl Scalar Blur Blur ls Scalar Line Spacing Line Spacing Position X 0 Position Y 0 Rotation 0 Opacity Style 100 Fill Fill Hue 0 Fill Saturation 0 Fill Brightness 0 Stroke Stroke Width 0 Letter Spacing 0 var lottie_player_71 = new PlaygroundPlayer( 71, 'playground_71_12', 'lottie_target_71', {\"v\": \"5.9.6\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 350, \"assets\": [], \"fonts\": {\"list\": [{\"origin\": 0, \"fPath\": \"\", \"fClass\": \"\", \"fFamily\": \"Sans\", \"fWeight\": \"\", \"fStyle\": \"Regular\", \"fName\": \"Sans\"}]}, \"layers\": [{\"ty\": 5, \"sr\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {\"p\": {\"a\": 0, \"k\": [256, 70, 0]}}, \"t\": {\"d\": {\"k\": [{\"s\": {\"s\": 70, \"f\": \"Sans\", \"t\": \"Hello World\\rthe quick brown\\rfox jumps over\\rthe lazy dog\", \"ls\": 0, \"j\": 2, \"fc\": [0, 0, 0], \"sc\": [0, 0, 0], \"sw\": 0, \"of\": true}, \"t\": 0}]}, \"p\": {}, \"m\": {\"g\": 1, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 2}}, \"a\": [{\"nm\": \"Text Range\", \"s\": {\"t\": 0, \"o\": {\"a\": 0, \"k\": 0}, \"s\": {\"a\": 0, \"k\": 60}, \"e\": {\"a\": 0, \"k\": 75}, \"a\": {\"a\": 0, \"k\": 100}, \"b\": 1, \"rn\": 0, \"sh\": 1, \"xe\": {\"a\": 0, \"k\": 0}, \"ne\": {\"a\": 0, \"k\": 0}, \"sm\": {\"a\": 0, \"k\": 100}, \"r\": 1}, \"a\": {\"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}, \"fc\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]}, \"fh\": {\"a\": 0, \"k\": 0}, \"fs\": {\"a\": 0, \"k\": 0}, \"fb\": {\"a\": 0, \"k\": 0}, \"sc\": {\"a\": 0, \"k\": [1, 0, 0]}, \"sw\": {\"a\": 0, \"k\": 0}, \"t\": {\"a\": 0, \"k\": 0}}}]}}, {\"ty\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {}, \"sc\": \"#ffffff\", \"sw\": 512, \"sh\": 350}]}, function (lottie, data) { var range = lottie.layers[0].t.a[0]; range.a.p.k = [data[\"Position X\"], data[\"Position Y\"]]; range.a.o.k = data[\"Opacity\"]; range.a.r.k = data[\"Rotation\"]; range.a.fc.k = data[\"Fill\"]; range.a.sc.k = data[\"Stroke\"]; range.a.sw.k = data[\"Stroke Width\"]; range.a.t.k = data[\"Letter Spacing\"]; range.a.fh.k = data[\"Fill Hue\"]; range.a.fs.k = data[\"Fill Saturation\"]; range.a.fb.k = data[\"Fill Brightness\"]; this.json_viewer_contents = lottie.layers[0].t.a[0].a; }, {} );","title":"Text"},{"location":"text/#text","text":"","title":"Text"},{"location":"text/#font-list","text":"Fonts are defined in the animation object, under fonts . When fonts is present in the Animation object, it has a single attribute called list , which is an array of font objects: Attribute Type Title Description ascent number Ascent Text will be moved down based on this value fFamily string Font Family Font Family fName string Name Name used by text documents to reference this font, usually it's fFamily followed by fStyle fStyle string Font Style Font Style fPath string Path Path fWeight string Weight Weight origin Font Path Origin Origin Origin fClass string CSS Class CSS Class applied to text objects using this font To understand how to load fonts it's better to look at some examples so here follow various ways of adding a font into lottie. The tables show the JSON, its resulting output, then an equivalent font definition using CSS. @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@700&display=swap'); @font-face { font-family: 'Ubuntu'; font-style: italic; font-weight: 300; font-display: swap; src: url(https://fonts.gstatic.com/s/ubuntu/v15/4iCp6KVjbNBYlgoKejZftWyI.ttf) format('truetype'); }","title":"Font List"},{"location":"text/#using-a-system-font","text":"Here we use origin 0 (and we can omit it). fFamily needs to be an available font family. JSON Lottie Output { \"fFamily\": \"monospace\", \"fName\": \"MyFont\", \"fStyle\": \"Regular\" } var lottie_player_65 = new LottiePlayer( 'lottie_target_65', '../static/examples/font-local.json', true, {} ); CSS Output { font-family: monospace; } Hello","title":"Using a system font"},{"location":"text/#font-from-css-url","text":"Here we use origin 1. JSON Lottie Output { \"fPath\": \"https://fonts.googleapis.com/css2?family=Montserrat:wght@800&display=swap\", \"fFamily\": \"Poppins\", \"fStyle\": \"Bold\", \"fName\": \"Poppins Bold\", \"origin\": 1 } var lottie_player_66 = new LottiePlayer( 'lottie_target_66', '../static/examples/font-css.json', true, {} ); CSS Output @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@700&display=swap'); or <link href=\"https://fonts.googleapis.com/css2?family=Poppins:wght@700&amp;display=swap\" rel=\"stylesheet\"> Hello","title":"Font from CSS URL"},{"location":"text/#font-from-url","text":"Here we use origin 3. JSON Lottie Output { \"fPath\": \"https://fonts.gstatic.com/s/ubuntu/v15/4iCp6KVjbNBYlgoKejZftWyI.ttf\", \"fFamily\": \"Ubuntu\", \"fStyle\": \"Light Italic\", \"fName\": \"Ubuntu Light Italic\", \"origin\": 3 } var lottie_player_67 = new LottiePlayer( 'lottie_target_67', '../static/examples/font-url.json', true, {} ); CSS Output @font-face { font-family: 'Ubuntu'; font-style: italic; font-weight: 300; font-display: swap; src: url(https://fonts.gstatic.com/s/ubuntu/v15/4iCp6KVjbNBYlgoKejZftWyI.ttf) format('truetype'); } Hello","title":"Font from URL"},{"location":"text/#character-data","text":"You can also have font data directly into the lottie, this is done by having an array of character data objects in the chars attribute of the Animation . Attribute Type Title Description ch string Character Character fFamily string Font Family Font Family size number Font Size Font Size style string Font Style Font Style w number Width Width data Character Shape or Character Precomp Data Data","title":"Character Data"},{"location":"text/#character-shapes","text":"Defines a character as shapes Attribute Type Title Description shapes array of Graphic Element Shapes Shapes forming the character","title":"Character Shapes"},{"location":"text/#character-precomp","text":"Defines a character as a precomp layer Attribute Type Title Description refId string Reference Id ID of the precomp as specified in the assets ks Transform Transform Layer transform ip number In Point Frame when the layer becomes visible op number Out Point Frame when the layer becomes invisible sr number Time Stretch Time Stretch st number Start Time Start Time","title":"Character Precomp"},{"location":"text/#text-layer","text":"The text layer has an attribute called t containing a Text Data object.","title":"Text Layer"},{"location":"text/#text-data","text":"Contains all the text data and animation Attribute Type Title Description a array of Text Range Ranges Ranges d Animated Text Document Document Document m Text Alignment Options Alignment Alignment p Text Follow Path Follow Path Follow Path","title":"Text Data"},{"location":"text/#animated-text-document","text":"This object is similar to an animated property for text. The main difference is that it's always treated as animated (ie: you must use keyframes). Attribute Type Title Description k array of Text Document Keyframe Keyframes Keyframes x string Expression Expression sid string Slot ID One of the ID in the file's slots","title":"Animated Text Document"},{"location":"text/#text-document-keyframe","text":"This is similar to the keyframe object used by animated properties, but it doesn't have any attribute specifying interpolation as text is always animated in discrete steps. Attribute Type Title Description s Text Document Start Start t number Time Time","title":"Text Document Keyframe"},{"location":"text/#text-document","text":"This is where the actual text data is stored. Attribute Type Title Description f string Font Family Font Family fc Color Fill Color Fill Color sc Color Stroke Color Stroke Color sw number Stroke Width Stroke Width of boolean Stroke Over Fill Render stroke above the fill s number Font Size Font Size lh number Line Height Distance between lines on multiline or wrapped text sz array of number Wrap Size Size of the box containing the text ps array of number Wrap Position Position of the box containing the text t string Text Text, note that newlines are encoded with \\r j Text Justify Justify Justify ca Text Caps Text Caps Text Caps tr number Tracking Text Tracking ls number Baseline Shift Baseline Shift Text Color Red 0 Color Green 0 Color Blue 0 Stroke Width 0 Stroke Red 0 Stroke Green 0 Stroke Blue 0 Position X 5 Position Y 80 Font Size 100 Justify Left Right Center Justify with Last Line Left Justify with Last Line Right Justify with Last Line Center Justify with Last Line Full var lottie_player_68 = new PlaygroundPlayer( 68, 'playground_68_13', 'lottie_target_68', {\"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 120, \"w\": 300, \"h\": 100, \"ddd\": 0, \"assets\": [], \"fonts\": {\"list\": [{\"fPath\": \"https://fonts.gstatic.com/s/ubuntu/v15/4iCp6KVjbNBYlgoKejZftWyI.ttf\", \"fFamily\": \"Ubuntu\", \"fStyle\": \"Light Italic\", \"fName\": \"Ubuntu Light Italic\", \"origin\": 3}]}, \"layers\": [{\"nm\": \"Text Layer\", \"ty\": 5, \"sr\": 1, \"ks\": {\"p\": {\"k\": [5, 80], \"a\": 0}}, \"ip\": 0, \"op\": 120, \"st\": 0, \"t\": {\"a\": [], \"d\": {\"k\": [{\"s\": {\"f\": \"Ubuntu Light Italic\", \"fc\": [0, 0, 0], \"s\": 100, \"t\": \"Hello\", \"j\": 0}, \"t\": 0}]}, \"m\": {\"a\": {\"k\": [0, 0], \"a\": 0}}, \"p\": {}}}]}, function (lottie, data) { lottie.layers[0].t.d.k[0].s.t = data[\"Text\"]; lottie.layers[0].t.d.k[0].s.fc[0] = data[\"Color Red\"]; lottie.layers[0].t.d.k[0].s.fc[1] = data[\"Color Green\"]; lottie.layers[0].t.d.k[0].s.fc[2] = data[\"Color Blue\"]; lottie.layers[0].t.d.k[0].s.sc = [ data[\"Stroke Red\"], data[\"Stroke Green\"], data[\"Stroke Blue\"] ]; lottie.layers[0].t.d.k[0].s.sw = data[\"Stroke Width\"]; lottie.layers[0].ks.p.k[0] = data[\"Position X\"]; lottie.layers[0].ks.p.k[1] = data[\"Position Y\"]; lottie.layers[0].t.d.k[0].s.s = data[\"Font Size\"]; lottie.layers[0].t.d.k[0].s.j = Number(data[\"Justify\"]); this.json_viewer_contents = lottie.layers[0]; }, {} );","title":"Text Document"},{"location":"text/#text-alignment-options","text":"Used to change the origin point for transformations, such as Rotation, that may be applied to the text string. The origin point for each character, word, or line can be changed. Attribute Type Title Description a Vector Alignment Group alignment g Text Grouping Grouping Anchor point grouping","title":"Text Alignment Options"},{"location":"text/#text-follow-path","text":"Uses the path described by a layer mask to put the text on said path. Attribute Type Title Description m integer Mask Index of the mask to use f Scalar First Margin First Margin l Scalar Last Margin Last Margin r Scalar Reverse Path Reverse Path a Scalar Force Alignment Force Alignment p Scalar Perpendicular To Path Perpendicular To Path","title":"Text Follow Path"},{"location":"text/#text-range","text":"Range of text with custom animations and style Attribute Type Title Description nm string Name Name s Text Range Selector Selector Selector a Text Style Style Style Text Hello World the quick brown fox jumps over the lazy dog Selector Start 60 End 75 Offset 0 Min Ease 0 Max Ease 0 Randomize Range Units Percent Index Based On Characters Character Excluding Spaces Words Lines Shape Square Ramp Up Ramp Down Triangle Round Smooth Position X 0 Position Y 0 Rotation 0 Opacity Style 100 Fill Fill Hue 0 Fill Saturation 0 Fill Brightness 0 Stroke Stroke Width 0 Letter Spacing 0 var lottie_player_69 = new PlaygroundPlayer( 69, 'playground_69_22', 'lottie_target_69', {\"v\": \"5.9.6\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 350, \"assets\": [], \"fonts\": {\"list\": [{\"origin\": 0, \"fPath\": \"\", \"fClass\": \"\", \"fFamily\": \"Sans\", \"fWeight\": \"\", \"fStyle\": \"Regular\", \"fName\": \"Sans\"}]}, \"layers\": [{\"ty\": 5, \"sr\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {\"p\": {\"a\": 0, \"k\": [256, 70, 0]}}, \"t\": {\"d\": {\"k\": [{\"s\": {\"s\": 70, \"f\": \"Sans\", \"t\": \"Hello World\\rthe quick brown\\rfox jumps over\\rthe lazy dog\", \"ls\": 0, \"j\": 2, \"fc\": [0, 0, 0], \"sc\": [0, 0, 0], \"sw\": 0, \"of\": true}, \"t\": 0}]}, \"p\": {}, \"m\": {\"g\": 1, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 2}}, \"a\": [{\"nm\": \"Text Range\", \"s\": {\"t\": 0, \"o\": {\"a\": 0, \"k\": 0}, \"s\": {\"a\": 0, \"k\": 60}, \"e\": {\"a\": 0, \"k\": 75}, \"a\": {\"a\": 0, \"k\": 100}, \"b\": 1, \"rn\": 0, \"sh\": 1, \"xe\": {\"a\": 0, \"k\": 0}, \"ne\": {\"a\": 0, \"k\": 0}, \"sm\": {\"a\": 0, \"k\": 100}, \"r\": 1}, \"a\": {\"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}, \"fc\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]}, \"fh\": {\"a\": 0, \"k\": 0}, \"fs\": {\"a\": 0, \"k\": 0}, \"fb\": {\"a\": 0, \"k\": 0}, \"sc\": {\"a\": 0, \"k\": [1, 0, 0]}, \"sw\": {\"a\": 0, \"k\": 0}, \"t\": {\"a\": 0, \"k\": 0}}}]}}, {\"ty\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {}, \"sc\": \"#ffffff\", \"sw\": 512, \"sh\": 350}]}, function (lottie, data) { var range = lottie.layers[0].t.a[0]; lottie.fonts.list[0].fFamily = \"monospace\"; lottie.layers[0].t.d.k[0].s.t = data[\"Text\"].replace(/\\n\\r?/g, \"\\r\") range.s.s.k = data[\"Start\"]; range.s.e.k = data[\"End\"]; range.s.o.k = data[\"Offset\"]; range.s.ne.k = data[\"Min Ease\"]; range.s.xe.k = data[\"Max Ease\"]; range.s.rn = Number(data[\"Randomize\"]); range.s.b = Number(data[\"Based On\"]); range.s.sh = Number(data[\"Shape\"]); range.s.r = Number(data[\"Range Units\"]); range.a.p.k = [data[\"Position X\"], data[\"Position Y\"]]; range.a.o.k = data[\"Opacity\"]; range.a.r.k = data[\"Rotation\"]; range.a.fc.k = data[\"Fill\"]; range.a.sc.k = data[\"Stroke\"]; range.a.sw.k = data[\"Stroke Width\"]; range.a.t.k = data[\"Letter Spacing\"]; range.a.fh.k = data[\"Fill Hue\"]; range.a.fs.k = data[\"Fill Saturation\"]; range.a.fb.k = data[\"Fill Brightness\"]; this.json_viewer_contents = lottie.layers[0].t.a[0]; }, {} );","title":"Text Range"},{"location":"text/#text-range-selector","text":"Defines the range of characters to apply a property value only to a specific subset of the text document. r Defines whether the values are defined as a percentage or indices. The range is defined by s , e , and o . ne and xe define what happes to text that is only partly inside the selected range. b changes whether selection is done on per character basis, per word, etc. It also changes the meaning of an index when r is set to Indices. Attribute Type Title Description t 0-1 integer Expressible Expressible xe Scalar Max Ease Max Ease ne Scalar Min Ease Min Ease a Scalar Max Amount Max Amount b Text Based Based On Based On rn 0-1 integer Randomize Randomize sh Text Shape Shape Shape o Scalar Offset Offset r Text Range Units Range Units Range Units sm Scalar Selector Smoothness Selector Smoothness s Scalar Start Start e Scalar End End Start 60 End 75 Offset 0 Min Ease 0 Max Ease 0 Randomize Range Units Percent Index Based On Characters Character Excluding Spaces Words Lines Shape Square Ramp Up Ramp Down Triangle Round Smooth var lottie_player_70 = new PlaygroundPlayer( 70, 'playground_70_10', 'lottie_target_70', {\"v\": \"5.9.6\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 350, \"assets\": [], \"fonts\": {\"list\": [{\"origin\": 0, \"fPath\": \"\", \"fClass\": \"\", \"fFamily\": \"Sans\", \"fWeight\": \"\", \"fStyle\": \"Regular\", \"fName\": \"Sans\"}]}, \"layers\": [{\"ty\": 5, \"sr\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {\"p\": {\"a\": 0, \"k\": [256, 70, 0]}}, \"t\": {\"d\": {\"k\": [{\"s\": {\"s\": 70, \"f\": \"Sans\", \"t\": \"Hello World\\rthe quick brown\\rfox jumps over\\rthe lazy dog\", \"ls\": 0, \"j\": 2, \"fc\": [0, 0, 0], \"sc\": [0, 0, 0], \"sw\": 0, \"of\": true}, \"t\": 0}]}, \"p\": {}, \"m\": {\"g\": 1, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 2}}, \"a\": [{\"nm\": \"Text Range\", \"s\": {\"t\": 0, \"o\": {\"a\": 0, \"k\": 0}, \"s\": {\"a\": 0, \"k\": 60}, \"e\": {\"a\": 0, \"k\": 75}, \"a\": {\"a\": 0, \"k\": 100}, \"b\": 1, \"rn\": 0, \"sh\": 1, \"xe\": {\"a\": 0, \"k\": 0}, \"ne\": {\"a\": 0, \"k\": 0}, \"sm\": {\"a\": 0, \"k\": 100}, \"r\": 1}, \"a\": {\"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}, \"fc\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]}, \"fh\": {\"a\": 0, \"k\": 0}, \"fs\": {\"a\": 0, \"k\": 0}, \"fb\": {\"a\": 0, \"k\": 0}, \"sc\": {\"a\": 0, \"k\": [1, 0, 0]}, \"sw\": {\"a\": 0, \"k\": 0}, \"t\": {\"a\": 0, \"k\": 0}}}]}}, {\"ty\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {}, \"sc\": \"#ffffff\", \"sw\": 512, \"sh\": 350}]}, function (lottie, data) { var selector = lottie.layers[0].t.a[0].s; selector.s.k = data[\"Start\"]; selector.e.k = data[\"End\"]; selector.o.k = data[\"Offset\"]; selector.ne.k = data[\"Min Ease\"]; selector.xe.k = data[\"Max Ease\"]; selector.rn = Number(data[\"Randomize\"]); selector.b = Number(data[\"Based On\"]); selector.sh = Number(data[\"Shape\"]); selector.r = Number(data[\"Range Units\"]); this.json_viewer_contents = lottie.layers[0].t.a[0].s; }, {} );","title":"Text Range Selector"},{"location":"text/#text-style","text":"Has the properties of a transform and the style options of a text document. It applies such transform and style to the part of the text defined by the text selector property Composition Diagram for Text Style Text Style Transform Attribute Type Title Description a Position Anchor Point Anchor point: a position (relative to its parent) around which transformations are applied (ie: center for rotation / scale) p Splittable Position Position Position / Translation r Scalar Rotation Rotation in degrees, clockwise s Vector Scale Scale factor, [100, 100] for no scaling o Scalar Opacity Opacity sk Scalar Skew Skew amount as an angle in degrees sa Scalar Skew Axis Direction along which skew is applied, in degrees ( 0 skews along the X axis, 90 along the Y axis) rx Scalar X Rotation Split rotation component ry Scalar Y Rotation Split rotation component rz Scalar Z Rotation Split rotation component, equivalent to r when not split or Vector Orientation Orientation sw Scalar Stroke Width Stroke Width sc Color Stroke Color Stroke Color sh Scalar Stroke Hue Stroke Hue ss Scalar Stroke Saturation Stroke Saturation sb Scalar Stroke Brightness Stroke Brightness so Scalar Stroke Opacity Stroke Opacity fc Color Fill Color Fill Color fh Scalar Fill Hue Fill Hue fs Scalar Fill Saturation Fill Saturation fb Scalar Fill Brightness Fill Brightness fo Scalar Fill Opacity Fill Opacity t Scalar Letter Spacing Letter Spacing bl Scalar Blur Blur ls Scalar Line Spacing Line Spacing Position X 0 Position Y 0 Rotation 0 Opacity Style 100 Fill Fill Hue 0 Fill Saturation 0 Fill Brightness 0 Stroke Stroke Width 0 Letter Spacing 0 var lottie_player_71 = new PlaygroundPlayer( 71, 'playground_71_12', 'lottie_target_71', {\"v\": \"5.9.6\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 350, \"assets\": [], \"fonts\": {\"list\": [{\"origin\": 0, \"fPath\": \"\", \"fClass\": \"\", \"fFamily\": \"Sans\", \"fWeight\": \"\", \"fStyle\": \"Regular\", \"fName\": \"Sans\"}]}, \"layers\": [{\"ty\": 5, \"sr\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {\"p\": {\"a\": 0, \"k\": [256, 70, 0]}}, \"t\": {\"d\": {\"k\": [{\"s\": {\"s\": 70, \"f\": \"Sans\", \"t\": \"Hello World\\rthe quick brown\\rfox jumps over\\rthe lazy dog\", \"ls\": 0, \"j\": 2, \"fc\": [0, 0, 0], \"sc\": [0, 0, 0], \"sw\": 0, \"of\": true}, \"t\": 0}]}, \"p\": {}, \"m\": {\"g\": 1, \"a\": {\"a\": 0, \"k\": [0, 0], \"ix\": 2}}, \"a\": [{\"nm\": \"Text Range\", \"s\": {\"t\": 0, \"o\": {\"a\": 0, \"k\": 0}, \"s\": {\"a\": 0, \"k\": 60}, \"e\": {\"a\": 0, \"k\": 75}, \"a\": {\"a\": 0, \"k\": 100}, \"b\": 1, \"rn\": 0, \"sh\": 1, \"xe\": {\"a\": 0, \"k\": 0}, \"ne\": {\"a\": 0, \"k\": 0}, \"sm\": {\"a\": 0, \"k\": 100}, \"r\": 1}, \"a\": {\"p\": {\"a\": 0, \"k\": [0, 0]}, \"r\": {\"a\": 0, \"k\": 0}, \"o\": {\"a\": 0, \"k\": 100}, \"fc\": {\"a\": 0, \"k\": [0.196, 0.314, 0.69]}, \"fh\": {\"a\": 0, \"k\": 0}, \"fs\": {\"a\": 0, \"k\": 0}, \"fb\": {\"a\": 0, \"k\": 0}, \"sc\": {\"a\": 0, \"k\": [1, 0, 0]}, \"sw\": {\"a\": 0, \"k\": 0}, \"t\": {\"a\": 0, \"k\": 0}}}]}}, {\"ty\": 1, \"ip\": 0, \"op\": 60, \"st\": 0, \"ks\": {}, \"sc\": \"#ffffff\", \"sw\": 512, \"sh\": 350}]}, function (lottie, data) { var range = lottie.layers[0].t.a[0]; range.a.p.k = [data[\"Position X\"], data[\"Position Y\"]]; range.a.o.k = data[\"Opacity\"]; range.a.r.k = data[\"Rotation\"]; range.a.fc.k = data[\"Fill\"]; range.a.sc.k = data[\"Stroke\"]; range.a.sw.k = data[\"Stroke Width\"]; range.a.t.k = data[\"Letter Spacing\"]; range.a.fh.k = data[\"Fill Hue\"]; range.a.fs.k = data[\"Fill Saturation\"]; range.a.fb.k = data[\"Fill Brightness\"]; this.json_viewer_contents = lottie.layers[0].t.a[0].a; }, {} );","title":"Text Style"},{"location":"values/","text":"Values This pages describes basic types and values throughout the lottie format. Integer Boolean In some places boolean values are shown as booleans in the JSON ( true / false ). In other places they are shown as integers with 0 or 1 as values. Vector Vector data is represented by an array of numbers. This is used any time a property with multiple components is needed. An example would be a position, which would be represented as an array with two numbers, the first corresponding to the X coordinate and the second corresponding to the Y . Color Colors are Vectors with values between 0 and 1 for the RGB components. For example: [1, 0, 0] [1, 0.5, 0] Note: sometimes you might find color values with 4 components (the 4th being alpha) but most players ignore the last component. Hex Color Colors represented as a \"#\"-prefixed string, with two hexadecimal digits per RGB component. #FF8000 Gradient Gradients are represented as a flat array, showing offsets and RGB components. There are two possible representations, with alpha, and without. Gradients without transparency The array is a sequence of offset , red , green , blue components for each color. all values are between 0 and 1 So let's say you want these colors: [0.161, 0.184, 0.459] [0.196, 0.314, 0.69] [0.769, 0.851, 0.961] the array will look like the following: [0, 0.16, 0.18, 0.46, 0.5, 0.2, 0.31, 0.69, 1, 0.77, 0.85, 0.96] Value Description 0 Offset of the 1st color ( 0 means at the start) 0.161 Red component for the 1st color 0.184 Green component for the 1st color 0.459 Blue component for the 1st color 0.5 Offset of the 2nd color ( 0.5 means half way) 0.196 Red component for the 2nd color 0.314 Green component for the 2nd color 0.69 Blue component for the 2nd color 1 Offset of the 3rd color ( 1 means at the end) 0.769 Red component for the 3rd color 0.851 Green component for the 3rd color 0.961 Blue component for the 3rd color Gradients with transparency Alpha is added at the end, repeating offsets and followed by alpha for each colors So assume the same colors as before, but opacity of 80% for the first color and 100% for the other two. The array will look like this: [0, 0.16, 0.18, 0.46, 0.5, 0.2, 0.31, 0.69, 1, 0.77, 0.85, 0.96, 0, 0.8, 0.5, 0.2, 1, 1] It's the same array as the case without transparency but with the following values added at the end: Value Description 0 Offset of the 1st color ( 0 means at the start) 0.8 Alpha component for the 1st color 0.5 Offset of the 2nd color ( 0.5 means half way) 1 Alpha component for the 2nd color 1 Offset of the 3rd color ( 1 means at the end) 1 Alpha component for the 3rd color Gradient Example GradientPreviewEditor.stand_alone(document.getElementById(\"editor_72\"), (lottie) => { var raw_json = JSON.stringify(lottie, undefined, 4); var pretty_json = hljs.highlight(\"json\", raw_json).value; document.getElementById(\"json_viewer_72\").innerHTML = pretty_json; }, ); Bezier Shape This represents a cubic bezier path. Note that for interpolation to work correctly all bezier values in a property's keyframe must have the same number of points. Attribute Type Title Description c boolean Closed Closed i array of Vector In Tangents Array of points, each point is an array of coordinates. These points are along the in tangents relative to the corresponding v . o array of Vector Out Tangents Array of points, each point is an array of coordinates. These points are along the out tangents relative to the corresponding v . v array of Vector Vertices Array of points, each point is an array of coordinates. These points are along the bezier path i and o are relative to v . The n th bezier segment is defined as: v[n], v[n]+o[n], v[n+1]+i[n+1], v[n+1] If the bezier is closed, you need an extra segment going from the last point to the first, still following i and o appropriately. If you want linear bezier, you can have i and o for a segment to be [0, 0] . If you want it quadratic, set them to 2/3rd of what the quadratic control point would be. If you want a point to be smooth you need to make sure that i = -o . BezierPreviewEditor.stand_alone(document.getElementById(\"editor_73\"), (lottie) => { var raw_json = JSON.stringify(lottie, undefined, 4); var pretty_json = hljs.highlight(\"json\", raw_json).value; document.getElementById(\"json_viewer_73\").innerHTML = pretty_json; }, ); Data URL Data URLs are embedded files (such as images) as defined in [ RFC2397 ] .","title":"Values"},{"location":"values/#values","text":"This pages describes basic types and values throughout the lottie format.","title":"Values"},{"location":"values/#int-boolean","text":"In some places boolean values are shown as booleans in the JSON ( true / false ). In other places they are shown as integers with 0 or 1 as values.","title":"Integer Boolean"},{"location":"values/#vector","text":"Vector data is represented by an array of numbers. This is used any time a property with multiple components is needed. An example would be a position, which would be represented as an array with two numbers, the first corresponding to the X coordinate and the second corresponding to the Y .","title":"Vector"},{"location":"values/#color","text":"Colors are Vectors with values between 0 and 1 for the RGB components. For example: [1, 0, 0] [1, 0.5, 0] Note: sometimes you might find color values with 4 components (the 4th being alpha) but most players ignore the last component.","title":"Color"},{"location":"values/#hexcolor","text":"Colors represented as a \"#\"-prefixed string, with two hexadecimal digits per RGB component. #FF8000","title":"Hex Color"},{"location":"values/#gradient","text":"Gradients are represented as a flat array, showing offsets and RGB components. There are two possible representations, with alpha, and without.","title":"Gradient"},{"location":"values/#gradients-without-transparency","text":"The array is a sequence of offset , red , green , blue components for each color. all values are between 0 and 1 So let's say you want these colors: [0.161, 0.184, 0.459] [0.196, 0.314, 0.69] [0.769, 0.851, 0.961] the array will look like the following: [0, 0.16, 0.18, 0.46, 0.5, 0.2, 0.31, 0.69, 1, 0.77, 0.85, 0.96] Value Description 0 Offset of the 1st color ( 0 means at the start) 0.161 Red component for the 1st color 0.184 Green component for the 1st color 0.459 Blue component for the 1st color 0.5 Offset of the 2nd color ( 0.5 means half way) 0.196 Red component for the 2nd color 0.314 Green component for the 2nd color 0.69 Blue component for the 2nd color 1 Offset of the 3rd color ( 1 means at the end) 0.769 Red component for the 3rd color 0.851 Green component for the 3rd color 0.961 Blue component for the 3rd color","title":"Gradients without transparency"},{"location":"values/#gradients-with-transparency","text":"Alpha is added at the end, repeating offsets and followed by alpha for each colors So assume the same colors as before, but opacity of 80% for the first color and 100% for the other two. The array will look like this: [0, 0.16, 0.18, 0.46, 0.5, 0.2, 0.31, 0.69, 1, 0.77, 0.85, 0.96, 0, 0.8, 0.5, 0.2, 1, 1] It's the same array as the case without transparency but with the following values added at the end: Value Description 0 Offset of the 1st color ( 0 means at the start) 0.8 Alpha component for the 1st color 0.5 Offset of the 2nd color ( 0.5 means half way) 1 Alpha component for the 2nd color 1 Offset of the 3rd color ( 1 means at the end) 1 Alpha component for the 3rd color","title":"Gradients with transparency"},{"location":"values/#gradient-example","text":"GradientPreviewEditor.stand_alone(document.getElementById(\"editor_72\"), (lottie) => { var raw_json = JSON.stringify(lottie, undefined, 4); var pretty_json = hljs.highlight(\"json\", raw_json).value; document.getElementById(\"json_viewer_72\").innerHTML = pretty_json; }, );","title":"Gradient Example"},{"location":"values/#bezier","text":"This represents a cubic bezier path. Note that for interpolation to work correctly all bezier values in a property's keyframe must have the same number of points. Attribute Type Title Description c boolean Closed Closed i array of Vector In Tangents Array of points, each point is an array of coordinates. These points are along the in tangents relative to the corresponding v . o array of Vector Out Tangents Array of points, each point is an array of coordinates. These points are along the out tangents relative to the corresponding v . v array of Vector Vertices Array of points, each point is an array of coordinates. These points are along the bezier path i and o are relative to v . The n th bezier segment is defined as: v[n], v[n]+o[n], v[n+1]+i[n+1], v[n+1] If the bezier is closed, you need an extra segment going from the last point to the first, still following i and o appropriately. If you want linear bezier, you can have i and o for a segment to be [0, 0] . If you want it quadratic, set them to 2/3rd of what the quadratic control point would be. If you want a point to be smooth you need to make sure that i = -o . BezierPreviewEditor.stand_alone(document.getElementById(\"editor_73\"), (lottie) => { var raw_json = JSON.stringify(lottie, undefined, 4); var pretty_json = hljs.highlight(\"json\", raw_json).value; document.getElementById(\"json_viewer_73\").innerHTML = pretty_json; }, );","title":"Bezier Shape"},{"location":"values/#data-url","text":"Data URLs are embedded files (such as images) as defined in [ RFC2397 ] .","title":"Data URL"},{"location":"breakdown/bezier/","text":"Bezier Curves var lottie_player_74 = new LottiePlayer( 'lottie_target_74', '../../static/examples/bezier_expression.json', true, {} ); Introduction to Beziers Bezier curves are a common way of approximating arbitrary shapes in computer graphics. They represent an arc of a polynomial, and they can be of any degree, but usually you will mostly find quadratic and cubic beziers. Lottie only deals in cubic beziers so we'll focus on those. A bezier curve of degree n is defined by n +1 points. The first and the last of such points will lay on the curve, while the others define the shape of the segment. So for the case of a cubic bezier (degree 3) you have 4 points. To find a point on a bezier, you usually define it as the result of an interpolation within the polynomial curve. The interpolation factor is usually referred to as t . The easiest way of calculating the poition of a point in a bezier given a t is to perform linear interpolations between the bezier points, each step reducing the curve to one with a degree less than the previous, until you end up with a final point. For example in the cubic case, you interpolate each cubic point with the next, resulting in 3 quadratic points. You repeat the process on these 3 points, and you end up with 2 other points. Finally you perform linear interpolation between the two to get the result. In the example below you can control the t value to see how this algorithm works. The black dots are the ones that define the bezier, and the red dot is the position along the bezier at the given t . var lottie_player_75 = new PlaygroundPlayer( 75, 'playground_75_1', 'lottie_target_75', {\"nm\": \"Animation\", \"fr\": 60, \"ip\": 0, \"op\": 280, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [], \"chars\": [], \"layers\": [{\"nm\": \"Shapes\", \"ddd\": 0, \"hd\": false, \"ks\": {}, \"ao\": 0, \"ip\": 0, \"op\": 280, \"st\": 0, \"hasMask\": false, \"masksProperties\": [], \"ef\": [{\"ef\": [{\"ty\": 0, \"nm\": \"Slider\", \"v\": {\"a\": 1, \"k\": [{\"t\": 0, \"i\": {\"x\": [0.667], \"y\": [1]}, \"o\": {\"x\": [0.333], \"y\": [0]}, \"s\": [0]}, {\"t\": 120, \"i\": {\"x\": [0.667], \"y\": [1]}, \"o\": {\"x\": [0.333], \"y\": [0]}, \"s\": [1]}, {\"t\": 140, \"i\": {\"x\": [0.667], \"y\": [1]}, \"o\": {\"x\": [0.333], \"y\": [0]}, \"s\": [1]}, {\"t\": 260, \"s\": [0]}]}}], \"ty\": 5, \"nm\": \"Slider\"}], \"mb\": false, \"ty\": 4, \"shapes\": [{\"nm\": \"Bezier Point\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"nm\": \"p0\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [25, 400], \"x\": \"var group = thisLayer.content(\\\"Linear Points\\\");\\nvar pt_index = 0;\\nvar pt_from = group.content(\\\"p\\\"+pt_index).position;\\nvar pt_to = group.content(\\\"p\\\"+(pt_index+1)).position;\\nvar t = thisLayer.effect(\\\"Slider\\\")(\\\"Slider\\\");\\nvar $bm_rt = linear(t, pt_from, pt_to);\\n\"}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"hd\": false, \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.125, 0]}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Linear Points\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"nm\": \"p0\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [25, 400], \"x\": \"var group = thisLayer.content(\\\"Quadratic Points\\\");\\nvar pt_index = 0;\\nvar pt_from = group.content(\\\"p\\\"+pt_index).position;\\nvar pt_to = group.content(\\\"p\\\"+(pt_index+1)).position;\\nvar t = thisLayer.effect(\\\"Slider\\\")(\\\"Slider\\\");\\nvar $bm_rt = linear(t, pt_from, pt_to);\\n\"}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"nm\": \"p1\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [130, 170], \"x\": \"var group = thisLayer.content(\\\"Quadratic Points\\\");\\nvar pt_index = 1;\\nvar pt_from = group.content(\\\"p\\\"+pt_index).position;\\nvar pt_to = group.content(\\\"p\\\"+(pt_index+1)).position;\\nvar t = thisLayer.effect(\\\"Slider\\\")(\\\"Slider\\\");\\nvar $bm_rt = linear(t, pt_from, pt_to);\\n\"}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"hd\": false, \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.8, 0]}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Linear Lines\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"ty\": \"sh\", \"ks\": {\"a\": 0, \"k\": {\"i\": [], \"o\": [], \"v\": []}, \"x\": \"var group = thisLayer.content(\\\"Linear Points\\\");\\nvar num_points = 2;\\nvar points = [];\\nvar ip = [];\\nvar op = [];\\nfor ( var i = 0; i < num_points; i++ )\\n{\\n var pos = group.content(\\\"p\\\" + i).position;\\n points.push(pos);\\n ip.push(pos);\\n op.push(pos);\\n}\\nvar $bm_rt = {\\n v: points,\\n i: ip,\\n o: op\\n};\\n\"}}, {\"hd\": false, \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.8, 0]}, \"w\": {\"a\": 0, \"k\": 10}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Quadratic Points\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"nm\": \"p0\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [25, 400], \"x\": \"var group = thisLayer.content(\\\"Cubic Points\\\");\\nvar pt_index = 0;\\nvar pt_from = group.content(\\\"p\\\"+pt_index).position;\\nvar pt_to = group.content(\\\"p\\\"+(pt_index+1)).position;\\nvar t = thisLayer.effect(\\\"Slider\\\")(\\\"Slider\\\");\\nvar $bm_rt = linear(t, pt_from, pt_to);\\n\"}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"nm\": \"p1\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [130, 170], \"x\": \"var group = thisLayer.content(\\\"Cubic Points\\\");\\nvar pt_index = 1;\\nvar pt_from = group.content(\\\"p\\\"+pt_index).position;\\nvar pt_to = group.content(\\\"p\\\"+(pt_index+1)).position;\\nvar t = thisLayer.effect(\\\"Slider\\\")(\\\"Slider\\\");\\nvar $bm_rt = linear(t, pt_from, pt_to);\\n\"}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"nm\": \"p2\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [350, 230], \"x\": \"var group = thisLayer.content(\\\"Cubic Points\\\");\\nvar pt_index = 2;\\nvar pt_from = group.content(\\\"p\\\"+pt_index).position;\\nvar pt_to = group.content(\\\"p\\\"+(pt_index+1)).position;\\nvar t = thisLayer.effect(\\\"Slider\\\")(\\\"Slider\\\");\\nvar $bm_rt = linear(t, pt_from, pt_to);\\n\"}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"hd\": false, \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.2, 0.2, 1]}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Quadratic Lines\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"ty\": \"sh\", \"ks\": {\"a\": 0, \"k\": {\"i\": [], \"o\": [], \"v\": []}, \"x\": \"var group = thisLayer.content(\\\"Quadratic Points\\\");\\nvar num_points = 3;\\nvar points = [];\\nvar ip = [];\\nvar op = [];\\nfor ( var i = 0; i < num_points; i++ )\\n{\\n var pos = group.content(\\\"p\\\" + i).position;\\n points.push(pos);\\n ip.push(pos);\\n op.push(pos);\\n}\\nvar $bm_rt = {\\n v: points,\\n i: ip,\\n o: op\\n};\\n\"}}, {\"hd\": false, \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.2, 0.2, 1]}, \"w\": {\"a\": 0, \"k\": 10}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Cubic Points\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"nm\": \"p0\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [25, 400]}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"nm\": \"p1\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [130, 170]}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"nm\": \"p2\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [350, 230]}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"nm\": \"p3\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [485, 400]}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"hd\": false, \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0, 0]}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Cubic Lines\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"ty\": \"sh\", \"ks\": {\"a\": 0, \"k\": {\"i\": [], \"o\": [], \"v\": []}, \"x\": \"var group = thisLayer.content(\\\"Cubic Points\\\");\\nvar num_points = 4;\\nvar points = [];\\nvar ip = [];\\nvar op = [];\\nfor ( var i = 0; i < num_points; i++ )\\n{\\n var pos = group.content(\\\"p\\\" + i).position;\\n points.push(pos);\\n ip.push(pos);\\n op.push(pos);\\n}\\nvar $bm_rt = {\\n v: points,\\n i: ip,\\n o: op\\n};\\n\"}}, {\"hd\": false, \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0, 0]}, \"w\": {\"a\": 0, \"k\": 10}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Bezier Result\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"ty\": \"sh\", \"ks\": {\"a\": 0, \"k\": {\"i\": [], \"o\": [], \"v\": []}, \"x\": \"var group = thisLayer.content(\\\"Cubic Points\\\");\\nvar $bm_rt = {\\n v: [group.content(\\\"p0\\\").position, group.content(\\\"p3\\\").position],\\n i: [[0, 0], group.content(\\\"p2\\\").position],\\n o: [group.content(\\\"p1\\\").position, [0,0]]\\n};\\n\"}}, {\"hd\": false, \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.8, 0]}, \"w\": {\"a\": 0, \"k\": 10}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}]}]}, function (lottie, data) { }, {} ); lottie.layers[0].ef[0].ef[0].v.a = 0; lottie.layers[0].ef[0].ef[0].v.k = data[\"t\"]; Poly Beziers Usually shapes are defined as a polybezier, which is the a concept equivalent to polygons, but with bezier segments as their edges. Each bezier segment has its last point in the same position as the first point in the following segment. This results in a sequence of points, some of which are along the line and some of which are not. For polybeziers with cubic segments, there are two points outside the path between each pair of points along the path. For this reason instead of viewing the polybezier as a sequence of bezier segments, they are often seen as a sequence of vertices and tangents. The vertices are the points along the path, which correspond to the end points of the segments. Each point has two tangents associated with them, one \"in\" thangent, and one \"out\" tangent. The \"out\" tangent is the second point defining the bezier segment following the vertex and the \"in\" tangent is the third point defining the bezier segment coming into the vertex. Beziers in Lottie An shape in Lotttie is represented as a cubic polybezier and it's represented in the JSON as an object with the following attributes: v is an array of vertices. i is an array of \"in\" tangent points, relative to v . o is an array of \"out\" tangent points, relative to v . c is a boolean determining whether the polybezier is closed. If it is, there's an additional bezier segment between the last point in v and the first. BezierPreviewEditor.stand_alone(document.getElementById(\"editor_76\"), (lottie) => { var raw_json = JSON.stringify(lottie, undefined, 4); var pretty_json = hljs.highlight(\"json\", raw_json).value; document.getElementById(\"json_viewer_76\").innerHTML = pretty_json; }, );","title":"Bezier Curves"},{"location":"breakdown/bezier/#bezier-curves","text":"var lottie_player_74 = new LottiePlayer( 'lottie_target_74', '../../static/examples/bezier_expression.json', true, {} );","title":"Bezier Curves"},{"location":"breakdown/bezier/#introduction-to-beziers","text":"Bezier curves are a common way of approximating arbitrary shapes in computer graphics. They represent an arc of a polynomial, and they can be of any degree, but usually you will mostly find quadratic and cubic beziers. Lottie only deals in cubic beziers so we'll focus on those. A bezier curve of degree n is defined by n +1 points. The first and the last of such points will lay on the curve, while the others define the shape of the segment. So for the case of a cubic bezier (degree 3) you have 4 points. To find a point on a bezier, you usually define it as the result of an interpolation within the polynomial curve. The interpolation factor is usually referred to as t . The easiest way of calculating the poition of a point in a bezier given a t is to perform linear interpolations between the bezier points, each step reducing the curve to one with a degree less than the previous, until you end up with a final point. For example in the cubic case, you interpolate each cubic point with the next, resulting in 3 quadratic points. You repeat the process on these 3 points, and you end up with 2 other points. Finally you perform linear interpolation between the two to get the result. In the example below you can control the t value to see how this algorithm works. The black dots are the ones that define the bezier, and the red dot is the position along the bezier at the given t . var lottie_player_75 = new PlaygroundPlayer( 75, 'playground_75_1', 'lottie_target_75', {\"nm\": \"Animation\", \"fr\": 60, \"ip\": 0, \"op\": 280, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [], \"chars\": [], \"layers\": [{\"nm\": \"Shapes\", \"ddd\": 0, \"hd\": false, \"ks\": {}, \"ao\": 0, \"ip\": 0, \"op\": 280, \"st\": 0, \"hasMask\": false, \"masksProperties\": [], \"ef\": [{\"ef\": [{\"ty\": 0, \"nm\": \"Slider\", \"v\": {\"a\": 1, \"k\": [{\"t\": 0, \"i\": {\"x\": [0.667], \"y\": [1]}, \"o\": {\"x\": [0.333], \"y\": [0]}, \"s\": [0]}, {\"t\": 120, \"i\": {\"x\": [0.667], \"y\": [1]}, \"o\": {\"x\": [0.333], \"y\": [0]}, \"s\": [1]}, {\"t\": 140, \"i\": {\"x\": [0.667], \"y\": [1]}, \"o\": {\"x\": [0.333], \"y\": [0]}, \"s\": [1]}, {\"t\": 260, \"s\": [0]}]}}], \"ty\": 5, \"nm\": \"Slider\"}], \"mb\": false, \"ty\": 4, \"shapes\": [{\"nm\": \"Bezier Point\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"nm\": \"p0\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [25, 400], \"x\": \"var group = thisLayer.content(\\\"Linear Points\\\");\\nvar pt_index = 0;\\nvar pt_from = group.content(\\\"p\\\"+pt_index).position;\\nvar pt_to = group.content(\\\"p\\\"+(pt_index+1)).position;\\nvar t = thisLayer.effect(\\\"Slider\\\")(\\\"Slider\\\");\\nvar $bm_rt = linear(t, pt_from, pt_to);\\n\"}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"hd\": false, \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.125, 0]}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Linear Points\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"nm\": \"p0\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [25, 400], \"x\": \"var group = thisLayer.content(\\\"Quadratic Points\\\");\\nvar pt_index = 0;\\nvar pt_from = group.content(\\\"p\\\"+pt_index).position;\\nvar pt_to = group.content(\\\"p\\\"+(pt_index+1)).position;\\nvar t = thisLayer.effect(\\\"Slider\\\")(\\\"Slider\\\");\\nvar $bm_rt = linear(t, pt_from, pt_to);\\n\"}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"nm\": \"p1\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [130, 170], \"x\": \"var group = thisLayer.content(\\\"Quadratic Points\\\");\\nvar pt_index = 1;\\nvar pt_from = group.content(\\\"p\\\"+pt_index).position;\\nvar pt_to = group.content(\\\"p\\\"+(pt_index+1)).position;\\nvar t = thisLayer.effect(\\\"Slider\\\")(\\\"Slider\\\");\\nvar $bm_rt = linear(t, pt_from, pt_to);\\n\"}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"hd\": false, \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.8, 0]}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Linear Lines\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"ty\": \"sh\", \"ks\": {\"a\": 0, \"k\": {\"i\": [], \"o\": [], \"v\": []}, \"x\": \"var group = thisLayer.content(\\\"Linear Points\\\");\\nvar num_points = 2;\\nvar points = [];\\nvar ip = [];\\nvar op = [];\\nfor ( var i = 0; i < num_points; i++ )\\n{\\n var pos = group.content(\\\"p\\\" + i).position;\\n points.push(pos);\\n ip.push(pos);\\n op.push(pos);\\n}\\nvar $bm_rt = {\\n v: points,\\n i: ip,\\n o: op\\n};\\n\"}}, {\"hd\": false, \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [1, 0.8, 0]}, \"w\": {\"a\": 0, \"k\": 10}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Quadratic Points\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"nm\": \"p0\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [25, 400], \"x\": \"var group = thisLayer.content(\\\"Cubic Points\\\");\\nvar pt_index = 0;\\nvar pt_from = group.content(\\\"p\\\"+pt_index).position;\\nvar pt_to = group.content(\\\"p\\\"+(pt_index+1)).position;\\nvar t = thisLayer.effect(\\\"Slider\\\")(\\\"Slider\\\");\\nvar $bm_rt = linear(t, pt_from, pt_to);\\n\"}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"nm\": \"p1\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [130, 170], \"x\": \"var group = thisLayer.content(\\\"Cubic Points\\\");\\nvar pt_index = 1;\\nvar pt_from = group.content(\\\"p\\\"+pt_index).position;\\nvar pt_to = group.content(\\\"p\\\"+(pt_index+1)).position;\\nvar t = thisLayer.effect(\\\"Slider\\\")(\\\"Slider\\\");\\nvar $bm_rt = linear(t, pt_from, pt_to);\\n\"}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"nm\": \"p2\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [350, 230], \"x\": \"var group = thisLayer.content(\\\"Cubic Points\\\");\\nvar pt_index = 2;\\nvar pt_from = group.content(\\\"p\\\"+pt_index).position;\\nvar pt_to = group.content(\\\"p\\\"+(pt_index+1)).position;\\nvar t = thisLayer.effect(\\\"Slider\\\")(\\\"Slider\\\");\\nvar $bm_rt = linear(t, pt_from, pt_to);\\n\"}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"hd\": false, \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.2, 0.2, 1]}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Quadratic Lines\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"ty\": \"sh\", \"ks\": {\"a\": 0, \"k\": {\"i\": [], \"o\": [], \"v\": []}, \"x\": \"var group = thisLayer.content(\\\"Quadratic Points\\\");\\nvar num_points = 3;\\nvar points = [];\\nvar ip = [];\\nvar op = [];\\nfor ( var i = 0; i < num_points; i++ )\\n{\\n var pos = group.content(\\\"p\\\" + i).position;\\n points.push(pos);\\n ip.push(pos);\\n op.push(pos);\\n}\\nvar $bm_rt = {\\n v: points,\\n i: ip,\\n o: op\\n};\\n\"}}, {\"hd\": false, \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0.2, 0.2, 1]}, \"w\": {\"a\": 0, \"k\": 10}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Cubic Points\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"nm\": \"p0\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [25, 400]}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"nm\": \"p1\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [130, 170]}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"nm\": \"p2\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [350, 230]}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"nm\": \"p3\", \"hd\": false, \"ty\": \"el\", \"p\": {\"a\": 0, \"k\": [485, 400]}, \"s\": {\"a\": 0, \"k\": [32, 32]}}, {\"hd\": false, \"ty\": \"fl\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0, 0]}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Cubic Lines\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"ty\": \"sh\", \"ks\": {\"a\": 0, \"k\": {\"i\": [], \"o\": [], \"v\": []}, \"x\": \"var group = thisLayer.content(\\\"Cubic Points\\\");\\nvar num_points = 4;\\nvar points = [];\\nvar ip = [];\\nvar op = [];\\nfor ( var i = 0; i < num_points; i++ )\\n{\\n var pos = group.content(\\\"p\\\" + i).position;\\n points.push(pos);\\n ip.push(pos);\\n op.push(pos);\\n}\\nvar $bm_rt = {\\n v: points,\\n i: ip,\\n o: op\\n};\\n\"}}, {\"hd\": false, \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0, 0]}, \"w\": {\"a\": 0, \"k\": 10}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}, {\"nm\": \"Bezier Result\", \"hd\": false, \"ty\": \"gr\", \"it\": [{\"ty\": \"sh\", \"ks\": {\"a\": 0, \"k\": {\"i\": [], \"o\": [], \"v\": []}, \"x\": \"var group = thisLayer.content(\\\"Cubic Points\\\");\\nvar $bm_rt = {\\n v: [group.content(\\\"p0\\\").position, group.content(\\\"p3\\\").position],\\n i: [[0, 0], group.content(\\\"p2\\\").position],\\n o: [group.content(\\\"p1\\\").position, [0,0]]\\n};\\n\"}}, {\"hd\": false, \"ty\": \"st\", \"o\": {\"a\": 0, \"k\": 100}, \"c\": {\"a\": 0, \"k\": [0, 0.8, 0]}, \"w\": {\"a\": 0, \"k\": 10}}, {\"hd\": false, \"ty\": \"tr\", \"s\": {\"a\": 0, \"k\": [100, 100]}, \"o\": {\"a\": 0, \"k\": 100}}]}]}]}, function (lottie, data) { }, {} ); lottie.layers[0].ef[0].ef[0].v.a = 0; lottie.layers[0].ef[0].ef[0].v.k = data[\"t\"];","title":"Introduction to Beziers"},{"location":"breakdown/bezier/#poly-beziers","text":"Usually shapes are defined as a polybezier, which is the a concept equivalent to polygons, but with bezier segments as their edges. Each bezier segment has its last point in the same position as the first point in the following segment. This results in a sequence of points, some of which are along the line and some of which are not. For polybeziers with cubic segments, there are two points outside the path between each pair of points along the path. For this reason instead of viewing the polybezier as a sequence of bezier segments, they are often seen as a sequence of vertices and tangents. The vertices are the points along the path, which correspond to the end points of the segments. Each point has two tangents associated with them, one \"in\" thangent, and one \"out\" tangent. The \"out\" tangent is the second point defining the bezier segment following the vertex and the \"in\" tangent is the third point defining the bezier segment coming into the vertex.","title":"Poly Beziers"},{"location":"breakdown/bezier/#beziers-in-lottie","text":"An shape in Lotttie is represented as a cubic polybezier and it's represented in the JSON as an object with the following attributes: v is an array of vertices. i is an array of \"in\" tangent points, relative to v . o is an array of \"out\" tangent points, relative to v . c is a boolean determining whether the polybezier is closed. If it is, there's an additional bezier segment between the last point in v and the first. BezierPreviewEditor.stand_alone(document.getElementById(\"editor_76\"), (lottie) => { var raw_json = JSON.stringify(lottie, undefined, 4); var pretty_json = hljs.highlight(\"json\", raw_json).value; document.getElementById(\"json_viewer_76\").innerHTML = pretty_json; }, );","title":"Beziers in Lottie"},{"location":"breakdown/bouncy_ball/","text":"Bouncy Ball This page will show the basics of Lottie by inspecting this simple animation: var lottie_player_77 = new LottiePlayer( 'lottie_target_77', '../../static/examples/bouncy_ball.json', true, {} ); Note that Lottie files usually have their JSON minified, but the example files here have been expanded for ease of inspection. This dissection is not meant to be a complete description, so certain attributes will not be described but each section will have links to the relevant reference pages where you can find a description for those. Top level The top level object, describes the animation as a whole. { \"nm\": \"Bouncy Ball\", \"v\": \"5.5.2\", \"ip\": 0, \"op\": 120, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ ... ] } Here we see the basic properties: nm is the name of the document, it's not actually used by players. v shows the Lottie format version, some older files might have a slightly different structure. fr is the framerate in frames per second. Note that most timing information is described in frames within Lottie, so changing the framerate means the duration of the animation will also change. op is the last frame of the animation, after which the animation will loop or stop, depending on how the player is set up. In this case 120 frames at 60 fps will result in 2 seconds of animation. ip marks the first frame of the animation, usually it's set to 0 . w and h describe the width and height of the animation, any content outside the box starting at (0, 0) and ending at (w, h) will not be visible. Note that a lottie file is a vector format and can be scaled up and down. So you shouldn't think of these values as a size in pixels. Layers Now we look at the layers . Most file will be more complex than this and have multiple layers but here we only have one: { \"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 120, \"nm\": \"Layer\", \"ks\": { ... }, \"shapes\": [...] } We see the layer can also have a name ( nm ). You might note that ip and op have the same values as in the animation. This means the layer will always be visible. You can decide to show a layer only for a small amount of time, in which case you would set ip to the first frame the layer should be visible at and op to the last frame, and the layer will only be visible between those frames. ddd is a boolean value that indicates whether this layer contains 3D elements. ty is the layer type. In this case it's a shape layer . Finally ind is a unique number used to reference this layer. Here it's not being used since there is only one layer. Layer transform Here we'll have a look at the ks attribute of the layer that represents its transform : { \"a\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"s\": { \"a\": 0, \"k\": [ 100, 100 ] }, \"r\": { \"a\": 0, \"k\": 0 }, \"o\": { \"a\": 0, \"k\": 100 } } This layer does not have any transform so everything is at its default value. (If you see a transform missing some attributes, you can assume they have the values above) You might have noticed that all the attributes of the transform are objects with the same structure. This is because they are animatable properties . In this case they don't have any animations applied to them so a is 0 and k is the actual value. If they were animated, a would be 1 and k would have a list of keyframes (more on this later). The animated properties of a transform are as follows: a is the anchor point along which other transformations are applied (you can think of it as the center of rotation). p is the position (translation). Both a and p have arrays as values representing 2D coordinates. s is the scale and, similar to a and p , its value has 2 components. Note that values are expressed as percentages ( 100 meaning 100% or no scaling). r is the rotation angle in degrees. o is opacity, similar to s , it also is expressed as a percentage. You might also find sk and sa in a transform object, determining the skew. Shapes Since this is a shape layer, it contains a list of shapes. In this case there is only one shape: { \"ty\": \"gr\", \"nm\": \"Ellipse Group\", \"it\": [ ... ] } ty represents the type of the shape, in this case it's a group , which is simply a shape that contains other shapes. Groups add another layer of organization: you have layers at the top, shape layers can contain group shapes, and groups can contain other groups. nm is the name, same as before. it is the list of shapes within the group, we will inspect them one by one Ellipse { \"ty\": \"el\", \"nm\": \"Ellipse\", \"p\": { \"a\": 0, \"k\": [ 204, 169 ] }, \"s\": { \"a\": 0, \"k\": [ 153, 153 ] } } The first shape in the group is an ellipse (denoted by \"ty\": \"el\" ). It has two properties: position ( p ) and size ( s ). The position determines the center of the ellipse and size its two axes. In this case we can tell it's a circle since both values in s are the same. Fill { \"ty\": \"fl\", \"nm\": \"Fill\", \"o\": { \"a\": 0, \"k\": 100 }, \"c\": { \"a\": 0, \"k\": [ 0.710, 0.192, 0.278 ] }, \"r\": 1 } An ellipse by itself doesn't actually draw anything. it just defines the shape. So we need to apply some style to it. Here we have a fill shape that determines the fill color for the ellipse. r is not animated and it determines the fill rule . o is the opacity, as a percentage. c is a Color . Colors are RGB triplets with components in [0, 1] . In this case it represents this color: [0.71, 0.192, 0.278] . Transform { \"ty\": \"tr\", \"a\": { \"a\": 0, \"k\": [ 204, 169 ] }, \"p\": { ... }, \"s\": { ... }, \"r\": { \"a\": 0, \"k\": 0 }, \"o\": { \"a\": 0, \"k\": 100 } } Unlike layers, that have the transform as an attribute, groups have them as a shape . Note that this might give you a false sense of flexibility, because players expect to have a transform shape at the end of their shape list. The attributes are the same as the layer transform, with the addition of ty to represent the shape type. Here position ( p ) and scale ( s ) are animated and we'll look into them separately: Animated Position { \"a\": 1, \"k\": [ { \"t\": 0, \"s\": [ 235, 106 ], \"h\": 0, \"o\": { \"x\": [ 0.333 ], \"y\": [ 0 ] }, \"i\": { \"x\": [ 1 ], \"y\": [ 1 ] } }, { \"t\": 60, \"s\": [ 235, 441 ], \"h\": 0, \"o\": { \"x\": [ 0 ], \"y\": [ 0 ] }, \"i\": { \"x\": [ 0.667 ], \"y\": [ 1 ] } }, { \"t\": 120, \"s\": [ 235, 106 ] } ] } a is 1 , denoting the property is animated. k contains a list of keyframe . First Keyframe { \"t\": 0, \"s\": [ 235, 106 ], \"h\": 0, \"o\": { \"x\": [ 0.333 ], \"y\": [ 0 ] }, \"i\": { \"x\": [ 1 ], \"y\": [ 1 ] } } The first keyframe specifies the time at which the property starts being animated. In this case t is 0 , meaning the animation starts right away. s shows the value the property will have at t . o and i specify the easing function . o affects the movement at the beginning of the keyframe and i at the end. In this case, it uses an \"ease in\" kind of curve, where the animation starts slowly and it picks up speed at the end. Second Keyframe { \"t\": 60, \"s\": [ 235, 441 ], \"h\": 0, \"o\": { \"x\": [ 0 ], \"y\": [ 0 ] }, \"i\": { \"x\": [ 0.667 ], \"y\": [ 1 ] } } Here is the second keyframe, t is 60 which is the half way point of the animation. You can compare s with the previous keyframe to see how the position is affected. In this case it went from [235, 106] to [235, 441] , meaning the ball has moved down. i and o are set up for an \"ease out\" curve, meaning the animation starts quick but eventually it slows down. Last Keyframe { \"t\": 120, \"s\": [ 235, 106 ] } The last keyframe is at the end of the animation ( t is 100 ). It doesn't have easing information because there are no more keyframes after this. The value of s is the same as in the first keyframe, this allows for a seamless loop. Animated scale { \"a\": 1, \"k\": [ { \"t\": 55, \"s\": [ 100, 100 ], \"h\": 0, \"o\": { \"x\": [ 0 ], \"y\": [ 0 ] }, \"i\": { \"x\": [ 1 ], \"y\": [ 1 ] } }, { \"t\": 60, \"s\": [ 136, 59 ], \"h\": 0, \"o\": { \"x\": [ 0 ], \"y\": [ 0 ] }, \"i\": { \"x\": [ 1 ], \"y\": [ 1 ] } }, { \"t\": 65, \"s\": [ 100, 100 ] } ] } This provides the \"squishing\" effect. The works the same as the animated position described above. One thing to note is the first and last keyframe have t that doesn't match with the ip and op of the animation. This mean the property will maintain its value on the time before the first keyframe and after the last one.","title":"Bouncy Ball"},{"location":"breakdown/bouncy_ball/#bouncy-ball","text":"This page will show the basics of Lottie by inspecting this simple animation: var lottie_player_77 = new LottiePlayer( 'lottie_target_77', '../../static/examples/bouncy_ball.json', true, {} ); Note that Lottie files usually have their JSON minified, but the example files here have been expanded for ease of inspection. This dissection is not meant to be a complete description, so certain attributes will not be described but each section will have links to the relevant reference pages where you can find a description for those.","title":"Bouncy Ball"},{"location":"breakdown/bouncy_ball/#top-level","text":"The top level object, describes the animation as a whole. { \"nm\": \"Bouncy Ball\", \"v\": \"5.5.2\", \"ip\": 0, \"op\": 120, \"fr\": 60, \"w\": 512, \"h\": 512, \"layers\": [ ... ] } Here we see the basic properties: nm is the name of the document, it's not actually used by players. v shows the Lottie format version, some older files might have a slightly different structure. fr is the framerate in frames per second. Note that most timing information is described in frames within Lottie, so changing the framerate means the duration of the animation will also change. op is the last frame of the animation, after which the animation will loop or stop, depending on how the player is set up. In this case 120 frames at 60 fps will result in 2 seconds of animation. ip marks the first frame of the animation, usually it's set to 0 . w and h describe the width and height of the animation, any content outside the box starting at (0, 0) and ending at (w, h) will not be visible. Note that a lottie file is a vector format and can be scaled up and down. So you shouldn't think of these values as a size in pixels.","title":"Top level"},{"location":"breakdown/bouncy_ball/#layers","text":"Now we look at the layers . Most file will be more complex than this and have multiple layers but here we only have one: { \"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 120, \"nm\": \"Layer\", \"ks\": { ... }, \"shapes\": [...] } We see the layer can also have a name ( nm ). You might note that ip and op have the same values as in the animation. This means the layer will always be visible. You can decide to show a layer only for a small amount of time, in which case you would set ip to the first frame the layer should be visible at and op to the last frame, and the layer will only be visible between those frames. ddd is a boolean value that indicates whether this layer contains 3D elements. ty is the layer type. In this case it's a shape layer . Finally ind is a unique number used to reference this layer. Here it's not being used since there is only one layer.","title":"Layers"},{"location":"breakdown/bouncy_ball/#layer-transform","text":"Here we'll have a look at the ks attribute of the layer that represents its transform : { \"a\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"p\": { \"a\": 0, \"k\": [ 0, 0 ] }, \"s\": { \"a\": 0, \"k\": [ 100, 100 ] }, \"r\": { \"a\": 0, \"k\": 0 }, \"o\": { \"a\": 0, \"k\": 100 } } This layer does not have any transform so everything is at its default value. (If you see a transform missing some attributes, you can assume they have the values above) You might have noticed that all the attributes of the transform are objects with the same structure. This is because they are animatable properties . In this case they don't have any animations applied to them so a is 0 and k is the actual value. If they were animated, a would be 1 and k would have a list of keyframes (more on this later). The animated properties of a transform are as follows: a is the anchor point along which other transformations are applied (you can think of it as the center of rotation). p is the position (translation). Both a and p have arrays as values representing 2D coordinates. s is the scale and, similar to a and p , its value has 2 components. Note that values are expressed as percentages ( 100 meaning 100% or no scaling). r is the rotation angle in degrees. o is opacity, similar to s , it also is expressed as a percentage. You might also find sk and sa in a transform object, determining the skew.","title":"Layer transform"},{"location":"breakdown/bouncy_ball/#shapes","text":"Since this is a shape layer, it contains a list of shapes. In this case there is only one shape: { \"ty\": \"gr\", \"nm\": \"Ellipse Group\", \"it\": [ ... ] } ty represents the type of the shape, in this case it's a group , which is simply a shape that contains other shapes. Groups add another layer of organization: you have layers at the top, shape layers can contain group shapes, and groups can contain other groups. nm is the name, same as before. it is the list of shapes within the group, we will inspect them one by one","title":"Shapes"},{"location":"breakdown/bouncy_ball/#ellipse","text":"{ \"ty\": \"el\", \"nm\": \"Ellipse\", \"p\": { \"a\": 0, \"k\": [ 204, 169 ] }, \"s\": { \"a\": 0, \"k\": [ 153, 153 ] } } The first shape in the group is an ellipse (denoted by \"ty\": \"el\" ). It has two properties: position ( p ) and size ( s ). The position determines the center of the ellipse and size its two axes. In this case we can tell it's a circle since both values in s are the same.","title":"Ellipse"},{"location":"breakdown/bouncy_ball/#fill","text":"{ \"ty\": \"fl\", \"nm\": \"Fill\", \"o\": { \"a\": 0, \"k\": 100 }, \"c\": { \"a\": 0, \"k\": [ 0.710, 0.192, 0.278 ] }, \"r\": 1 } An ellipse by itself doesn't actually draw anything. it just defines the shape. So we need to apply some style to it. Here we have a fill shape that determines the fill color for the ellipse. r is not animated and it determines the fill rule . o is the opacity, as a percentage. c is a Color . Colors are RGB triplets with components in [0, 1] . In this case it represents this color: [0.71, 0.192, 0.278] .","title":"Fill"},{"location":"breakdown/bouncy_ball/#transform","text":"{ \"ty\": \"tr\", \"a\": { \"a\": 0, \"k\": [ 204, 169 ] }, \"p\": { ... }, \"s\": { ... }, \"r\": { \"a\": 0, \"k\": 0 }, \"o\": { \"a\": 0, \"k\": 100 } } Unlike layers, that have the transform as an attribute, groups have them as a shape . Note that this might give you a false sense of flexibility, because players expect to have a transform shape at the end of their shape list. The attributes are the same as the layer transform, with the addition of ty to represent the shape type. Here position ( p ) and scale ( s ) are animated and we'll look into them separately:","title":"Transform"},{"location":"breakdown/bouncy_ball/#animated-position","text":"{ \"a\": 1, \"k\": [ { \"t\": 0, \"s\": [ 235, 106 ], \"h\": 0, \"o\": { \"x\": [ 0.333 ], \"y\": [ 0 ] }, \"i\": { \"x\": [ 1 ], \"y\": [ 1 ] } }, { \"t\": 60, \"s\": [ 235, 441 ], \"h\": 0, \"o\": { \"x\": [ 0 ], \"y\": [ 0 ] }, \"i\": { \"x\": [ 0.667 ], \"y\": [ 1 ] } }, { \"t\": 120, \"s\": [ 235, 106 ] } ] } a is 1 , denoting the property is animated. k contains a list of keyframe .","title":"Animated Position"},{"location":"breakdown/bouncy_ball/#first-keyframe","text":"{ \"t\": 0, \"s\": [ 235, 106 ], \"h\": 0, \"o\": { \"x\": [ 0.333 ], \"y\": [ 0 ] }, \"i\": { \"x\": [ 1 ], \"y\": [ 1 ] } } The first keyframe specifies the time at which the property starts being animated. In this case t is 0 , meaning the animation starts right away. s shows the value the property will have at t . o and i specify the easing function . o affects the movement at the beginning of the keyframe and i at the end. In this case, it uses an \"ease in\" kind of curve, where the animation starts slowly and it picks up speed at the end.","title":"First Keyframe"},{"location":"breakdown/bouncy_ball/#second-keyframe","text":"{ \"t\": 60, \"s\": [ 235, 441 ], \"h\": 0, \"o\": { \"x\": [ 0 ], \"y\": [ 0 ] }, \"i\": { \"x\": [ 0.667 ], \"y\": [ 1 ] } } Here is the second keyframe, t is 60 which is the half way point of the animation. You can compare s with the previous keyframe to see how the position is affected. In this case it went from [235, 106] to [235, 441] , meaning the ball has moved down. i and o are set up for an \"ease out\" curve, meaning the animation starts quick but eventually it slows down.","title":"Second Keyframe"},{"location":"breakdown/bouncy_ball/#last-keyframe","text":"{ \"t\": 120, \"s\": [ 235, 106 ] } The last keyframe is at the end of the animation ( t is 100 ). It doesn't have easing information because there are no more keyframes after this. The value of s is the same as in the first keyframe, this allows for a seamless loop.","title":"Last Keyframe"},{"location":"breakdown/bouncy_ball/#animated-scale","text":"{ \"a\": 1, \"k\": [ { \"t\": 55, \"s\": [ 100, 100 ], \"h\": 0, \"o\": { \"x\": [ 0 ], \"y\": [ 0 ] }, \"i\": { \"x\": [ 1 ], \"y\": [ 1 ] } }, { \"t\": 60, \"s\": [ 136, 59 ], \"h\": 0, \"o\": { \"x\": [ 0 ], \"y\": [ 0 ] }, \"i\": { \"x\": [ 1 ], \"y\": [ 1 ] } }, { \"t\": 65, \"s\": [ 100, 100 ] } ] } This provides the \"squishing\" effect. The works the same as the animated position described above. One thing to note is the first and last keyframe have t that doesn't match with the ip and op of the animation. This mean the property will maintain its value on the time before the first keyframe and after the last one.","title":"Animated scale"},{"location":"breakdown/lottie_from_scratch/","text":"Lottie from Scratch In this example, we'll build a simple Lottie animation from scratch. Introducing the builder tool The builder tool allows you to build lottie animations from its JSON components using a more convenient interface than manually editing the cryptic lottie JSON attributes. You can click on the categories on the toolbar to the left of the builder interface then drag and drop blocks into the workspace and see the effects. To the right you have a preview of the animation and the corresponding JSON. The rest of this guide will assume you are following along using the builder. Most block can be right-clicked to bring up a context menu, and you can select \"Help\" from that menu to go on the page that describes the object represented by that block. Setting up Ensure your workspace is empty, if it isn't click on the \"Clear\" button near the top-right. Start by selecting the Animation block in the Animation category and dragging it to the workspace. Then select a Shape Layer (from Layers) and drop it into the Layers slot of the Animation block. Your workspace should look something like this: You might have noticed the block attached to the layer. For simplicity all the common layer properties are in a separate block in the builder, this allows you to duplicate those blocks to copy the settings across layers and the block is collapsed by default to avoid cluttering the workspace. View workspace at the end of this step Adding Shapes In order to show something, we need to add some shapes to the layer. So let's add a Polystar, a Fill and a Stroke from the Shapes category. Note that the order is important: This should result in a black pentagon showing in the corner. View workspace at the end of this step Basic Properties We start by moving our shape in a more sensible position. To do so, select Static Property and connect it to the \"Position\" of the Polystar, then connect a \"x y\" block to it. Both these blocks are under \"Properties\". You can now edit the values of x and y to move the pentagon. For example, setting them both to 256 should move the shape to the center of the screen: You can do something similar to modify the size of the pentagon and the fill color, of course you need to select the right block types from the properties toolbox. The color can be changed by manually updating the RGB components or by selecting a color from the palette shown after clicking the color preview on the block. View workspace at the end of this step Making a Star We can turn the pentagon into a star by changing the star type and filling in some more properties: Note that while you can use just a number block for \"Rotation\", using the angle block allows you to edit the angle in a more intuitive way. You can tell these block apart because they are a different color and the angle block shows the \u00b0 symbol. View workspace at the end of this step Animating the Star Until now, we've only seen static properties, but now we can have a look at some animated ones. To animate the star rotation, we need to first disconnect the static property from it and connect an animated property in its place. Thne attach two keyframe blocks to the animated property. Once the keyframes are added, attach angle blocks to their value slots and change the second keyframe to have a time of 60 and a value of 72\u00b0. You should now see the star spinning in the preview. View workspace at the end of this step Making the Animation longer Currently, the animation lasts for 1 second (60 frames). If you want it to last for longer, you need to first change the Out Point in the animation block. Let's change it to 120 to make the animation last for 2 seconds. You'll see the star starts blinking, disappearing after a second and reappearing after another second. This is because we also need to update the layer Out Point. By default, the layer properties are collapsed, so right-click on the Layer Properties and select \"Expand Block\" from the context menu, then change its \"Out Point\" to match with the Animation block. Now the star remains visible the whole time, but it stops rotating at the second mark. To fix that you can update the second keyframe in the star rotation to have a time of 120. Alternatively you can add a third keyframe with that time and an appropriate value. View the final workspace","title":"Lottie from Scratch"},{"location":"breakdown/lottie_from_scratch/#lottie-from-scratch","text":"In this example, we'll build a simple Lottie animation from scratch.","title":"Lottie from Scratch"},{"location":"breakdown/lottie_from_scratch/#introducing-the-builder-tool","text":"The builder tool allows you to build lottie animations from its JSON components using a more convenient interface than manually editing the cryptic lottie JSON attributes. You can click on the categories on the toolbar to the left of the builder interface then drag and drop blocks into the workspace and see the effects. To the right you have a preview of the animation and the corresponding JSON. The rest of this guide will assume you are following along using the builder. Most block can be right-clicked to bring up a context menu, and you can select \"Help\" from that menu to go on the page that describes the object represented by that block.","title":"Introducing the builder tool"},{"location":"breakdown/lottie_from_scratch/#setting-up","text":"Ensure your workspace is empty, if it isn't click on the \"Clear\" button near the top-right. Start by selecting the Animation block in the Animation category and dragging it to the workspace. Then select a Shape Layer (from Layers) and drop it into the Layers slot of the Animation block. Your workspace should look something like this: You might have noticed the block attached to the layer. For simplicity all the common layer properties are in a separate block in the builder, this allows you to duplicate those blocks to copy the settings across layers and the block is collapsed by default to avoid cluttering the workspace. View workspace at the end of this step","title":"Setting up"},{"location":"breakdown/lottie_from_scratch/#adding-shapes","text":"In order to show something, we need to add some shapes to the layer. So let's add a Polystar, a Fill and a Stroke from the Shapes category. Note that the order is important: This should result in a black pentagon showing in the corner. View workspace at the end of this step","title":"Adding Shapes"},{"location":"breakdown/lottie_from_scratch/#basic-properties","text":"We start by moving our shape in a more sensible position. To do so, select Static Property and connect it to the \"Position\" of the Polystar, then connect a \"x y\" block to it. Both these blocks are under \"Properties\". You can now edit the values of x and y to move the pentagon. For example, setting them both to 256 should move the shape to the center of the screen: You can do something similar to modify the size of the pentagon and the fill color, of course you need to select the right block types from the properties toolbox. The color can be changed by manually updating the RGB components or by selecting a color from the palette shown after clicking the color preview on the block. View workspace at the end of this step","title":"Basic Properties"},{"location":"breakdown/lottie_from_scratch/#making-a-star","text":"We can turn the pentagon into a star by changing the star type and filling in some more properties: Note that while you can use just a number block for \"Rotation\", using the angle block allows you to edit the angle in a more intuitive way. You can tell these block apart because they are a different color and the angle block shows the \u00b0 symbol. View workspace at the end of this step","title":"Making a Star"},{"location":"breakdown/lottie_from_scratch/#animating-the-star","text":"Until now, we've only seen static properties, but now we can have a look at some animated ones. To animate the star rotation, we need to first disconnect the static property from it and connect an animated property in its place. Thne attach two keyframe blocks to the animated property. Once the keyframes are added, attach angle blocks to their value slots and change the second keyframe to have a time of 60 and a value of 72\u00b0. You should now see the star spinning in the preview. View workspace at the end of this step","title":"Animating the Star"},{"location":"breakdown/lottie_from_scratch/#making-the-animation-longer","text":"Currently, the animation lasts for 1 second (60 frames). If you want it to last for longer, you need to first change the Out Point in the animation block. Let's change it to 120 to make the animation last for 2 seconds. You'll see the star starts blinking, disappearing after a second and reappearing after another second. This is because we also need to update the layer Out Point. By default, the layer properties are collapsed, so right-click on the Layer Properties and select \"Expand Block\" from the context menu, then change its \"Out Point\" to match with the Animation block. Now the star remains visible the whole time, but it stops rotating at the second mark. To fix that you can update the second keyframe in the star rotation to have a time of 120. Alternatively you can add a third keyframe with that time and an appropriate value. View the final workspace","title":"Making the Animation longer"},{"location":"breakdown/precomps/","text":"Precompositions This page will explain Precompositions (or precomps for short), which are a defining feature of the Lottie format which allows for great flexibility in effects and organization of animation files. What are Precompositions? In short, a precomposition is an animation embedded inside another animation, of which you can control playback. Once you have a precomposition, you can use layers to reference it in various parts of the animation to avoid repeating elements. How do Precompositions work in a Lottie? The main object is the Precomposition Asset . Its structure is very simple, just an asset identifier and a list of layers. By itself a precomposition asset doesn't do much, it needs to be referenced by a Precomposition Layer . You can think of the precomp asset to be similar to a video asset, and the layer plays back the animation defined by that asset. Follows a simple example: First we start with a file without precomps: var lottie_player_78 = new LottiePlayer( 'lottie_target_78', '../../static/examples/precomp/star-nocomp.json', true, {} ); And the same animation but using a precomp: var lottie_player_79 = new LottiePlayer( 'lottie_target_79', '../../static/examples/precomp/star-comp.json', true, {} ); Now let's have a look at how the JSON changed: This is the original animation, nothing special about it: { \"nm\": \"Animation\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [ { \"nm\": \"Shape Layer\", \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"ks\": {}, \"shapes\": [/* ... */] } ] } And this is the version using a precomposition: { \"nm\": \"Animation\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [ { \"id\": \"Star\", \"layers\": [ { \"nm\": \"Shape Layer\", \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"shapes\": [/* ... */] } ] } ], \"layers\": [ { \"nm\": \"Precomp Layer\", \"refId\": \"Star\" \"ty\": 0, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {} } ], } As you can see, the layers in the original animation have been moved to an asset (in this example there was only one layer but it works the same when you have multiple layer). And in layers of the outer animation there is a single layer referencing the new asset. The structure of the asset is fairly straightforward: a unique identifier ( Star in the example) and the list of layers in the precomposition. The layer has the usual attributes you can find on visual layers and a couple others: refId is the identifier of the precomp the layer is referencing, w and h define the clipping rectangle for the composition, in this case they match the value in the outer animation. Important things to note A precomp doesn't contain assets, but it can reference assets defined in the main animation object. It can also reference other precomps. Layer indexes are unique in each composition: you can have a layer with index 0 in multiple precomps and in the main animation, references to these (such as when parenting layers) are relative to the composition. You need to always specify w and h in the precomp layer or nothing will be displayed. What can you do with Precompositions? In this section we'll describe some example use case including the initial animations and the result to compare how a file needs to be changed to obtain certain effects. Resizing If you need to resize an animation, the best way of doing it is by precomposing all its layers and then scale the precomp layer. While for simple examples you'd might be able to get away with scaling all the layers in the original animation, it gets complicated if you have parented layers or transforms applied to some of the layers. Note that in the example below w and h keep their initial value and only the scale is changed. var lottie_player_80 = new PlaygroundPlayer( 80, 'playground_80_1', 'lottie_target_80', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}], \"layers\": [{\"ddd\": 0, \"ty\": 0, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"nm\": \"Precomp Layer\", \"ks\": {}, \"refId\": \"Star\"}], \"meta\": {\"g\": \"Glaxnimate 0.5.0-93-g187709f5\"}}, function (lottie, data) { this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} ); lottie.w = lottie.h = 512 * data[\"Scale\"] / 100; lottie.layers[0].ks.s = { a: 0, k: [ data[\"Scale\"], data[\"Scale\"] ] }; Speeding up and Slowing down Similarly, you can use time stretch to speed up and slow down an animation: var lottie_player_81 = new PlaygroundPlayer( 81, 'playground_81_1', 'lottie_target_81', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}], \"layers\": [{\"ddd\": 0, \"ty\": 0, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"nm\": \"Precomp Layer\", \"ks\": {}, \"refId\": \"Star\"}], \"meta\": {\"g\": \"Glaxnimate 0.5.0-93-g187709f5\"}}, function (lottie, data) { this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} ); var time_mult = 100 / data[\"Speed\"]; lottie.op = 60 * time_mult; lottie.layers[0].op = 60 * time_mult; lottie.layers[0].sr = time_mult; You can also change the start time to delay the start of the precomp playback: var lottie_player_82 = new PlaygroundPlayer( 82, 'playground_82_1', 'lottie_target_82', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}], \"layers\": [{\"ddd\": 0, \"ty\": 0, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"nm\": \"Precomp Layer\", \"ks\": {}, \"refId\": \"Star\"}], \"meta\": {\"g\": \"Glaxnimate 0.5.0-93-g187709f5\"}}, function (lottie, data) { this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} ); var time_mult = 100 / data[\"Speed\"]; var start = data[\"Start\"]; lottie.op = 60 * time_mult + start; lottie.layers[0].op = 60 * time_mult + start; lottie.layers[0].sr = time_mult; lottie.layers[0].st = start; Reversing Playback While sr only allows you to speed up and slow down time, with time remapping You can have more interesting effects, such as reversing playback: var lottie_player_83 = new PlaygroundPlayer( 83, 'playground_83_1', 'lottie_target_83', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}], \"layers\": [{\"ddd\": 0, \"ty\": 0, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"nm\": \"Precomp Layer\", \"ks\": {}, \"refId\": \"Star\"}], \"meta\": {\"g\": \"Glaxnimate 0.5.0-93-g187709f5\"}}, function (lottie, data) { this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} ); lottie.layers[0].tm = { a: 1, \"k\": [ { \"t\": 0, \"s\": [1], \"o\": { \"x\": 0, \"y\": 0}, \"i\": { \"x\": 1, \"y\": 1} }, { \"t\": 60, \"s\": [0], \"o\": { \"x\": 0, \"y\": 0}, \"i\": { \"x\": 1, \"y\": 1} } ] }; Repeated Elements Another important use for precomps is that they allow to have multiple layers showing the same precomp. In the following example the star is animated once but there are 8 precomp layers with different rotations: var lottie_player_84 = new LottiePlayer( 'lottie_target_84', '../../static/examples/precomp/star-splosion.json', true, {} ); Overlaying Animations Precomps also make it easier to combine multiple files into ones. One thing to keep in mind is if the two files already have assets, you need to ensure their asset identifier are unique, this can be done by overwriting asset id and layer refId properties to some kind of incremental values. In the following example we will overlay the animation from the last example with a different animation. First Animation: Second Animation: Overlaid: var lottie_player_85 = new PlaygroundPlayer( 85, 'playground_85_1', 'lottie_target_85', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": -45}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}, {\"id\": \"Expanding Stars\", \"layers\": [{\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 0}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 45}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 90}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 135}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 180}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -45}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -90}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -135}}}]}, {\"id\": \"Circle\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Layer\", \"mn\": \"{456fdfe5-686b-4006-92f4-951c47ab4bc7}\", \"ks\": {}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{05d5f1a0-6046-4aea-a405-b9ba60a24bd7}\", \"d\": 1, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0, 0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [730, 730]}]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{d835adb4-6502-4e3e-98c2-70d1145f1a23}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [6], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"c\": {\"a\": 0, \"k\": [0.11372549019607843, 0.1568627450980392, 0.2823529411764706]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{78036603-40f1-42ca-ada5-fee506b4ac58}\", \"o\": {\"a\": 1, \"k\": [{\"t\": 30, \"s\": [100], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}}]}]}], \"layers\": [{\"nm\": \"Expanding Stars Layer\", \"refId\": \"Expanding Stars\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {}}, {\"nm\": \"Circle Layer\", \"refId\": \"Circle\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {}}]}, function (lottie, data) { this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} ); If you look at the JSON you'll notice that this is how the structure changed: // First Animation: { \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [ { \"id\": \"Star\", \"layers\": [ /* Star Precomp Layers */ ] } ], \"layers\": [ /* First Animation Layers */ ] } // Second Animation { \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [ /* Second Animation Layers */ ] } // Overlaid { \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [ { \"id\": \"Star\", \"layers\": [ /* Star Precomp Layers */ ] }, { \"id\": \"Expanding Stars\", \"layers\": [ /* First Animation Layers */ ] }, { \"id\": \"Circle\", \"layers\": [ /* Second Animation Layers */ ] } ], \"layers\": [ { \"nm\": \"Expanding Stars Layer\", \"refId\": \"Expanding Stars\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {} }, { \"nm\": \"Circle Layer\", \"refId\": \"Circle\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {} } ] } In this example the two animations had the same duration and size, you can use the techniques described earlier to resize or retime the animations if you want to overlay animations with different sizes or durations. Concatenating Animations This works basically the same as overlaying them, just by changing some timing properties in the precomp layers. var lottie_player_86 = new PlaygroundPlayer( 86, 'playground_86_1', 'lottie_target_86', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": -45}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}, {\"id\": \"Expanding Stars\", \"layers\": [{\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 0}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 45}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 90}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 135}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 180}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -45}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -90}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -135}}}]}, {\"id\": \"Circle\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Layer\", \"mn\": \"{456fdfe5-686b-4006-92f4-951c47ab4bc7}\", \"ks\": {}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{05d5f1a0-6046-4aea-a405-b9ba60a24bd7}\", \"d\": 1, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0, 0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [730, 730]}]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{d835adb4-6502-4e3e-98c2-70d1145f1a23}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [6], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"c\": {\"a\": 0, \"k\": [0.11372549019607843, 0.1568627450980392, 0.2823529411764706]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{78036603-40f1-42ca-ada5-fee506b4ac58}\", \"o\": {\"a\": 1, \"k\": [{\"t\": 30, \"s\": [100], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}}]}]}], \"layers\": [{\"nm\": \"Expanding Stars Layer\", \"refId\": \"Expanding Stars\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {}}, {\"nm\": \"Circle Layer\", \"refId\": \"Circle\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {}}]}, function (lottie, data) { this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} ); lottie.op = 120 lottie.layers[1].ip = 60; lottie.layers[1].op = 120; lottie.layers[1].st = 60; Masking Animations Just like any other visual layer, precomp layers can be used for mattes . var lottie_player_87 = new PlaygroundPlayer( 87, 'playground_87_1', 'lottie_target_87', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": -45}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}, {\"id\": \"Expanding Stars\", \"layers\": [{\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 0}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 45}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 90}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 135}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 180}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -45}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -90}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -135}}}]}, {\"id\": \"Circle\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Layer\", \"mn\": \"{456fdfe5-686b-4006-92f4-951c47ab4bc7}\", \"ks\": {}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{05d5f1a0-6046-4aea-a405-b9ba60a24bd7}\", \"d\": 1, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0, 0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [730, 730]}]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{d835adb4-6502-4e3e-98c2-70d1145f1a23}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [6], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"c\": {\"a\": 0, \"k\": [0.11372549019607843, 0.1568627450980392, 0.2823529411764706]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{78036603-40f1-42ca-ada5-fee506b4ac58}\", \"o\": {\"a\": 1, \"k\": [{\"t\": 30, \"s\": [100], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}}]}]}], \"layers\": [{\"nm\": \"Expanding Stars Layer\", \"refId\": \"Expanding Stars\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {}}, {\"nm\": \"Circle Layer\", \"refId\": \"Circle\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {}}]}, function (lottie, data) { this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} ); lottie.layers[0].td = 1; lottie.layers[1].tt = 1;","title":"Precompositions"},{"location":"breakdown/precomps/#precompositions","text":"This page will explain Precompositions (or precomps for short), which are a defining feature of the Lottie format which allows for great flexibility in effects and organization of animation files.","title":"Precompositions"},{"location":"breakdown/precomps/#what-are-precompositions","text":"In short, a precomposition is an animation embedded inside another animation, of which you can control playback. Once you have a precomposition, you can use layers to reference it in various parts of the animation to avoid repeating elements.","title":"What are Precompositions?"},{"location":"breakdown/precomps/#how-do-precompositions-work-in-a-lottie","text":"The main object is the Precomposition Asset . Its structure is very simple, just an asset identifier and a list of layers. By itself a precomposition asset doesn't do much, it needs to be referenced by a Precomposition Layer . You can think of the precomp asset to be similar to a video asset, and the layer plays back the animation defined by that asset. Follows a simple example: First we start with a file without precomps: var lottie_player_78 = new LottiePlayer( 'lottie_target_78', '../../static/examples/precomp/star-nocomp.json', true, {} ); And the same animation but using a precomp: var lottie_player_79 = new LottiePlayer( 'lottie_target_79', '../../static/examples/precomp/star-comp.json', true, {} ); Now let's have a look at how the JSON changed: This is the original animation, nothing special about it: { \"nm\": \"Animation\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [ { \"nm\": \"Shape Layer\", \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"ks\": {}, \"shapes\": [/* ... */] } ] } And this is the version using a precomposition: { \"nm\": \"Animation\", \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [ { \"id\": \"Star\", \"layers\": [ { \"nm\": \"Shape Layer\", \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"shapes\": [/* ... */] } ] } ], \"layers\": [ { \"nm\": \"Precomp Layer\", \"refId\": \"Star\" \"ty\": 0, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {} } ], } As you can see, the layers in the original animation have been moved to an asset (in this example there was only one layer but it works the same when you have multiple layer). And in layers of the outer animation there is a single layer referencing the new asset. The structure of the asset is fairly straightforward: a unique identifier ( Star in the example) and the list of layers in the precomposition. The layer has the usual attributes you can find on visual layers and a couple others: refId is the identifier of the precomp the layer is referencing, w and h define the clipping rectangle for the composition, in this case they match the value in the outer animation.","title":"How do Precompositions work in a Lottie?"},{"location":"breakdown/precomps/#important-things-to-note","text":"A precomp doesn't contain assets, but it can reference assets defined in the main animation object. It can also reference other precomps. Layer indexes are unique in each composition: you can have a layer with index 0 in multiple precomps and in the main animation, references to these (such as when parenting layers) are relative to the composition. You need to always specify w and h in the precomp layer or nothing will be displayed.","title":"Important things to note"},{"location":"breakdown/precomps/#what-can-you-do-with-precompositions","text":"In this section we'll describe some example use case including the initial animations and the result to compare how a file needs to be changed to obtain certain effects.","title":"What can you do with Precompositions?"},{"location":"breakdown/precomps/#resizing","text":"If you need to resize an animation, the best way of doing it is by precomposing all its layers and then scale the precomp layer. While for simple examples you'd might be able to get away with scaling all the layers in the original animation, it gets complicated if you have parented layers or transforms applied to some of the layers. Note that in the example below w and h keep their initial value and only the scale is changed. var lottie_player_80 = new PlaygroundPlayer( 80, 'playground_80_1', 'lottie_target_80', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}], \"layers\": [{\"ddd\": 0, \"ty\": 0, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"nm\": \"Precomp Layer\", \"ks\": {}, \"refId\": \"Star\"}], \"meta\": {\"g\": \"Glaxnimate 0.5.0-93-g187709f5\"}}, function (lottie, data) { this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} ); lottie.w = lottie.h = 512 * data[\"Scale\"] / 100; lottie.layers[0].ks.s = { a: 0, k: [ data[\"Scale\"], data[\"Scale\"] ] };","title":"Resizing"},{"location":"breakdown/precomps/#speeding-up-and-slowing-down","text":"Similarly, you can use time stretch to speed up and slow down an animation: var lottie_player_81 = new PlaygroundPlayer( 81, 'playground_81_1', 'lottie_target_81', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}], \"layers\": [{\"ddd\": 0, \"ty\": 0, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"nm\": \"Precomp Layer\", \"ks\": {}, \"refId\": \"Star\"}], \"meta\": {\"g\": \"Glaxnimate 0.5.0-93-g187709f5\"}}, function (lottie, data) { this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} ); var time_mult = 100 / data[\"Speed\"]; lottie.op = 60 * time_mult; lottie.layers[0].op = 60 * time_mult; lottie.layers[0].sr = time_mult; You can also change the start time to delay the start of the precomp playback: var lottie_player_82 = new PlaygroundPlayer( 82, 'playground_82_1', 'lottie_target_82', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}], \"layers\": [{\"ddd\": 0, \"ty\": 0, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"nm\": \"Precomp Layer\", \"ks\": {}, \"refId\": \"Star\"}], \"meta\": {\"g\": \"Glaxnimate 0.5.0-93-g187709f5\"}}, function (lottie, data) { this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} ); var time_mult = 100 / data[\"Speed\"]; var start = data[\"Start\"]; lottie.op = 60 * time_mult + start; lottie.layers[0].op = 60 * time_mult + start; lottie.layers[0].sr = time_mult; lottie.layers[0].st = start;","title":"Speeding up and Slowing down"},{"location":"breakdown/precomps/#reversing-playback","text":"While sr only allows you to speed up and slow down time, with time remapping You can have more interesting effects, such as reversing playback: var lottie_player_83 = new PlaygroundPlayer( 83, 'playground_83_1', 'lottie_target_83', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": 0}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}], \"layers\": [{\"ddd\": 0, \"ty\": 0, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"nm\": \"Precomp Layer\", \"ks\": {}, \"refId\": \"Star\"}], \"meta\": {\"g\": \"Glaxnimate 0.5.0-93-g187709f5\"}}, function (lottie, data) { this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} ); lottie.layers[0].tm = { a: 1, \"k\": [ { \"t\": 0, \"s\": [1], \"o\": { \"x\": 0, \"y\": 0}, \"i\": { \"x\": 1, \"y\": 1} }, { \"t\": 60, \"s\": [0], \"o\": { \"x\": 0, \"y\": 0}, \"i\": { \"x\": 1, \"y\": 1} } ] };","title":"Reversing Playback"},{"location":"breakdown/precomps/#repeated-elements","text":"Another important use for precomps is that they allow to have multiple layers showing the same precomp. In the following example the star is animated once but there are 8 precomp layers with different rotations: var lottie_player_84 = new LottiePlayer( 'lottie_target_84', '../../static/examples/precomp/star-splosion.json', true, {} );","title":"Repeated Elements"},{"location":"breakdown/precomps/#overlaying-animations","text":"Precomps also make it easier to combine multiple files into ones. One thing to keep in mind is if the two files already have assets, you need to ensure their asset identifier are unique, this can be done by overwriting asset id and layer refId properties to some kind of incremental values. In the following example we will overlay the animation from the last example with a different animation. First Animation: Second Animation: Overlaid: var lottie_player_85 = new PlaygroundPlayer( 85, 'playground_85_1', 'lottie_target_85', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": -45}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}, {\"id\": \"Expanding Stars\", \"layers\": [{\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 0}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 45}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 90}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 135}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 180}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -45}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -90}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -135}}}]}, {\"id\": \"Circle\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Layer\", \"mn\": \"{456fdfe5-686b-4006-92f4-951c47ab4bc7}\", \"ks\": {}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{05d5f1a0-6046-4aea-a405-b9ba60a24bd7}\", \"d\": 1, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0, 0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [730, 730]}]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{d835adb4-6502-4e3e-98c2-70d1145f1a23}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [6], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"c\": {\"a\": 0, \"k\": [0.11372549019607843, 0.1568627450980392, 0.2823529411764706]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{78036603-40f1-42ca-ada5-fee506b4ac58}\", \"o\": {\"a\": 1, \"k\": [{\"t\": 30, \"s\": [100], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}}]}]}], \"layers\": [{\"nm\": \"Expanding Stars Layer\", \"refId\": \"Expanding Stars\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {}}, {\"nm\": \"Circle Layer\", \"refId\": \"Circle\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {}}]}, function (lottie, data) { this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} ); If you look at the JSON you'll notice that this is how the structure changed: // First Animation: { \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [ { \"id\": \"Star\", \"layers\": [ /* Star Precomp Layers */ ] } ], \"layers\": [ /* First Animation Layers */ ] } // Second Animation { \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [], \"layers\": [ /* Second Animation Layers */ ] } // Overlaid { \"ip\": 0, \"op\": 60, \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [ { \"id\": \"Star\", \"layers\": [ /* Star Precomp Layers */ ] }, { \"id\": \"Expanding Stars\", \"layers\": [ /* First Animation Layers */ ] }, { \"id\": \"Circle\", \"layers\": [ /* Second Animation Layers */ ] } ], \"layers\": [ { \"nm\": \"Expanding Stars Layer\", \"refId\": \"Expanding Stars\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {} }, { \"nm\": \"Circle Layer\", \"refId\": \"Circle\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {} } ] } In this example the two animations had the same duration and size, you can use the techniques described earlier to resize or retime the animations if you want to overlay animations with different sizes or durations.","title":"Overlaying Animations"},{"location":"breakdown/precomps/#concatenating-animations","text":"This works basically the same as overlaying them, just by changing some timing properties in the precomp layers. var lottie_player_86 = new PlaygroundPlayer( 86, 'playground_86_1', 'lottie_target_86', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": -45}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}, {\"id\": \"Expanding Stars\", \"layers\": [{\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 0}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 45}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 90}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 135}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 180}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -45}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -90}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -135}}}]}, {\"id\": \"Circle\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Layer\", \"mn\": \"{456fdfe5-686b-4006-92f4-951c47ab4bc7}\", \"ks\": {}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{05d5f1a0-6046-4aea-a405-b9ba60a24bd7}\", \"d\": 1, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0, 0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [730, 730]}]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{d835adb4-6502-4e3e-98c2-70d1145f1a23}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [6], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"c\": {\"a\": 0, \"k\": [0.11372549019607843, 0.1568627450980392, 0.2823529411764706]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{78036603-40f1-42ca-ada5-fee506b4ac58}\", \"o\": {\"a\": 1, \"k\": [{\"t\": 30, \"s\": [100], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}}]}]}], \"layers\": [{\"nm\": \"Expanding Stars Layer\", \"refId\": \"Expanding Stars\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {}}, {\"nm\": \"Circle Layer\", \"refId\": \"Circle\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {}}]}, function (lottie, data) { this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} ); lottie.op = 120 lottie.layers[1].ip = 60; lottie.layers[1].op = 120; lottie.layers[1].st = 60;","title":"Concatenating Animations"},{"location":"breakdown/precomps/#masking-animations","text":"Just like any other visual layer, precomp layers can be used for mattes . var lottie_player_87 = new PlaygroundPlayer( 87, 'playground_87_1', 'lottie_target_87', {\"v\": \"5.7.1\", \"ip\": 0, \"op\": 60, \"nm\": \"Animation\", \"mn\": \"{0b14b755-3d9e-4f7f-b7ab-21cd57d13e23}\", \"fr\": 60, \"w\": 512, \"h\": 512, \"assets\": [{\"id\": \"Star\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Shape Layer\", \"mn\": \"{4d57cabf-951f-4067-b50e-8307f9f5fe72}\", \"ks\": {}, \"shapes\": [{\"ty\": \"sr\", \"nm\": \"PolyStar\", \"mn\": \"{c99b4a89-363b-4cd3-8797-bf65b57fdd29}\", \"d\": 1, \"p\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [256, 256], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0, 0]}]}, \"or\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [80], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"ir\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 51, \"s\": [40], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"is\": {\"a\": 0, \"k\": 0}, \"os\": {\"a\": 0, \"k\": 0}, \"r\": {\"a\": 0, \"k\": -45}, \"pt\": {\"a\": 0, \"k\": 5}, \"sy\": 1}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{eb7fbdff-0656-41f5-9337-3aa283dde263}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 0, \"k\": 6}, \"c\": {\"a\": 0, \"k\": [1, 0.3411764705882353, 0.01568627450980392]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{54bfe210-7450-4824-accc-eef8f6c48ae8}\", \"o\": {\"a\": 0, \"k\": 100}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [1, 0.9803921568627451, 0.2823529411764706]}}]}]}, {\"id\": \"Expanding Stars\", \"layers\": [{\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 0}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 45}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 90}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 135}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": 180}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -45}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -90}}}, {\"nm\": \"Precomp Layer\", \"refId\": \"Star\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {\"a\": {\"a\": 0, \"k\": [256, 256]}, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"r\": {\"a\": 0, \"k\": -135}}}]}, {\"id\": \"Circle\", \"layers\": [{\"ddd\": 0, \"ty\": 4, \"ind\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"nm\": \"Layer\", \"mn\": \"{456fdfe5-686b-4006-92f4-951c47ab4bc7}\", \"ks\": {}, \"shapes\": [{\"ty\": \"el\", \"nm\": \"Ellipse\", \"mn\": \"{05d5f1a0-6046-4aea-a405-b9ba60a24bd7}\", \"d\": 1, \"p\": {\"a\": 0, \"k\": [256, 256]}, \"s\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0, 0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [730, 730]}]}}, {\"ty\": \"st\", \"nm\": \"Stroke\", \"mn\": \"{d835adb4-6502-4e3e-98c2-70d1145f1a23}\", \"o\": {\"a\": 0, \"k\": 100}, \"lc\": 2, \"lj\": 2, \"ml\": 0, \"w\": {\"a\": 1, \"k\": [{\"t\": 0, \"s\": [0], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 30, \"s\": [6], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"c\": {\"a\": 0, \"k\": [0.11372549019607843, 0.1568627450980392, 0.2823529411764706]}}, {\"ty\": \"fl\", \"nm\": \"Fill\", \"mn\": \"{78036603-40f1-42ca-ada5-fee506b4ac58}\", \"o\": {\"a\": 1, \"k\": [{\"t\": 30, \"s\": [100], \"h\": 0, \"o\": {\"x\": [0], \"y\": [0]}, \"i\": {\"x\": [1], \"y\": [1]}}, {\"t\": 60, \"s\": [0]}]}, \"r\": 1, \"c\": {\"a\": 0, \"k\": [0.19607843137254902, 0.3137254901960784, 0.6901960784313725]}}]}]}], \"layers\": [{\"nm\": \"Expanding Stars Layer\", \"refId\": \"Expanding Stars\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {}}, {\"nm\": \"Circle Layer\", \"refId\": \"Circle\", \"ty\": 0, \"st\": 0, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ks\": {}}]}, function (lottie, data) { this.json_viewer_contents = {...lottie, assets:[\"...\"]}; }, {} ); lottie.layers[0].td = 1; lottie.layers[1].tt = 1;","title":"Masking Animations"},{"location":"playground/builder/","text":"html, body { min-height: 100vh; } body { display: flex; flex-flow: column; } div[role='main'], body > .container, #playground_layout { width: 100%; height: 100%; padding: 0; margin: 0; flex-grow: 1; display: flex; flex-flow: column; } #playground_layout { display: flex; flex-flow: row; align-items: stretch; padding: 24px } #blockly_div { flex-grow: 1; } #playground_output_container { width: 512px; } #lottie_player { width: 512px; height: 512px } #playground_output { margin: 0; width: 512px; display: flex; flex-flow: column; } #blockly_output { margin: 0; overflow: auto; flex-grow: 1; border: none; } #playground_output_buttons { padding: 0; list-style: none; display: flex; margin-bottom: 0px; } #playground_output_buttons > li > button { border: 1px solid #D9E0E6; padding: 8px; } Save Load Clear Copy JSON Load from URL function save() { localStorage.setItem(\"blockly_lottie\", lottie_blockly.workspace_to_xml_string()); } function load() { lottie_blockly.xml_to_workspace(localStorage.getItem(\"blockly_lottie\")); } function update_code() { var json = lottie_blockly.workspace_to_json(); var output = document.getElementById(\"blockly_output\"); output.value = JSON.stringify(json, null, 4); syntax_edit_update(output, output.value); var anim_data = { container: document.getElementById('lottie_player'), renderer: 'svg', loop: true, autoplay: true, animationData: JSON.parse(output.value) }; var frame = 0; if ( anim != null ) { try { frame = anim.currentFrame } catch (e) {} try { anim.destroy(); } catch (e) {} anim = null; } anim = bodymovin.loadAnimation(anim_data); if ( frame != 0 ) anim.goToAndPlay(frame, true); } function copy_json() { var element = document.getElementById(\"blockly_output\"); var text = element.value; navigator.clipboard.writeText(text); } function copy_xml() { navigator.clipboard.writeText(lottie_blockly.workspace_to_xml_string()); } function parse_json() { lottie_blockly.json_to_workspace(document.getElementById(\"blockly_output\").value); } function load_url_prompt() { var url = prompt(\"URL to a lottie JSON\"); if ( url ) lottie_blockly.load_json_url(url) } var options = { comments: true, toolbox: lottie_toolbox, media: 'https://unpkg.com/blockly/media/', collapse: true, }; var anim = null; var lottie_blockly = new LottieBlockly(options, \"blockly_div\", alert); lottie_blockly.workspace.addChangeListener(update_code); var current_url = new URL(window.location.href); var requested_url = current_url.searchParams.get(\"url\"); if ( requested_url ) lottie_blockly.load_json_url(requested_url); else load();","title":"Builder"},{"location":"playground/json_editor/","text":"import { DotLottie } from \"https://unpkg.com/@lottiefiles/dotlottie-web@0.23.2/dist/index.js\" window.DotLottie = DotLottie; Loading... File New Load from URL... Open File... Load Saved Save Download Edit Undo Redo Search by JSON... Find/Replace... Go to Line... Prettify JSON Lottie View Issues... Go to Next Issue View Lottie Features... View Toggle Wide Layout Preview Background... Renderer lottie-web SVG lottie-web Canvas DotLottie Help View Keyboard Shortcuts Fit in View Normal View Upload File \u00d7 Drop JSON file here Cancel Load from URL \u00d7 Cancel Load Key bindings \u00d7 Close Lottie Features \u00d7 Close function input_error(e, safe = false) { error_container.style.display = \"block\"; loading_div.style.display = \"none\"; clear_element(error_container); error_container.appendChild(document.createTextNode(safe ? e : \"Could not load input!\")); console.error(e); } function input_start() { error_container.style.display = \"none\"; loading_div.style.display = \"block\"; } function lottie_file_input(ev) { input_start(); lottie_receive_files(ev.target.files); } function lottie_receive_files(files) { for ( var i = 0; i < files.length; i++ ) { var file = files[i]; if ( file.type.match(\"application/json\") ) { var reader = new FileReader(); reader.onload = function(e2) { lottie_string_input(e2.target.result, true); document.getElementById(\"dismiss_file_modal\").click(); }; reader.readAsText(file); return; } } input_error(\"Not a JSON file\", true); } function lottie_drop_input(ev) { ev.preventDefault(); if (ev.dataTransfer.items) { input_start(); lottie_receive_files( Array.from(ev.dataTransfer.items) .filter(i => i.kind === 'file') .map(i => i.getAsFile()) ); } } function lottie_url_input(url) { input_start(); fetch(url) .then(r => r.json()) .then(set_editor_json) .catch(input_error); } function set_editor_json(data) { lottie_string_input(JSON.stringify(data, undefined, 4)); } function attach_listener() { lottie_player.anim.addEventListener(\"enterFrame\", (ev) => { frame_slider.value = frame_edit.value = Math.round(lottie_player.anim.currentFrame); }); } function switch_renderer(renderer) { lottie_player.switch_renderer(renderer); attach_listener(); } function on_lottie_update(lottie) { worker.update(lottie); lottie_player.lottie = lottie; frame_slider.min = frame_edit.min = lottie.ip; frame_slider.max = frame_edit.max = lottie.op; lottie_player.reload(); frame_slider.value = frame_edit.value = Math.round(lottie_player.anim.currentFrame); attach_listener(); } function update_frame(value) { value = Number(value); if ( value != Math.round(lottie_player.anim.currentFrame) ) lottie_player.go_to_frame(value); } function pretty() { set_editor_json(lottie_player.lottie); } function lottie_string_input(data, auto_prettify = false) { if ( auto_prettify && data.split(\"\\n\").length < 3 ) { try { data = JSON.parse(data); data = JSON.stringify(data, undefined, 4); } catch (e) {} } editor.set_content(data); error_container.style.display = \"none\"; loading_div.style.display = \"none\"; } function inspect_tree(node) { let children = []; let name = node.name; if ( node.firstChild() ) { while ( true ) { children.push(inspect_tree(node)); if ( !node.nextSibling() ) break; } node.parent() } return { [name]: children }; } function action_save() { localStorage.setItem(\"editor_lottie\", JSON.stringify(lottie_player.lottie)); } function action_load() { set_editor_json(JSON.parse(localStorage.getItem(\"editor_lottie\"))); } function action_new() { set_editor_json({ \"v\": \"5.5.2\", \"fr\": 60, \"ip\": 0, \"op\": 60, \"w\": 512, \"h\": 512, \"ddd\": 0, \"assets\": [], \"fonts\": { \"list\": [] }, \"layers\": [] }); } function action_download() { download_json(lottie_player.lottie, \"lottie.json\"); } function toggle_playback(button) { if ( lottie_player.autoplay ) { lottie_player.pause(); button.title = \"Play\"; button.firstElementChild.setAttribute(\"class\", \"fa-solid fa-play\"); } else { lottie_player.play(); button.title = \"Pause\"; button.firstElementChild.setAttribute(\"class\", \"fa-solid fa-pause\"); } } function toggle_playback_controls() { if ( frame_slider.style.display == \"none\" ) { frame_slider.style.display = \"block\"; frame_edit.style.display = \"block\"; } else { frame_slider.style.display = \"none\"; frame_edit.style.display = \"none\"; } } function refresh_features() { let parent = document.getElementById(\"features_container\"); clear_element(parent); let features = get_features(editor.completions.validation_result); let has_something = false; for ( let what of [\"Layers\", \"Shapes\"] ) { let attr = what.toLowerCase(); if ( features[attr].length ) { has_something = true; parent.appendChild(document.createElement(\"h6\")).appendChild(document.createTextNode(what)); let list = parent.appendChild(document.createElement(\"ul\")); for ( let lay of features[attr] ) { let li = list.appendChild(document.createElement(\"li\")); for ( link of get_validation_links(lay, editor.schema) ) { li.appendChild(link.to_element()); li.appendChild(document.createTextNode(\" \")); } } } } if ( features.features.size ) { has_something = true; parent.appendChild(document.createElement(\"h6\")).appendChild(document.createTextNode(\"Features\")); let list = parent.appendChild(document.createElement(\"ul\")); for ( let feature of features.features ) { let link = list.appendChild(document.createElement(\"li\")).appendChild(document.createElement(\"a\")); link.setAttribute(\"href\", \"https://canilottie.com/\" + feature); link.appendChild(document.createTextNode( feature.split(\"-\").map(f => f[0].toUpperCase() + f.slice(1)).join(\" \") )); } } if ( !has_something ) { parent.appendChild(document.createElement(\"p\")).appendChild(document.createTextNode(\"None Found\")); } } let expr_variables = [\"$bm_rt\", \"time\", \"value\", \"thisProperty\", \"thisComp\", \"thisLayer\"]; let expr_funcs = [\"comp\", \"posterizeTime\", \"timeToFrames\", \"framesToTime\", \"rgbToHsl\", \"hslToRgb\", \"createPath\", \"add\", \"sub\", \"mul\", \"div\", \"mod\", \"clamp\", \"normalize\", \"length\", \"lookAt\", \"seedRandom\", \"random\", \"linear\", \"ease\", \"easeIn\", \"easeOut\", \"degreesToRadians\", \"radiansToDegrees\", \"$bm_sum\", \"sum\", \"$bm_sub\", \"$bm_div\" ]; let frame_slider = document.getElementById(\"frame_slider\"); let frame_edit = document.getElementById(\"frame_edit\"); let editor = new LottieJsonEditor( document.getElementById(\"editor_parent\"), document.getElementById(\"info_box\"), on_lottie_update ); const search_by_json_cmd = search_by_json_factory(); let worker = new LottieJsonWorker(); worker.on(\"schema_loaded\", (data) => { editor.set_schema(Object.assign(new SchemaData(), data.schema)); editor.expression_completions.load_completions(data.expressions) if ( lottie_player.lottie ) worker.update(lottie_player.lottie); }); worker.on(\"result\", data => editor.end_load(data.result)); document.body.addEventListener(\"click\", e => { if ( !e.target.closest(\".info_box_trigger\") && !editor.info_box.element.contains(e.target) ) { editor.hide_info_box_tooltip(); } }); var lottie_player = new LottiePlayer(\"lottie_target\", undefined); let error_container = document.getElementById(\"error_alert\"); let loading_div = document.getElementById(\"loading_alert\"); var data = playground_get_data(); if ( data ) { if ( data[0] == \"{\" ) lottie_string_input(data, true); else lottie_url_input(data); } else if (window.location.search != '' ) { let url = (new URL(window.location)).searchParams.get(\"url\"); if ( url ) lottie_url_input(url); } else { action_new(); } let key_bindings_parent = document.getElementById(\"key_bindings\"); let platform = \"linux\"; let mod = \"Ctrl\"; if ( navigator.platform.indexOf(\"Mac\") != -1 ) { platform = \"mac\"; mode = \"Cmd\"; } else if ( navigator.platform.indexOf(\"Win\") != -1 ) { platform = \"win\"; } for ( arr of editor.view.state.field(CodeMirrorWrapper.keymap) ) { for ( key of arr ) { let seq = key[platform] ?? key.key; if ( seq && key.run.name ) { let row = key_bindings.appendChild(document.createElement(\"tr\")); row.appendChild(document.createElement(\"th\")) .appendChild(document.createTextNode(seq.replace(\"Mod\", mod))); let cmd = key.run.name.replace(/[A-Z]/g, l => \" \" + l) .replace(/^[a-z]/, l => l.toUpperCase()); row.appendChild(document.createElement(\"td\")) .appendChild(document.createTextNode(cmd)); } } }","title":"JSON Editor"}]}